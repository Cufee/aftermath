// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/cufee/aftermath/internal/database/ent/db/account"
	"github.com/cufee/aftermath/internal/database/ent/db/accountsnapshot"
	"github.com/cufee/aftermath/internal/database/ent/db/adevent"
	"github.com/cufee/aftermath/internal/database/ent/db/admessage"
	"github.com/cufee/aftermath/internal/database/ent/db/appconfiguration"
	"github.com/cufee/aftermath/internal/database/ent/db/applicationcommand"
	"github.com/cufee/aftermath/internal/database/ent/db/authnonce"
	"github.com/cufee/aftermath/internal/database/ent/db/clan"
	"github.com/cufee/aftermath/internal/database/ent/db/crontask"
	"github.com/cufee/aftermath/internal/database/ent/db/discordinteraction"
	"github.com/cufee/aftermath/internal/database/ent/db/gamemap"
	"github.com/cufee/aftermath/internal/database/ent/db/gamemode"
	"github.com/cufee/aftermath/internal/database/ent/db/leaderboardscore"
	"github.com/cufee/aftermath/internal/database/ent/db/moderationrequest"
	"github.com/cufee/aftermath/internal/database/ent/db/predicate"
	"github.com/cufee/aftermath/internal/database/ent/db/session"
	"github.com/cufee/aftermath/internal/database/ent/db/user"
	"github.com/cufee/aftermath/internal/database/ent/db/userconnection"
	"github.com/cufee/aftermath/internal/database/ent/db/usercontent"
	"github.com/cufee/aftermath/internal/database/ent/db/usersubscription"
	"github.com/cufee/aftermath/internal/database/ent/db/vehicle"
	"github.com/cufee/aftermath/internal/database/ent/db/vehicleaverage"
	"github.com/cufee/aftermath/internal/database/ent/db/vehiclesnapshot"
	"github.com/cufee/aftermath/internal/database/ent/db/widgetsettings"
	"github.com/cufee/aftermath/internal/database/models"
	"github.com/cufee/aftermath/internal/stats/frame"
	"golang.org/x/text/language"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount            = "Account"
	TypeAccountSnapshot    = "AccountSnapshot"
	TypeAdEvent            = "AdEvent"
	TypeAdMessage          = "AdMessage"
	TypeAppConfiguration   = "AppConfiguration"
	TypeApplicationCommand = "ApplicationCommand"
	TypeAuthNonce          = "AuthNonce"
	TypeClan               = "Clan"
	TypeCronTask           = "CronTask"
	TypeDiscordInteraction = "DiscordInteraction"
	TypeGameMap            = "GameMap"
	TypeGameMode           = "GameMode"
	TypeLeaderboardScore   = "LeaderboardScore"
	TypeModerationRequest  = "ModerationRequest"
	TypeSession            = "Session"
	TypeUser               = "User"
	TypeUserConnection     = "UserConnection"
	TypeUserContent        = "UserContent"
	TypeUserSubscription   = "UserSubscription"
	TypeVehicle            = "Vehicle"
	TypeVehicleAverage     = "VehicleAverage"
	TypeVehicleSnapshot    = "VehicleSnapshot"
	TypeWidgetSettings     = "WidgetSettings"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	last_battle_time         *time.Time
	account_created_at       *time.Time
	realm                    *string
	nickname                 *string
	private                  *bool
	clearedFields            map[string]struct{}
	clan                     *string
	clearedclan              bool
	vehicle_snapshots        map[string]struct{}
	removedvehicle_snapshots map[string]struct{}
	clearedvehicle_snapshots bool
	account_snapshots        map[string]struct{}
	removedaccount_snapshots map[string]struct{}
	clearedaccount_snapshots bool
	done                     bool
	oldValue                 func(context.Context) (*Account, error)
	predicates               []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id string) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastBattleTime sets the "last_battle_time" field.
func (m *AccountMutation) SetLastBattleTime(t time.Time) {
	m.last_battle_time = &t
}

// LastBattleTime returns the value of the "last_battle_time" field in the mutation.
func (m *AccountMutation) LastBattleTime() (r time.Time, exists bool) {
	v := m.last_battle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBattleTime returns the old "last_battle_time" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLastBattleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBattleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBattleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBattleTime: %w", err)
	}
	return oldValue.LastBattleTime, nil
}

// ResetLastBattleTime resets all changes to the "last_battle_time" field.
func (m *AccountMutation) ResetLastBattleTime() {
	m.last_battle_time = nil
}

// SetAccountCreatedAt sets the "account_created_at" field.
func (m *AccountMutation) SetAccountCreatedAt(t time.Time) {
	m.account_created_at = &t
}

// AccountCreatedAt returns the value of the "account_created_at" field in the mutation.
func (m *AccountMutation) AccountCreatedAt() (r time.Time, exists bool) {
	v := m.account_created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountCreatedAt returns the old "account_created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAccountCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountCreatedAt: %w", err)
	}
	return oldValue.AccountCreatedAt, nil
}

// ResetAccountCreatedAt resets all changes to the "account_created_at" field.
func (m *AccountMutation) ResetAccountCreatedAt() {
	m.account_created_at = nil
}

// SetRealm sets the "realm" field.
func (m *AccountMutation) SetRealm(s string) {
	m.realm = &s
}

// Realm returns the value of the "realm" field in the mutation.
func (m *AccountMutation) Realm() (r string, exists bool) {
	v := m.realm
	if v == nil {
		return
	}
	return *v, true
}

// OldRealm returns the old "realm" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRealm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRealm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRealm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRealm: %w", err)
	}
	return oldValue.Realm, nil
}

// ResetRealm resets all changes to the "realm" field.
func (m *AccountMutation) ResetRealm() {
	m.realm = nil
}

// SetNickname sets the "nickname" field.
func (m *AccountMutation) SetNickname(s string) {
	m.nickname = &s
}

// Nickname returns the value of the "nickname" field in the mutation.
func (m *AccountMutation) Nickname() (r string, exists bool) {
	v := m.nickname
	if v == nil {
		return
	}
	return *v, true
}

// OldNickname returns the old "nickname" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldNickname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNickname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNickname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNickname: %w", err)
	}
	return oldValue.Nickname, nil
}

// ResetNickname resets all changes to the "nickname" field.
func (m *AccountMutation) ResetNickname() {
	m.nickname = nil
}

// SetPrivate sets the "private" field.
func (m *AccountMutation) SetPrivate(b bool) {
	m.private = &b
}

// Private returns the value of the "private" field in the mutation.
func (m *AccountMutation) Private() (r bool, exists bool) {
	v := m.private
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivate returns the old "private" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPrivate(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivate: %w", err)
	}
	return oldValue.Private, nil
}

// ResetPrivate resets all changes to the "private" field.
func (m *AccountMutation) ResetPrivate() {
	m.private = nil
}

// SetClanID sets the "clan_id" field.
func (m *AccountMutation) SetClanID(s string) {
	m.clan = &s
}

// ClanID returns the value of the "clan_id" field in the mutation.
func (m *AccountMutation) ClanID() (r string, exists bool) {
	v := m.clan
	if v == nil {
		return
	}
	return *v, true
}

// OldClanID returns the old "clan_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldClanID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClanID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClanID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClanID: %w", err)
	}
	return oldValue.ClanID, nil
}

// ClearClanID clears the value of the "clan_id" field.
func (m *AccountMutation) ClearClanID() {
	m.clan = nil
	m.clearedFields[account.FieldClanID] = struct{}{}
}

// ClanIDCleared returns if the "clan_id" field was cleared in this mutation.
func (m *AccountMutation) ClanIDCleared() bool {
	_, ok := m.clearedFields[account.FieldClanID]
	return ok
}

// ResetClanID resets all changes to the "clan_id" field.
func (m *AccountMutation) ResetClanID() {
	m.clan = nil
	delete(m.clearedFields, account.FieldClanID)
}

// ClearClan clears the "clan" edge to the Clan entity.
func (m *AccountMutation) ClearClan() {
	m.clearedclan = true
	m.clearedFields[account.FieldClanID] = struct{}{}
}

// ClanCleared reports if the "clan" edge to the Clan entity was cleared.
func (m *AccountMutation) ClanCleared() bool {
	return m.ClanIDCleared() || m.clearedclan
}

// ClanIDs returns the "clan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClanID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) ClanIDs() (ids []string) {
	if id := m.clan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClan resets all changes to the "clan" edge.
func (m *AccountMutation) ResetClan() {
	m.clan = nil
	m.clearedclan = false
}

// AddVehicleSnapshotIDs adds the "vehicle_snapshots" edge to the VehicleSnapshot entity by ids.
func (m *AccountMutation) AddVehicleSnapshotIDs(ids ...string) {
	if m.vehicle_snapshots == nil {
		m.vehicle_snapshots = make(map[string]struct{})
	}
	for i := range ids {
		m.vehicle_snapshots[ids[i]] = struct{}{}
	}
}

// ClearVehicleSnapshots clears the "vehicle_snapshots" edge to the VehicleSnapshot entity.
func (m *AccountMutation) ClearVehicleSnapshots() {
	m.clearedvehicle_snapshots = true
}

// VehicleSnapshotsCleared reports if the "vehicle_snapshots" edge to the VehicleSnapshot entity was cleared.
func (m *AccountMutation) VehicleSnapshotsCleared() bool {
	return m.clearedvehicle_snapshots
}

// RemoveVehicleSnapshotIDs removes the "vehicle_snapshots" edge to the VehicleSnapshot entity by IDs.
func (m *AccountMutation) RemoveVehicleSnapshotIDs(ids ...string) {
	if m.removedvehicle_snapshots == nil {
		m.removedvehicle_snapshots = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.vehicle_snapshots, ids[i])
		m.removedvehicle_snapshots[ids[i]] = struct{}{}
	}
}

// RemovedVehicleSnapshots returns the removed IDs of the "vehicle_snapshots" edge to the VehicleSnapshot entity.
func (m *AccountMutation) RemovedVehicleSnapshotsIDs() (ids []string) {
	for id := range m.removedvehicle_snapshots {
		ids = append(ids, id)
	}
	return
}

// VehicleSnapshotsIDs returns the "vehicle_snapshots" edge IDs in the mutation.
func (m *AccountMutation) VehicleSnapshotsIDs() (ids []string) {
	for id := range m.vehicle_snapshots {
		ids = append(ids, id)
	}
	return
}

// ResetVehicleSnapshots resets all changes to the "vehicle_snapshots" edge.
func (m *AccountMutation) ResetVehicleSnapshots() {
	m.vehicle_snapshots = nil
	m.clearedvehicle_snapshots = false
	m.removedvehicle_snapshots = nil
}

// AddAccountSnapshotIDs adds the "account_snapshots" edge to the AccountSnapshot entity by ids.
func (m *AccountMutation) AddAccountSnapshotIDs(ids ...string) {
	if m.account_snapshots == nil {
		m.account_snapshots = make(map[string]struct{})
	}
	for i := range ids {
		m.account_snapshots[ids[i]] = struct{}{}
	}
}

// ClearAccountSnapshots clears the "account_snapshots" edge to the AccountSnapshot entity.
func (m *AccountMutation) ClearAccountSnapshots() {
	m.clearedaccount_snapshots = true
}

// AccountSnapshotsCleared reports if the "account_snapshots" edge to the AccountSnapshot entity was cleared.
func (m *AccountMutation) AccountSnapshotsCleared() bool {
	return m.clearedaccount_snapshots
}

// RemoveAccountSnapshotIDs removes the "account_snapshots" edge to the AccountSnapshot entity by IDs.
func (m *AccountMutation) RemoveAccountSnapshotIDs(ids ...string) {
	if m.removedaccount_snapshots == nil {
		m.removedaccount_snapshots = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.account_snapshots, ids[i])
		m.removedaccount_snapshots[ids[i]] = struct{}{}
	}
}

// RemovedAccountSnapshots returns the removed IDs of the "account_snapshots" edge to the AccountSnapshot entity.
func (m *AccountMutation) RemovedAccountSnapshotsIDs() (ids []string) {
	for id := range m.removedaccount_snapshots {
		ids = append(ids, id)
	}
	return
}

// AccountSnapshotsIDs returns the "account_snapshots" edge IDs in the mutation.
func (m *AccountMutation) AccountSnapshotsIDs() (ids []string) {
	for id := range m.account_snapshots {
		ids = append(ids, id)
	}
	return
}

// ResetAccountSnapshots resets all changes to the "account_snapshots" edge.
func (m *AccountMutation) ResetAccountSnapshots() {
	m.account_snapshots = nil
	m.clearedaccount_snapshots = false
	m.removedaccount_snapshots = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.last_battle_time != nil {
		fields = append(fields, account.FieldLastBattleTime)
	}
	if m.account_created_at != nil {
		fields = append(fields, account.FieldAccountCreatedAt)
	}
	if m.realm != nil {
		fields = append(fields, account.FieldRealm)
	}
	if m.nickname != nil {
		fields = append(fields, account.FieldNickname)
	}
	if m.private != nil {
		fields = append(fields, account.FieldPrivate)
	}
	if m.clan != nil {
		fields = append(fields, account.FieldClanID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldLastBattleTime:
		return m.LastBattleTime()
	case account.FieldAccountCreatedAt:
		return m.AccountCreatedAt()
	case account.FieldRealm:
		return m.Realm()
	case account.FieldNickname:
		return m.Nickname()
	case account.FieldPrivate:
		return m.Private()
	case account.FieldClanID:
		return m.ClanID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldLastBattleTime:
		return m.OldLastBattleTime(ctx)
	case account.FieldAccountCreatedAt:
		return m.OldAccountCreatedAt(ctx)
	case account.FieldRealm:
		return m.OldRealm(ctx)
	case account.FieldNickname:
		return m.OldNickname(ctx)
	case account.FieldPrivate:
		return m.OldPrivate(ctx)
	case account.FieldClanID:
		return m.OldClanID(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldLastBattleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBattleTime(v)
		return nil
	case account.FieldAccountCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountCreatedAt(v)
		return nil
	case account.FieldRealm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRealm(v)
		return nil
	case account.FieldNickname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNickname(v)
		return nil
	case account.FieldPrivate:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivate(v)
		return nil
	case account.FieldClanID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClanID(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldClanID) {
		fields = append(fields, account.FieldClanID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldClanID:
		m.ClearClanID()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldLastBattleTime:
		m.ResetLastBattleTime()
		return nil
	case account.FieldAccountCreatedAt:
		m.ResetAccountCreatedAt()
		return nil
	case account.FieldRealm:
		m.ResetRealm()
		return nil
	case account.FieldNickname:
		m.ResetNickname()
		return nil
	case account.FieldPrivate:
		m.ResetPrivate()
		return nil
	case account.FieldClanID:
		m.ResetClanID()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clan != nil {
		edges = append(edges, account.EdgeClan)
	}
	if m.vehicle_snapshots != nil {
		edges = append(edges, account.EdgeVehicleSnapshots)
	}
	if m.account_snapshots != nil {
		edges = append(edges, account.EdgeAccountSnapshots)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeClan:
		if id := m.clan; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeVehicleSnapshots:
		ids := make([]ent.Value, 0, len(m.vehicle_snapshots))
		for id := range m.vehicle_snapshots {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountSnapshots:
		ids := make([]ent.Value, 0, len(m.account_snapshots))
		for id := range m.account_snapshots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedvehicle_snapshots != nil {
		edges = append(edges, account.EdgeVehicleSnapshots)
	}
	if m.removedaccount_snapshots != nil {
		edges = append(edges, account.EdgeAccountSnapshots)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeVehicleSnapshots:
		ids := make([]ent.Value, 0, len(m.removedvehicle_snapshots))
		for id := range m.removedvehicle_snapshots {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeAccountSnapshots:
		ids := make([]ent.Value, 0, len(m.removedaccount_snapshots))
		for id := range m.removedaccount_snapshots {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclan {
		edges = append(edges, account.EdgeClan)
	}
	if m.clearedvehicle_snapshots {
		edges = append(edges, account.EdgeVehicleSnapshots)
	}
	if m.clearedaccount_snapshots {
		edges = append(edges, account.EdgeAccountSnapshots)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeClan:
		return m.clearedclan
	case account.EdgeVehicleSnapshots:
		return m.clearedvehicle_snapshots
	case account.EdgeAccountSnapshots:
		return m.clearedaccount_snapshots
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeClan:
		m.ClearClan()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeClan:
		m.ResetClan()
		return nil
	case account.EdgeVehicleSnapshots:
		m.ResetVehicleSnapshots()
		return nil
	case account.EdgeAccountSnapshots:
		m.ResetAccountSnapshots()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// AccountSnapshotMutation represents an operation that mutates the AccountSnapshot nodes in the graph.
type AccountSnapshotMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	_type              *models.SnapshotType
	last_battle_time   *time.Time
	reference_id       *string
	rating_battles     *int
	addrating_battles  *int
	rating_frame       *frame.StatsFrame
	regular_battles    *int
	addregular_battles *int
	regular_frame      *frame.StatsFrame
	clearedFields      map[string]struct{}
	account            *string
	clearedaccount     bool
	done               bool
	oldValue           func(context.Context) (*AccountSnapshot, error)
	predicates         []predicate.AccountSnapshot
}

var _ ent.Mutation = (*AccountSnapshotMutation)(nil)

// accountsnapshotOption allows management of the mutation configuration using functional options.
type accountsnapshotOption func(*AccountSnapshotMutation)

// newAccountSnapshotMutation creates new mutation for the AccountSnapshot entity.
func newAccountSnapshotMutation(c config, op Op, opts ...accountsnapshotOption) *AccountSnapshotMutation {
	m := &AccountSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeAccountSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountSnapshotID sets the ID field of the mutation.
func withAccountSnapshotID(id string) accountsnapshotOption {
	return func(m *AccountSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *AccountSnapshot
		)
		m.oldValue = func(ctx context.Context) (*AccountSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccountSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccountSnapshot sets the old AccountSnapshot of the mutation.
func withAccountSnapshot(node *AccountSnapshot) accountsnapshotOption {
	return func(m *AccountSnapshotMutation) {
		m.oldValue = func(context.Context) (*AccountSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccountSnapshot entities.
func (m *AccountSnapshotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountSnapshotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountSnapshotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccountSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *AccountSnapshotMutation) SetType(mt models.SnapshotType) {
	m._type = &mt
}

// GetType returns the value of the "type" field in the mutation.
func (m *AccountSnapshotMutation) GetType() (r models.SnapshotType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldType(ctx context.Context) (v models.SnapshotType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AccountSnapshotMutation) ResetType() {
	m._type = nil
}

// SetLastBattleTime sets the "last_battle_time" field.
func (m *AccountSnapshotMutation) SetLastBattleTime(t time.Time) {
	m.last_battle_time = &t
}

// LastBattleTime returns the value of the "last_battle_time" field in the mutation.
func (m *AccountSnapshotMutation) LastBattleTime() (r time.Time, exists bool) {
	v := m.last_battle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBattleTime returns the old "last_battle_time" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldLastBattleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBattleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBattleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBattleTime: %w", err)
	}
	return oldValue.LastBattleTime, nil
}

// ResetLastBattleTime resets all changes to the "last_battle_time" field.
func (m *AccountSnapshotMutation) ResetLastBattleTime() {
	m.last_battle_time = nil
}

// SetAccountID sets the "account_id" field.
func (m *AccountSnapshotMutation) SetAccountID(s string) {
	m.account = &s
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *AccountSnapshotMutation) AccountID() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *AccountSnapshotMutation) ResetAccountID() {
	m.account = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *AccountSnapshotMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *AccountSnapshotMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *AccountSnapshotMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetRatingBattles sets the "rating_battles" field.
func (m *AccountSnapshotMutation) SetRatingBattles(i int) {
	m.rating_battles = &i
	m.addrating_battles = nil
}

// RatingBattles returns the value of the "rating_battles" field in the mutation.
func (m *AccountSnapshotMutation) RatingBattles() (r int, exists bool) {
	v := m.rating_battles
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingBattles returns the old "rating_battles" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldRatingBattles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingBattles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingBattles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingBattles: %w", err)
	}
	return oldValue.RatingBattles, nil
}

// AddRatingBattles adds i to the "rating_battles" field.
func (m *AccountSnapshotMutation) AddRatingBattles(i int) {
	if m.addrating_battles != nil {
		*m.addrating_battles += i
	} else {
		m.addrating_battles = &i
	}
}

// AddedRatingBattles returns the value that was added to the "rating_battles" field in this mutation.
func (m *AccountSnapshotMutation) AddedRatingBattles() (r int, exists bool) {
	v := m.addrating_battles
	if v == nil {
		return
	}
	return *v, true
}

// ResetRatingBattles resets all changes to the "rating_battles" field.
func (m *AccountSnapshotMutation) ResetRatingBattles() {
	m.rating_battles = nil
	m.addrating_battles = nil
}

// SetRatingFrame sets the "rating_frame" field.
func (m *AccountSnapshotMutation) SetRatingFrame(ff frame.StatsFrame) {
	m.rating_frame = &ff
}

// RatingFrame returns the value of the "rating_frame" field in the mutation.
func (m *AccountSnapshotMutation) RatingFrame() (r frame.StatsFrame, exists bool) {
	v := m.rating_frame
	if v == nil {
		return
	}
	return *v, true
}

// OldRatingFrame returns the old "rating_frame" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldRatingFrame(ctx context.Context) (v frame.StatsFrame, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRatingFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRatingFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRatingFrame: %w", err)
	}
	return oldValue.RatingFrame, nil
}

// ResetRatingFrame resets all changes to the "rating_frame" field.
func (m *AccountSnapshotMutation) ResetRatingFrame() {
	m.rating_frame = nil
}

// SetRegularBattles sets the "regular_battles" field.
func (m *AccountSnapshotMutation) SetRegularBattles(i int) {
	m.regular_battles = &i
	m.addregular_battles = nil
}

// RegularBattles returns the value of the "regular_battles" field in the mutation.
func (m *AccountSnapshotMutation) RegularBattles() (r int, exists bool) {
	v := m.regular_battles
	if v == nil {
		return
	}
	return *v, true
}

// OldRegularBattles returns the old "regular_battles" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldRegularBattles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegularBattles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegularBattles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegularBattles: %w", err)
	}
	return oldValue.RegularBattles, nil
}

// AddRegularBattles adds i to the "regular_battles" field.
func (m *AccountSnapshotMutation) AddRegularBattles(i int) {
	if m.addregular_battles != nil {
		*m.addregular_battles += i
	} else {
		m.addregular_battles = &i
	}
}

// AddedRegularBattles returns the value that was added to the "regular_battles" field in this mutation.
func (m *AccountSnapshotMutation) AddedRegularBattles() (r int, exists bool) {
	v := m.addregular_battles
	if v == nil {
		return
	}
	return *v, true
}

// ResetRegularBattles resets all changes to the "regular_battles" field.
func (m *AccountSnapshotMutation) ResetRegularBattles() {
	m.regular_battles = nil
	m.addregular_battles = nil
}

// SetRegularFrame sets the "regular_frame" field.
func (m *AccountSnapshotMutation) SetRegularFrame(ff frame.StatsFrame) {
	m.regular_frame = &ff
}

// RegularFrame returns the value of the "regular_frame" field in the mutation.
func (m *AccountSnapshotMutation) RegularFrame() (r frame.StatsFrame, exists bool) {
	v := m.regular_frame
	if v == nil {
		return
	}
	return *v, true
}

// OldRegularFrame returns the old "regular_frame" field's value of the AccountSnapshot entity.
// If the AccountSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountSnapshotMutation) OldRegularFrame(ctx context.Context) (v frame.StatsFrame, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegularFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegularFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegularFrame: %w", err)
	}
	return oldValue.RegularFrame, nil
}

// ResetRegularFrame resets all changes to the "regular_frame" field.
func (m *AccountSnapshotMutation) ResetRegularFrame() {
	m.regular_frame = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *AccountSnapshotMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[accountsnapshot.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *AccountSnapshotMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *AccountSnapshotMutation) AccountIDs() (ids []string) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *AccountSnapshotMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the AccountSnapshotMutation builder.
func (m *AccountSnapshotMutation) Where(ps ...predicate.AccountSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccountSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccountSnapshot).
func (m *AccountSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, accountsnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, accountsnapshot.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, accountsnapshot.FieldType)
	}
	if m.last_battle_time != nil {
		fields = append(fields, accountsnapshot.FieldLastBattleTime)
	}
	if m.account != nil {
		fields = append(fields, accountsnapshot.FieldAccountID)
	}
	if m.reference_id != nil {
		fields = append(fields, accountsnapshot.FieldReferenceID)
	}
	if m.rating_battles != nil {
		fields = append(fields, accountsnapshot.FieldRatingBattles)
	}
	if m.rating_frame != nil {
		fields = append(fields, accountsnapshot.FieldRatingFrame)
	}
	if m.regular_battles != nil {
		fields = append(fields, accountsnapshot.FieldRegularBattles)
	}
	if m.regular_frame != nil {
		fields = append(fields, accountsnapshot.FieldRegularFrame)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accountsnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case accountsnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case accountsnapshot.FieldType:
		return m.GetType()
	case accountsnapshot.FieldLastBattleTime:
		return m.LastBattleTime()
	case accountsnapshot.FieldAccountID:
		return m.AccountID()
	case accountsnapshot.FieldReferenceID:
		return m.ReferenceID()
	case accountsnapshot.FieldRatingBattles:
		return m.RatingBattles()
	case accountsnapshot.FieldRatingFrame:
		return m.RatingFrame()
	case accountsnapshot.FieldRegularBattles:
		return m.RegularBattles()
	case accountsnapshot.FieldRegularFrame:
		return m.RegularFrame()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accountsnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case accountsnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case accountsnapshot.FieldType:
		return m.OldType(ctx)
	case accountsnapshot.FieldLastBattleTime:
		return m.OldLastBattleTime(ctx)
	case accountsnapshot.FieldAccountID:
		return m.OldAccountID(ctx)
	case accountsnapshot.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case accountsnapshot.FieldRatingBattles:
		return m.OldRatingBattles(ctx)
	case accountsnapshot.FieldRatingFrame:
		return m.OldRatingFrame(ctx)
	case accountsnapshot.FieldRegularBattles:
		return m.OldRegularBattles(ctx)
	case accountsnapshot.FieldRegularFrame:
		return m.OldRegularFrame(ctx)
	}
	return nil, fmt.Errorf("unknown AccountSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accountsnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case accountsnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case accountsnapshot.FieldType:
		v, ok := value.(models.SnapshotType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case accountsnapshot.FieldLastBattleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBattleTime(v)
		return nil
	case accountsnapshot.FieldAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case accountsnapshot.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case accountsnapshot.FieldRatingBattles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingBattles(v)
		return nil
	case accountsnapshot.FieldRatingFrame:
		v, ok := value.(frame.StatsFrame)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRatingFrame(v)
		return nil
	case accountsnapshot.FieldRegularBattles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegularBattles(v)
		return nil
	case accountsnapshot.FieldRegularFrame:
		v, ok := value.(frame.StatsFrame)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegularFrame(v)
		return nil
	}
	return fmt.Errorf("unknown AccountSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addrating_battles != nil {
		fields = append(fields, accountsnapshot.FieldRatingBattles)
	}
	if m.addregular_battles != nil {
		fields = append(fields, accountsnapshot.FieldRegularBattles)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case accountsnapshot.FieldRatingBattles:
		return m.AddedRatingBattles()
	case accountsnapshot.FieldRegularBattles:
		return m.AddedRegularBattles()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case accountsnapshot.FieldRatingBattles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRatingBattles(v)
		return nil
	case accountsnapshot.FieldRegularBattles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRegularBattles(v)
		return nil
	}
	return fmt.Errorf("unknown AccountSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountSnapshotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountSnapshotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccountSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountSnapshotMutation) ResetField(name string) error {
	switch name {
	case accountsnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case accountsnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case accountsnapshot.FieldType:
		m.ResetType()
		return nil
	case accountsnapshot.FieldLastBattleTime:
		m.ResetLastBattleTime()
		return nil
	case accountsnapshot.FieldAccountID:
		m.ResetAccountID()
		return nil
	case accountsnapshot.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case accountsnapshot.FieldRatingBattles:
		m.ResetRatingBattles()
		return nil
	case accountsnapshot.FieldRatingFrame:
		m.ResetRatingFrame()
		return nil
	case accountsnapshot.FieldRegularBattles:
		m.ResetRegularBattles()
		return nil
	case accountsnapshot.FieldRegularFrame:
		m.ResetRegularFrame()
		return nil
	}
	return fmt.Errorf("unknown AccountSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, accountsnapshot.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accountsnapshot.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, accountsnapshot.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case accountsnapshot.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case accountsnapshot.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case accountsnapshot.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown AccountSnapshot edge %s", name)
}

// AdEventMutation represents an operation that mutates the AdEvent nodes in the graph.
type AdEventMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	user_id       *string
	guild_id      *string
	channel_id    *string
	locale        *string
	message_id    *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AdEvent, error)
	predicates    []predicate.AdEvent
}

var _ ent.Mutation = (*AdEventMutation)(nil)

// adeventOption allows management of the mutation configuration using functional options.
type adeventOption func(*AdEventMutation)

// newAdEventMutation creates new mutation for the AdEvent entity.
func newAdEventMutation(c config, op Op, opts ...adeventOption) *AdEventMutation {
	m := &AdEventMutation{
		config:        c,
		op:            op,
		typ:           TypeAdEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdEventID sets the ID field of the mutation.
func withAdEventID(id string) adeventOption {
	return func(m *AdEventMutation) {
		var (
			err   error
			once  sync.Once
			value *AdEvent
		)
		m.oldValue = func(ctx context.Context) (*AdEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdEvent sets the old AdEvent of the mutation.
func withAdEvent(node *AdEvent) adeventOption {
	return func(m *AdEventMutation) {
		m.oldValue = func(context.Context) (*AdEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdEvent entities.
func (m *AdEventMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdEventMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdEventMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdEventMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdEventMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdEventMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdEventMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdEventMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdEventMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUserID sets the "user_id" field.
func (m *AdEventMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AdEventMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AdEventMutation) ResetUserID() {
	m.user_id = nil
}

// SetGuildID sets the "guild_id" field.
func (m *AdEventMutation) SetGuildID(s string) {
	m.guild_id = &s
}

// GuildID returns the value of the "guild_id" field in the mutation.
func (m *AdEventMutation) GuildID() (r string, exists bool) {
	v := m.guild_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGuildID returns the old "guild_id" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldGuildID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGuildID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGuildID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGuildID: %w", err)
	}
	return oldValue.GuildID, nil
}

// ResetGuildID resets all changes to the "guild_id" field.
func (m *AdEventMutation) ResetGuildID() {
	m.guild_id = nil
}

// SetChannelID sets the "channel_id" field.
func (m *AdEventMutation) SetChannelID(s string) {
	m.channel_id = &s
}

// ChannelID returns the value of the "channel_id" field in the mutation.
func (m *AdEventMutation) ChannelID() (r string, exists bool) {
	v := m.channel_id
	if v == nil {
		return
	}
	return *v, true
}

// OldChannelID returns the old "channel_id" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldChannelID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChannelID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChannelID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChannelID: %w", err)
	}
	return oldValue.ChannelID, nil
}

// ResetChannelID resets all changes to the "channel_id" field.
func (m *AdEventMutation) ResetChannelID() {
	m.channel_id = nil
}

// SetLocale sets the "locale" field.
func (m *AdEventMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *AdEventMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *AdEventMutation) ResetLocale() {
	m.locale = nil
}

// SetMessageID sets the "message_id" field.
func (m *AdEventMutation) SetMessageID(s string) {
	m.message_id = &s
}

// MessageID returns the value of the "message_id" field in the mutation.
func (m *AdEventMutation) MessageID() (r string, exists bool) {
	v := m.message_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageID returns the old "message_id" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldMessageID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageID: %w", err)
	}
	return oldValue.MessageID, nil
}

// ResetMessageID resets all changes to the "message_id" field.
func (m *AdEventMutation) ResetMessageID() {
	m.message_id = nil
}

// SetMetadata sets the "metadata" field.
func (m *AdEventMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AdEventMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AdEvent entity.
// If the AdEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdEventMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AdEventMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[adevent.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AdEventMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[adevent.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AdEventMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, adevent.FieldMetadata)
}

// Where appends a list predicates to the AdEventMutation builder.
func (m *AdEventMutation) Where(ps ...predicate.AdEvent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdEventMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdEventMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdEvent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdEventMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdEventMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdEvent).
func (m *AdEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdEventMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, adevent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adevent.FieldUpdatedAt)
	}
	if m.user_id != nil {
		fields = append(fields, adevent.FieldUserID)
	}
	if m.guild_id != nil {
		fields = append(fields, adevent.FieldGuildID)
	}
	if m.channel_id != nil {
		fields = append(fields, adevent.FieldChannelID)
	}
	if m.locale != nil {
		fields = append(fields, adevent.FieldLocale)
	}
	if m.message_id != nil {
		fields = append(fields, adevent.FieldMessageID)
	}
	if m.metadata != nil {
		fields = append(fields, adevent.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adevent.FieldCreatedAt:
		return m.CreatedAt()
	case adevent.FieldUpdatedAt:
		return m.UpdatedAt()
	case adevent.FieldUserID:
		return m.UserID()
	case adevent.FieldGuildID:
		return m.GuildID()
	case adevent.FieldChannelID:
		return m.ChannelID()
	case adevent.FieldLocale:
		return m.Locale()
	case adevent.FieldMessageID:
		return m.MessageID()
	case adevent.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adevent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adevent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adevent.FieldUserID:
		return m.OldUserID(ctx)
	case adevent.FieldGuildID:
		return m.OldGuildID(ctx)
	case adevent.FieldChannelID:
		return m.OldChannelID(ctx)
	case adevent.FieldLocale:
		return m.OldLocale(ctx)
	case adevent.FieldMessageID:
		return m.OldMessageID(ctx)
	case adevent.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AdEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adevent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adevent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adevent.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case adevent.FieldGuildID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGuildID(v)
		return nil
	case adevent.FieldChannelID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChannelID(v)
		return nil
	case adevent.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case adevent.FieldMessageID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageID(v)
		return nil
	case adevent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AdEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdEventMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adevent.FieldMetadata) {
		fields = append(fields, adevent.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdEventMutation) ClearField(name string) error {
	switch name {
	case adevent.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AdEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdEventMutation) ResetField(name string) error {
	switch name {
	case adevent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adevent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adevent.FieldUserID:
		m.ResetUserID()
		return nil
	case adevent.FieldGuildID:
		m.ResetGuildID()
		return nil
	case adevent.FieldChannelID:
		m.ResetChannelID()
		return nil
	case adevent.FieldLocale:
		m.ResetLocale()
		return nil
	case adevent.FieldMessageID:
		m.ResetMessageID()
		return nil
	case adevent.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AdEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdEventMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdEventMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdEventMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdEventMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdEventMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdEvent edge %s", name)
}

// AdMessageMutation represents an operation that mutates the AdMessage nodes in the graph.
type AdMessageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	enabled       *bool
	weight        *int
	addweight     *int
	chance        *float32
	addchance     *float32
	message       *map[language.Tag]string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AdMessage, error)
	predicates    []predicate.AdMessage
}

var _ ent.Mutation = (*AdMessageMutation)(nil)

// admessageOption allows management of the mutation configuration using functional options.
type admessageOption func(*AdMessageMutation)

// newAdMessageMutation creates new mutation for the AdMessage entity.
func newAdMessageMutation(c config, op Op, opts ...admessageOption) *AdMessageMutation {
	m := &AdMessageMutation{
		config:        c,
		op:            op,
		typ:           TypeAdMessage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdMessageID sets the ID field of the mutation.
func withAdMessageID(id string) admessageOption {
	return func(m *AdMessageMutation) {
		var (
			err   error
			once  sync.Once
			value *AdMessage
		)
		m.oldValue = func(ctx context.Context) (*AdMessage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdMessage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdMessage sets the old AdMessage of the mutation.
func withAdMessage(node *AdMessage) admessageOption {
	return func(m *AdMessageMutation) {
		m.oldValue = func(context.Context) (*AdMessage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdMessageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdMessageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdMessage entities.
func (m *AdMessageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdMessageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdMessageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdMessage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdMessageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdMessageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdMessageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdMessageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdMessageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdMessageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEnabled sets the "enabled" field.
func (m *AdMessageMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *AdMessageMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *AdMessageMutation) ResetEnabled() {
	m.enabled = nil
}

// SetWeight sets the "weight" field.
func (m *AdMessageMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *AdMessageMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *AdMessageMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *AdMessageMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *AdMessageMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetChance sets the "chance" field.
func (m *AdMessageMutation) SetChance(f float32) {
	m.chance = &f
	m.addchance = nil
}

// Chance returns the value of the "chance" field in the mutation.
func (m *AdMessageMutation) Chance() (r float32, exists bool) {
	v := m.chance
	if v == nil {
		return
	}
	return *v, true
}

// OldChance returns the old "chance" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldChance(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChance: %w", err)
	}
	return oldValue.Chance, nil
}

// AddChance adds f to the "chance" field.
func (m *AdMessageMutation) AddChance(f float32) {
	if m.addchance != nil {
		*m.addchance += f
	} else {
		m.addchance = &f
	}
}

// AddedChance returns the value that was added to the "chance" field in this mutation.
func (m *AdMessageMutation) AddedChance() (r float32, exists bool) {
	v := m.addchance
	if v == nil {
		return
	}
	return *v, true
}

// ResetChance resets all changes to the "chance" field.
func (m *AdMessageMutation) ResetChance() {
	m.chance = nil
	m.addchance = nil
}

// SetMessage sets the "message" field.
func (m *AdMessageMutation) SetMessage(value map[language.Tag]string) {
	m.message = &value
}

// Message returns the value of the "message" field in the mutation.
func (m *AdMessageMutation) Message() (r map[language.Tag]string, exists bool) {
	v := m.message
	if v == nil {
		return
	}
	return *v, true
}

// OldMessage returns the old "message" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldMessage(ctx context.Context) (v map[language.Tag]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessage: %w", err)
	}
	return oldValue.Message, nil
}

// ResetMessage resets all changes to the "message" field.
func (m *AdMessageMutation) ResetMessage() {
	m.message = nil
}

// SetMetadata sets the "metadata" field.
func (m *AdMessageMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AdMessageMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AdMessage entity.
// If the AdMessage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdMessageMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AdMessageMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[admessage.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AdMessageMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[admessage.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AdMessageMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, admessage.FieldMetadata)
}

// Where appends a list predicates to the AdMessageMutation builder.
func (m *AdMessageMutation) Where(ps ...predicate.AdMessage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdMessageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdMessageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdMessage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdMessageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdMessageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdMessage).
func (m *AdMessageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdMessageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, admessage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, admessage.FieldUpdatedAt)
	}
	if m.enabled != nil {
		fields = append(fields, admessage.FieldEnabled)
	}
	if m.weight != nil {
		fields = append(fields, admessage.FieldWeight)
	}
	if m.chance != nil {
		fields = append(fields, admessage.FieldChance)
	}
	if m.message != nil {
		fields = append(fields, admessage.FieldMessage)
	}
	if m.metadata != nil {
		fields = append(fields, admessage.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdMessageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case admessage.FieldCreatedAt:
		return m.CreatedAt()
	case admessage.FieldUpdatedAt:
		return m.UpdatedAt()
	case admessage.FieldEnabled:
		return m.Enabled()
	case admessage.FieldWeight:
		return m.Weight()
	case admessage.FieldChance:
		return m.Chance()
	case admessage.FieldMessage:
		return m.Message()
	case admessage.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdMessageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case admessage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case admessage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case admessage.FieldEnabled:
		return m.OldEnabled(ctx)
	case admessage.FieldWeight:
		return m.OldWeight(ctx)
	case admessage.FieldChance:
		return m.OldChance(ctx)
	case admessage.FieldMessage:
		return m.OldMessage(ctx)
	case admessage.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AdMessage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdMessageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case admessage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case admessage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case admessage.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	case admessage.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case admessage.FieldChance:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChance(v)
		return nil
	case admessage.FieldMessage:
		v, ok := value.(map[language.Tag]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessage(v)
		return nil
	case admessage.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AdMessage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdMessageMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, admessage.FieldWeight)
	}
	if m.addchance != nil {
		fields = append(fields, admessage.FieldChance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdMessageMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case admessage.FieldWeight:
		return m.AddedWeight()
	case admessage.FieldChance:
		return m.AddedChance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdMessageMutation) AddField(name string, value ent.Value) error {
	switch name {
	case admessage.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case admessage.FieldChance:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddChance(v)
		return nil
	}
	return fmt.Errorf("unknown AdMessage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdMessageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(admessage.FieldMetadata) {
		fields = append(fields, admessage.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdMessageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdMessageMutation) ClearField(name string) error {
	switch name {
	case admessage.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AdMessage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdMessageMutation) ResetField(name string) error {
	switch name {
	case admessage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case admessage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case admessage.FieldEnabled:
		m.ResetEnabled()
		return nil
	case admessage.FieldWeight:
		m.ResetWeight()
		return nil
	case admessage.FieldChance:
		m.ResetChance()
		return nil
	case admessage.FieldMessage:
		m.ResetMessage()
		return nil
	case admessage.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AdMessage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdMessageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdMessageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdMessageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdMessageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdMessageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdMessageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdMessageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AdMessage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdMessageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AdMessage edge %s", name)
}

// AppConfigurationMutation represents an operation that mutates the AppConfiguration nodes in the graph.
type AppConfigurationMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	key           *string
	value         *any
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AppConfiguration, error)
	predicates    []predicate.AppConfiguration
}

var _ ent.Mutation = (*AppConfigurationMutation)(nil)

// appconfigurationOption allows management of the mutation configuration using functional options.
type appconfigurationOption func(*AppConfigurationMutation)

// newAppConfigurationMutation creates new mutation for the AppConfiguration entity.
func newAppConfigurationMutation(c config, op Op, opts ...appconfigurationOption) *AppConfigurationMutation {
	m := &AppConfigurationMutation{
		config:        c,
		op:            op,
		typ:           TypeAppConfiguration,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppConfigurationID sets the ID field of the mutation.
func withAppConfigurationID(id string) appconfigurationOption {
	return func(m *AppConfigurationMutation) {
		var (
			err   error
			once  sync.Once
			value *AppConfiguration
		)
		m.oldValue = func(ctx context.Context) (*AppConfiguration, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppConfiguration.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppConfiguration sets the old AppConfiguration of the mutation.
func withAppConfiguration(node *AppConfiguration) appconfigurationOption {
	return func(m *AppConfigurationMutation) {
		m.oldValue = func(context.Context) (*AppConfiguration, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppConfigurationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppConfigurationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppConfiguration entities.
func (m *AppConfigurationMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppConfigurationMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppConfigurationMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppConfiguration.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppConfigurationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppConfigurationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppConfiguration entity.
// If the AppConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigurationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppConfigurationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppConfigurationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppConfigurationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppConfiguration entity.
// If the AppConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigurationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppConfigurationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetKey sets the "key" field.
func (m *AppConfigurationMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *AppConfigurationMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the AppConfiguration entity.
// If the AppConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigurationMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *AppConfigurationMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *AppConfigurationMutation) SetValue(a any) {
	m.value = &a
}

// Value returns the value of the "value" field in the mutation.
func (m *AppConfigurationMutation) Value() (r any, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the AppConfiguration entity.
// If the AppConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigurationMutation) OldValue(ctx context.Context) (v any, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *AppConfigurationMutation) ResetValue() {
	m.value = nil
}

// SetMetadata sets the "metadata" field.
func (m *AppConfigurationMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AppConfigurationMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AppConfiguration entity.
// If the AppConfiguration object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppConfigurationMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *AppConfigurationMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[appconfiguration.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *AppConfigurationMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[appconfiguration.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AppConfigurationMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, appconfiguration.FieldMetadata)
}

// Where appends a list predicates to the AppConfigurationMutation builder.
func (m *AppConfigurationMutation) Where(ps ...predicate.AppConfiguration) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppConfigurationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppConfigurationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppConfiguration, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppConfigurationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppConfigurationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppConfiguration).
func (m *AppConfigurationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppConfigurationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, appconfiguration.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appconfiguration.FieldUpdatedAt)
	}
	if m.key != nil {
		fields = append(fields, appconfiguration.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, appconfiguration.FieldValue)
	}
	if m.metadata != nil {
		fields = append(fields, appconfiguration.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppConfigurationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appconfiguration.FieldCreatedAt:
		return m.CreatedAt()
	case appconfiguration.FieldUpdatedAt:
		return m.UpdatedAt()
	case appconfiguration.FieldKey:
		return m.Key()
	case appconfiguration.FieldValue:
		return m.Value()
	case appconfiguration.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppConfigurationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appconfiguration.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appconfiguration.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appconfiguration.FieldKey:
		return m.OldKey(ctx)
	case appconfiguration.FieldValue:
		return m.OldValue(ctx)
	case appconfiguration.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AppConfiguration field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppConfigurationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appconfiguration.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appconfiguration.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appconfiguration.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case appconfiguration.FieldValue:
		v, ok := value.(any)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case appconfiguration.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AppConfiguration field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppConfigurationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppConfigurationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppConfigurationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppConfiguration numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppConfigurationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appconfiguration.FieldMetadata) {
		fields = append(fields, appconfiguration.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppConfigurationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppConfigurationMutation) ClearField(name string) error {
	switch name {
	case appconfiguration.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown AppConfiguration nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppConfigurationMutation) ResetField(name string) error {
	switch name {
	case appconfiguration.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appconfiguration.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appconfiguration.FieldKey:
		m.ResetKey()
		return nil
	case appconfiguration.FieldValue:
		m.ResetValue()
		return nil
	case appconfiguration.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AppConfiguration field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppConfigurationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppConfigurationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppConfigurationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppConfigurationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppConfigurationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppConfigurationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppConfigurationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AppConfiguration unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppConfigurationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AppConfiguration edge %s", name)
}

// ApplicationCommandMutation represents an operation that mutates the ApplicationCommand nodes in the graph.
type ApplicationCommandMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	name          *string
	version       *string
	options_hash  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ApplicationCommand, error)
	predicates    []predicate.ApplicationCommand
}

var _ ent.Mutation = (*ApplicationCommandMutation)(nil)

// applicationcommandOption allows management of the mutation configuration using functional options.
type applicationcommandOption func(*ApplicationCommandMutation)

// newApplicationCommandMutation creates new mutation for the ApplicationCommand entity.
func newApplicationCommandMutation(c config, op Op, opts ...applicationcommandOption) *ApplicationCommandMutation {
	m := &ApplicationCommandMutation{
		config:        c,
		op:            op,
		typ:           TypeApplicationCommand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withApplicationCommandID sets the ID field of the mutation.
func withApplicationCommandID(id string) applicationcommandOption {
	return func(m *ApplicationCommandMutation) {
		var (
			err   error
			once  sync.Once
			value *ApplicationCommand
		)
		m.oldValue = func(ctx context.Context) (*ApplicationCommand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ApplicationCommand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApplicationCommand sets the old ApplicationCommand of the mutation.
func withApplicationCommand(node *ApplicationCommand) applicationcommandOption {
	return func(m *ApplicationCommandMutation) {
		m.oldValue = func(context.Context) (*ApplicationCommand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ApplicationCommandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ApplicationCommandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ApplicationCommand entities.
func (m *ApplicationCommandMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ApplicationCommandMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ApplicationCommandMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ApplicationCommand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ApplicationCommandMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ApplicationCommandMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ApplicationCommand entity.
// If the ApplicationCommand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationCommandMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ApplicationCommandMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ApplicationCommandMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ApplicationCommandMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ApplicationCommand entity.
// If the ApplicationCommand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationCommandMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ApplicationCommandMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *ApplicationCommandMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ApplicationCommandMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ApplicationCommand entity.
// If the ApplicationCommand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationCommandMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ApplicationCommandMutation) ResetName() {
	m.name = nil
}

// SetVersion sets the "version" field.
func (m *ApplicationCommandMutation) SetVersion(s string) {
	m.version = &s
}

// Version returns the value of the "version" field in the mutation.
func (m *ApplicationCommandMutation) Version() (r string, exists bool) {
	v := m.version
	if v == nil {
		return
	}
	return *v, true
}

// OldVersion returns the old "version" field's value of the ApplicationCommand entity.
// If the ApplicationCommand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationCommandMutation) OldVersion(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVersion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVersion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVersion: %w", err)
	}
	return oldValue.Version, nil
}

// ResetVersion resets all changes to the "version" field.
func (m *ApplicationCommandMutation) ResetVersion() {
	m.version = nil
}

// SetOptionsHash sets the "options_hash" field.
func (m *ApplicationCommandMutation) SetOptionsHash(s string) {
	m.options_hash = &s
}

// OptionsHash returns the value of the "options_hash" field in the mutation.
func (m *ApplicationCommandMutation) OptionsHash() (r string, exists bool) {
	v := m.options_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionsHash returns the old "options_hash" field's value of the ApplicationCommand entity.
// If the ApplicationCommand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ApplicationCommandMutation) OldOptionsHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionsHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionsHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionsHash: %w", err)
	}
	return oldValue.OptionsHash, nil
}

// ResetOptionsHash resets all changes to the "options_hash" field.
func (m *ApplicationCommandMutation) ResetOptionsHash() {
	m.options_hash = nil
}

// Where appends a list predicates to the ApplicationCommandMutation builder.
func (m *ApplicationCommandMutation) Where(ps ...predicate.ApplicationCommand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ApplicationCommandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ApplicationCommandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ApplicationCommand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ApplicationCommandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ApplicationCommandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ApplicationCommand).
func (m *ApplicationCommandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ApplicationCommandMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, applicationcommand.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, applicationcommand.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, applicationcommand.FieldName)
	}
	if m.version != nil {
		fields = append(fields, applicationcommand.FieldVersion)
	}
	if m.options_hash != nil {
		fields = append(fields, applicationcommand.FieldOptionsHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ApplicationCommandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case applicationcommand.FieldCreatedAt:
		return m.CreatedAt()
	case applicationcommand.FieldUpdatedAt:
		return m.UpdatedAt()
	case applicationcommand.FieldName:
		return m.Name()
	case applicationcommand.FieldVersion:
		return m.Version()
	case applicationcommand.FieldOptionsHash:
		return m.OptionsHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ApplicationCommandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case applicationcommand.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case applicationcommand.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case applicationcommand.FieldName:
		return m.OldName(ctx)
	case applicationcommand.FieldVersion:
		return m.OldVersion(ctx)
	case applicationcommand.FieldOptionsHash:
		return m.OldOptionsHash(ctx)
	}
	return nil, fmt.Errorf("unknown ApplicationCommand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationCommandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case applicationcommand.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case applicationcommand.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case applicationcommand.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case applicationcommand.FieldVersion:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVersion(v)
		return nil
	case applicationcommand.FieldOptionsHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionsHash(v)
		return nil
	}
	return fmt.Errorf("unknown ApplicationCommand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ApplicationCommandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ApplicationCommandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ApplicationCommandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ApplicationCommand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ApplicationCommandMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ApplicationCommandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ApplicationCommandMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ApplicationCommand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ApplicationCommandMutation) ResetField(name string) error {
	switch name {
	case applicationcommand.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case applicationcommand.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case applicationcommand.FieldName:
		m.ResetName()
		return nil
	case applicationcommand.FieldVersion:
		m.ResetVersion()
		return nil
	case applicationcommand.FieldOptionsHash:
		m.ResetOptionsHash()
		return nil
	}
	return fmt.Errorf("unknown ApplicationCommand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ApplicationCommandMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ApplicationCommandMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ApplicationCommandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ApplicationCommandMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ApplicationCommandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ApplicationCommandMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ApplicationCommandMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ApplicationCommand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ApplicationCommandMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ApplicationCommand edge %s", name)
}

// AuthNonceMutation represents an operation that mutates the AuthNonce nodes in the graph.
type AuthNonceMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	active        *bool
	expires_at    *time.Time
	identifier    *string
	public_id     *string
	metadata      *map[string]string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*AuthNonce, error)
	predicates    []predicate.AuthNonce
}

var _ ent.Mutation = (*AuthNonceMutation)(nil)

// authnonceOption allows management of the mutation configuration using functional options.
type authnonceOption func(*AuthNonceMutation)

// newAuthNonceMutation creates new mutation for the AuthNonce entity.
func newAuthNonceMutation(c config, op Op, opts ...authnonceOption) *AuthNonceMutation {
	m := &AuthNonceMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthNonce,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthNonceID sets the ID field of the mutation.
func withAuthNonceID(id string) authnonceOption {
	return func(m *AuthNonceMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthNonce
		)
		m.oldValue = func(ctx context.Context) (*AuthNonce, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthNonce.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthNonce sets the old AuthNonce of the mutation.
func withAuthNonce(node *AuthNonce) authnonceOption {
	return func(m *AuthNonceMutation) {
		m.oldValue = func(context.Context) (*AuthNonce, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthNonceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthNonceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthNonce entities.
func (m *AuthNonceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthNonceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthNonceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthNonce.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AuthNonceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AuthNonceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AuthNonceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AuthNonceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AuthNonceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AuthNonceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetActive sets the "active" field.
func (m *AuthNonceMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *AuthNonceMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *AuthNonceMutation) ResetActive() {
	m.active = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *AuthNonceMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *AuthNonceMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *AuthNonceMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetIdentifier sets the "identifier" field.
func (m *AuthNonceMutation) SetIdentifier(s string) {
	m.identifier = &s
}

// Identifier returns the value of the "identifier" field in the mutation.
func (m *AuthNonceMutation) Identifier() (r string, exists bool) {
	v := m.identifier
	if v == nil {
		return
	}
	return *v, true
}

// OldIdentifier returns the old "identifier" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldIdentifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIdentifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIdentifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIdentifier: %w", err)
	}
	return oldValue.Identifier, nil
}

// ResetIdentifier resets all changes to the "identifier" field.
func (m *AuthNonceMutation) ResetIdentifier() {
	m.identifier = nil
}

// SetPublicID sets the "public_id" field.
func (m *AuthNonceMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *AuthNonceMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *AuthNonceMutation) ResetPublicID() {
	m.public_id = nil
}

// SetMetadata sets the "metadata" field.
func (m *AuthNonceMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *AuthNonceMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the AuthNonce entity.
// If the AuthNonce object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthNonceMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *AuthNonceMutation) ResetMetadata() {
	m.metadata = nil
}

// Where appends a list predicates to the AuthNonceMutation builder.
func (m *AuthNonceMutation) Where(ps ...predicate.AuthNonce) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthNonceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthNonceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthNonce, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthNonceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthNonceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthNonce).
func (m *AuthNonceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthNonceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, authnonce.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, authnonce.FieldUpdatedAt)
	}
	if m.active != nil {
		fields = append(fields, authnonce.FieldActive)
	}
	if m.expires_at != nil {
		fields = append(fields, authnonce.FieldExpiresAt)
	}
	if m.identifier != nil {
		fields = append(fields, authnonce.FieldIdentifier)
	}
	if m.public_id != nil {
		fields = append(fields, authnonce.FieldPublicID)
	}
	if m.metadata != nil {
		fields = append(fields, authnonce.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthNonceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authnonce.FieldCreatedAt:
		return m.CreatedAt()
	case authnonce.FieldUpdatedAt:
		return m.UpdatedAt()
	case authnonce.FieldActive:
		return m.Active()
	case authnonce.FieldExpiresAt:
		return m.ExpiresAt()
	case authnonce.FieldIdentifier:
		return m.Identifier()
	case authnonce.FieldPublicID:
		return m.PublicID()
	case authnonce.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthNonceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authnonce.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case authnonce.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case authnonce.FieldActive:
		return m.OldActive(ctx)
	case authnonce.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case authnonce.FieldIdentifier:
		return m.OldIdentifier(ctx)
	case authnonce.FieldPublicID:
		return m.OldPublicID(ctx)
	case authnonce.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown AuthNonce field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthNonceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authnonce.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case authnonce.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case authnonce.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case authnonce.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case authnonce.FieldIdentifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIdentifier(v)
		return nil
	case authnonce.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case authnonce.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown AuthNonce field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthNonceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthNonceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthNonceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthNonce numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthNonceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthNonceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthNonceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthNonce nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthNonceMutation) ResetField(name string) error {
	switch name {
	case authnonce.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case authnonce.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case authnonce.FieldActive:
		m.ResetActive()
		return nil
	case authnonce.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case authnonce.FieldIdentifier:
		m.ResetIdentifier()
		return nil
	case authnonce.FieldPublicID:
		m.ResetPublicID()
		return nil
	case authnonce.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown AuthNonce field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthNonceMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthNonceMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthNonceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthNonceMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthNonceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthNonceMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthNonceMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthNonce unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthNonceMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthNonce edge %s", name)
}

// ClanMutation represents an operation that mutates the Clan nodes in the graph.
type ClanMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	tag             *string
	name            *string
	emblem_id       *string
	members         *[]string
	appendmembers   []string
	clearedFields   map[string]struct{}
	accounts        map[string]struct{}
	removedaccounts map[string]struct{}
	clearedaccounts bool
	done            bool
	oldValue        func(context.Context) (*Clan, error)
	predicates      []predicate.Clan
}

var _ ent.Mutation = (*ClanMutation)(nil)

// clanOption allows management of the mutation configuration using functional options.
type clanOption func(*ClanMutation)

// newClanMutation creates new mutation for the Clan entity.
func newClanMutation(c config, op Op, opts ...clanOption) *ClanMutation {
	m := &ClanMutation{
		config:        c,
		op:            op,
		typ:           TypeClan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClanID sets the ID field of the mutation.
func withClanID(id string) clanOption {
	return func(m *ClanMutation) {
		var (
			err   error
			once  sync.Once
			value *Clan
		)
		m.oldValue = func(ctx context.Context) (*Clan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Clan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClan sets the old Clan of the mutation.
func withClan(node *Clan) clanOption {
	return func(m *ClanMutation) {
		m.oldValue = func(context.Context) (*Clan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Clan entities.
func (m *ClanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Clan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ClanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Clan entity.
// If the Clan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ClanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ClanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Clan entity.
// If the Clan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ClanMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTag sets the "tag" field.
func (m *ClanMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *ClanMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Clan entity.
// If the Clan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClanMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ResetTag resets all changes to the "tag" field.
func (m *ClanMutation) ResetTag() {
	m.tag = nil
}

// SetName sets the "name" field.
func (m *ClanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Clan entity.
// If the Clan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClanMutation) ResetName() {
	m.name = nil
}

// SetEmblemID sets the "emblem_id" field.
func (m *ClanMutation) SetEmblemID(s string) {
	m.emblem_id = &s
}

// EmblemID returns the value of the "emblem_id" field in the mutation.
func (m *ClanMutation) EmblemID() (r string, exists bool) {
	v := m.emblem_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEmblemID returns the old "emblem_id" field's value of the Clan entity.
// If the Clan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClanMutation) OldEmblemID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmblemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmblemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmblemID: %w", err)
	}
	return oldValue.EmblemID, nil
}

// ClearEmblemID clears the value of the "emblem_id" field.
func (m *ClanMutation) ClearEmblemID() {
	m.emblem_id = nil
	m.clearedFields[clan.FieldEmblemID] = struct{}{}
}

// EmblemIDCleared returns if the "emblem_id" field was cleared in this mutation.
func (m *ClanMutation) EmblemIDCleared() bool {
	_, ok := m.clearedFields[clan.FieldEmblemID]
	return ok
}

// ResetEmblemID resets all changes to the "emblem_id" field.
func (m *ClanMutation) ResetEmblemID() {
	m.emblem_id = nil
	delete(m.clearedFields, clan.FieldEmblemID)
}

// SetMembers sets the "members" field.
func (m *ClanMutation) SetMembers(s []string) {
	m.members = &s
	m.appendmembers = nil
}

// Members returns the value of the "members" field in the mutation.
func (m *ClanMutation) Members() (r []string, exists bool) {
	v := m.members
	if v == nil {
		return
	}
	return *v, true
}

// OldMembers returns the old "members" field's value of the Clan entity.
// If the Clan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClanMutation) OldMembers(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMembers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMembers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMembers: %w", err)
	}
	return oldValue.Members, nil
}

// AppendMembers adds s to the "members" field.
func (m *ClanMutation) AppendMembers(s []string) {
	m.appendmembers = append(m.appendmembers, s...)
}

// AppendedMembers returns the list of values that were appended to the "members" field in this mutation.
func (m *ClanMutation) AppendedMembers() ([]string, bool) {
	if len(m.appendmembers) == 0 {
		return nil, false
	}
	return m.appendmembers, true
}

// ResetMembers resets all changes to the "members" field.
func (m *ClanMutation) ResetMembers() {
	m.members = nil
	m.appendmembers = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *ClanMutation) AddAccountIDs(ids ...string) {
	if m.accounts == nil {
		m.accounts = make(map[string]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *ClanMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *ClanMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *ClanMutation) RemoveAccountIDs(ids ...string) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *ClanMutation) RemovedAccountsIDs() (ids []string) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *ClanMutation) AccountsIDs() (ids []string) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *ClanMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// Where appends a list predicates to the ClanMutation builder.
func (m *ClanMutation) Where(ps ...predicate.Clan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ClanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ClanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Clan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ClanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ClanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Clan).
func (m *ClanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClanMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, clan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, clan.FieldUpdatedAt)
	}
	if m.tag != nil {
		fields = append(fields, clan.FieldTag)
	}
	if m.name != nil {
		fields = append(fields, clan.FieldName)
	}
	if m.emblem_id != nil {
		fields = append(fields, clan.FieldEmblemID)
	}
	if m.members != nil {
		fields = append(fields, clan.FieldMembers)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clan.FieldCreatedAt:
		return m.CreatedAt()
	case clan.FieldUpdatedAt:
		return m.UpdatedAt()
	case clan.FieldTag:
		return m.Tag()
	case clan.FieldName:
		return m.Name()
	case clan.FieldEmblemID:
		return m.EmblemID()
	case clan.FieldMembers:
		return m.Members()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case clan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case clan.FieldTag:
		return m.OldTag(ctx)
	case clan.FieldName:
		return m.OldName(ctx)
	case clan.FieldEmblemID:
		return m.OldEmblemID(ctx)
	case clan.FieldMembers:
		return m.OldMembers(ctx)
	}
	return nil, fmt.Errorf("unknown Clan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case clan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case clan.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case clan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case clan.FieldEmblemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmblemID(v)
		return nil
	case clan.FieldMembers:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMembers(v)
		return nil
	}
	return fmt.Errorf("unknown Clan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Clan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(clan.FieldEmblemID) {
		fields = append(fields, clan.FieldEmblemID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClanMutation) ClearField(name string) error {
	switch name {
	case clan.FieldEmblemID:
		m.ClearEmblemID()
		return nil
	}
	return fmt.Errorf("unknown Clan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClanMutation) ResetField(name string) error {
	switch name {
	case clan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case clan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case clan.FieldTag:
		m.ResetTag()
		return nil
	case clan.FieldName:
		m.ResetName()
		return nil
	case clan.FieldEmblemID:
		m.ResetEmblemID()
		return nil
	case clan.FieldMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown Clan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClanMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.accounts != nil {
		edges = append(edges, clan.EdgeAccounts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clan.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedaccounts != nil {
		edges = append(edges, clan.EdgeAccounts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clan.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccounts {
		edges = append(edges, clan.EdgeAccounts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClanMutation) EdgeCleared(name string) bool {
	switch name {
	case clan.EdgeAccounts:
		return m.clearedaccounts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Clan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClanMutation) ResetEdge(name string) error {
	switch name {
	case clan.EdgeAccounts:
		m.ResetAccounts()
		return nil
	}
	return fmt.Errorf("unknown Clan edge %s", name)
}

// CronTaskMutation represents an operation that mutates the CronTask nodes in the graph.
type CronTaskMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	_type           *models.TaskType
	reference_id    *string
	targets         *[]string
	appendtargets   []string
	status          *models.TaskStatus
	scheduled_after *time.Time
	last_run        *time.Time
	tries_left      *int
	addtries_left   *int
	logs            *[]models.TaskLog
	appendlogs      []models.TaskLog
	data            *map[string]string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*CronTask, error)
	predicates      []predicate.CronTask
}

var _ ent.Mutation = (*CronTaskMutation)(nil)

// crontaskOption allows management of the mutation configuration using functional options.
type crontaskOption func(*CronTaskMutation)

// newCronTaskMutation creates new mutation for the CronTask entity.
func newCronTaskMutation(c config, op Op, opts ...crontaskOption) *CronTaskMutation {
	m := &CronTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeCronTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCronTaskID sets the ID field of the mutation.
func withCronTaskID(id string) crontaskOption {
	return func(m *CronTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *CronTask
		)
		m.oldValue = func(ctx context.Context) (*CronTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CronTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCronTask sets the old CronTask of the mutation.
func withCronTask(node *CronTask) crontaskOption {
	return func(m *CronTaskMutation) {
		m.oldValue = func(context.Context) (*CronTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CronTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CronTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CronTask entities.
func (m *CronTaskMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CronTaskMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CronTaskMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CronTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *CronTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *CronTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *CronTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *CronTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *CronTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *CronTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *CronTaskMutation) SetType(mt models.TaskType) {
	m._type = &mt
}

// GetType returns the value of the "type" field in the mutation.
func (m *CronTaskMutation) GetType() (r models.TaskType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldType(ctx context.Context) (v models.TaskType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *CronTaskMutation) ResetType() {
	m._type = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *CronTaskMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *CronTaskMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *CronTaskMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetTargets sets the "targets" field.
func (m *CronTaskMutation) SetTargets(s []string) {
	m.targets = &s
	m.appendtargets = nil
}

// Targets returns the value of the "targets" field in the mutation.
func (m *CronTaskMutation) Targets() (r []string, exists bool) {
	v := m.targets
	if v == nil {
		return
	}
	return *v, true
}

// OldTargets returns the old "targets" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldTargets(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargets is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargets: %w", err)
	}
	return oldValue.Targets, nil
}

// AppendTargets adds s to the "targets" field.
func (m *CronTaskMutation) AppendTargets(s []string) {
	m.appendtargets = append(m.appendtargets, s...)
}

// AppendedTargets returns the list of values that were appended to the "targets" field in this mutation.
func (m *CronTaskMutation) AppendedTargets() ([]string, bool) {
	if len(m.appendtargets) == 0 {
		return nil, false
	}
	return m.appendtargets, true
}

// ResetTargets resets all changes to the "targets" field.
func (m *CronTaskMutation) ResetTargets() {
	m.targets = nil
	m.appendtargets = nil
}

// SetStatus sets the "status" field.
func (m *CronTaskMutation) SetStatus(ms models.TaskStatus) {
	m.status = &ms
}

// Status returns the value of the "status" field in the mutation.
func (m *CronTaskMutation) Status() (r models.TaskStatus, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldStatus(ctx context.Context) (v models.TaskStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *CronTaskMutation) ResetStatus() {
	m.status = nil
}

// SetScheduledAfter sets the "scheduled_after" field.
func (m *CronTaskMutation) SetScheduledAfter(t time.Time) {
	m.scheduled_after = &t
}

// ScheduledAfter returns the value of the "scheduled_after" field in the mutation.
func (m *CronTaskMutation) ScheduledAfter() (r time.Time, exists bool) {
	v := m.scheduled_after
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledAfter returns the old "scheduled_after" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldScheduledAfter(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledAfter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledAfter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledAfter: %w", err)
	}
	return oldValue.ScheduledAfter, nil
}

// ResetScheduledAfter resets all changes to the "scheduled_after" field.
func (m *CronTaskMutation) ResetScheduledAfter() {
	m.scheduled_after = nil
}

// SetLastRun sets the "last_run" field.
func (m *CronTaskMutation) SetLastRun(t time.Time) {
	m.last_run = &t
}

// LastRun returns the value of the "last_run" field in the mutation.
func (m *CronTaskMutation) LastRun() (r time.Time, exists bool) {
	v := m.last_run
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRun returns the old "last_run" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldLastRun(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRun is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRun requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRun: %w", err)
	}
	return oldValue.LastRun, nil
}

// ResetLastRun resets all changes to the "last_run" field.
func (m *CronTaskMutation) ResetLastRun() {
	m.last_run = nil
}

// SetTriesLeft sets the "tries_left" field.
func (m *CronTaskMutation) SetTriesLeft(i int) {
	m.tries_left = &i
	m.addtries_left = nil
}

// TriesLeft returns the value of the "tries_left" field in the mutation.
func (m *CronTaskMutation) TriesLeft() (r int, exists bool) {
	v := m.tries_left
	if v == nil {
		return
	}
	return *v, true
}

// OldTriesLeft returns the old "tries_left" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldTriesLeft(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTriesLeft is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTriesLeft requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTriesLeft: %w", err)
	}
	return oldValue.TriesLeft, nil
}

// AddTriesLeft adds i to the "tries_left" field.
func (m *CronTaskMutation) AddTriesLeft(i int) {
	if m.addtries_left != nil {
		*m.addtries_left += i
	} else {
		m.addtries_left = &i
	}
}

// AddedTriesLeft returns the value that was added to the "tries_left" field in this mutation.
func (m *CronTaskMutation) AddedTriesLeft() (r int, exists bool) {
	v := m.addtries_left
	if v == nil {
		return
	}
	return *v, true
}

// ResetTriesLeft resets all changes to the "tries_left" field.
func (m *CronTaskMutation) ResetTriesLeft() {
	m.tries_left = nil
	m.addtries_left = nil
}

// SetLogs sets the "logs" field.
func (m *CronTaskMutation) SetLogs(ml []models.TaskLog) {
	m.logs = &ml
	m.appendlogs = nil
}

// Logs returns the value of the "logs" field in the mutation.
func (m *CronTaskMutation) Logs() (r []models.TaskLog, exists bool) {
	v := m.logs
	if v == nil {
		return
	}
	return *v, true
}

// OldLogs returns the old "logs" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldLogs(ctx context.Context) (v []models.TaskLog, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogs: %w", err)
	}
	return oldValue.Logs, nil
}

// AppendLogs adds ml to the "logs" field.
func (m *CronTaskMutation) AppendLogs(ml []models.TaskLog) {
	m.appendlogs = append(m.appendlogs, ml...)
}

// AppendedLogs returns the list of values that were appended to the "logs" field in this mutation.
func (m *CronTaskMutation) AppendedLogs() ([]models.TaskLog, bool) {
	if len(m.appendlogs) == 0 {
		return nil, false
	}
	return m.appendlogs, true
}

// ResetLogs resets all changes to the "logs" field.
func (m *CronTaskMutation) ResetLogs() {
	m.logs = nil
	m.appendlogs = nil
}

// SetData sets the "data" field.
func (m *CronTaskMutation) SetData(value map[string]string) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *CronTaskMutation) Data() (r map[string]string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the CronTask entity.
// If the CronTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CronTaskMutation) OldData(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *CronTaskMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the CronTaskMutation builder.
func (m *CronTaskMutation) Where(ps ...predicate.CronTask) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CronTaskMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CronTaskMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CronTask, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CronTaskMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CronTaskMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CronTask).
func (m *CronTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CronTaskMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, crontask.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, crontask.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, crontask.FieldType)
	}
	if m.reference_id != nil {
		fields = append(fields, crontask.FieldReferenceID)
	}
	if m.targets != nil {
		fields = append(fields, crontask.FieldTargets)
	}
	if m.status != nil {
		fields = append(fields, crontask.FieldStatus)
	}
	if m.scheduled_after != nil {
		fields = append(fields, crontask.FieldScheduledAfter)
	}
	if m.last_run != nil {
		fields = append(fields, crontask.FieldLastRun)
	}
	if m.tries_left != nil {
		fields = append(fields, crontask.FieldTriesLeft)
	}
	if m.logs != nil {
		fields = append(fields, crontask.FieldLogs)
	}
	if m.data != nil {
		fields = append(fields, crontask.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CronTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case crontask.FieldCreatedAt:
		return m.CreatedAt()
	case crontask.FieldUpdatedAt:
		return m.UpdatedAt()
	case crontask.FieldType:
		return m.GetType()
	case crontask.FieldReferenceID:
		return m.ReferenceID()
	case crontask.FieldTargets:
		return m.Targets()
	case crontask.FieldStatus:
		return m.Status()
	case crontask.FieldScheduledAfter:
		return m.ScheduledAfter()
	case crontask.FieldLastRun:
		return m.LastRun()
	case crontask.FieldTriesLeft:
		return m.TriesLeft()
	case crontask.FieldLogs:
		return m.Logs()
	case crontask.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CronTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case crontask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case crontask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case crontask.FieldType:
		return m.OldType(ctx)
	case crontask.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case crontask.FieldTargets:
		return m.OldTargets(ctx)
	case crontask.FieldStatus:
		return m.OldStatus(ctx)
	case crontask.FieldScheduledAfter:
		return m.OldScheduledAfter(ctx)
	case crontask.FieldLastRun:
		return m.OldLastRun(ctx)
	case crontask.FieldTriesLeft:
		return m.OldTriesLeft(ctx)
	case crontask.FieldLogs:
		return m.OldLogs(ctx)
	case crontask.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown CronTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CronTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case crontask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case crontask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case crontask.FieldType:
		v, ok := value.(models.TaskType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case crontask.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case crontask.FieldTargets:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargets(v)
		return nil
	case crontask.FieldStatus:
		v, ok := value.(models.TaskStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case crontask.FieldScheduledAfter:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledAfter(v)
		return nil
	case crontask.FieldLastRun:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRun(v)
		return nil
	case crontask.FieldTriesLeft:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTriesLeft(v)
		return nil
	case crontask.FieldLogs:
		v, ok := value.([]models.TaskLog)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogs(v)
		return nil
	case crontask.FieldData:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown CronTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CronTaskMutation) AddedFields() []string {
	var fields []string
	if m.addtries_left != nil {
		fields = append(fields, crontask.FieldTriesLeft)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CronTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case crontask.FieldTriesLeft:
		return m.AddedTriesLeft()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CronTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case crontask.FieldTriesLeft:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTriesLeft(v)
		return nil
	}
	return fmt.Errorf("unknown CronTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CronTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CronTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CronTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CronTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CronTaskMutation) ResetField(name string) error {
	switch name {
	case crontask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case crontask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case crontask.FieldType:
		m.ResetType()
		return nil
	case crontask.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case crontask.FieldTargets:
		m.ResetTargets()
		return nil
	case crontask.FieldStatus:
		m.ResetStatus()
		return nil
	case crontask.FieldScheduledAfter:
		m.ResetScheduledAfter()
		return nil
	case crontask.FieldLastRun:
		m.ResetLastRun()
		return nil
	case crontask.FieldTriesLeft:
		m.ResetTriesLeft()
		return nil
	case crontask.FieldLogs:
		m.ResetLogs()
		return nil
	case crontask.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown CronTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CronTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CronTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CronTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CronTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CronTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CronTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CronTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown CronTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CronTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown CronTask edge %s", name)
}

// DiscordInteractionMutation represents an operation that mutates the DiscordInteraction nodes in the graph.
type DiscordInteractionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	command       *string
	reference_id  *string
	_type         *models.DiscordInteractionType
	locale        *string
	options       *models.DiscordInteractionOptions
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*DiscordInteraction, error)
	predicates    []predicate.DiscordInteraction
}

var _ ent.Mutation = (*DiscordInteractionMutation)(nil)

// discordinteractionOption allows management of the mutation configuration using functional options.
type discordinteractionOption func(*DiscordInteractionMutation)

// newDiscordInteractionMutation creates new mutation for the DiscordInteraction entity.
func newDiscordInteractionMutation(c config, op Op, opts ...discordinteractionOption) *DiscordInteractionMutation {
	m := &DiscordInteractionMutation{
		config:        c,
		op:            op,
		typ:           TypeDiscordInteraction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiscordInteractionID sets the ID field of the mutation.
func withDiscordInteractionID(id string) discordinteractionOption {
	return func(m *DiscordInteractionMutation) {
		var (
			err   error
			once  sync.Once
			value *DiscordInteraction
		)
		m.oldValue = func(ctx context.Context) (*DiscordInteraction, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DiscordInteraction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiscordInteraction sets the old DiscordInteraction of the mutation.
func withDiscordInteraction(node *DiscordInteraction) discordinteractionOption {
	return func(m *DiscordInteractionMutation) {
		m.oldValue = func(context.Context) (*DiscordInteraction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiscordInteractionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiscordInteractionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DiscordInteraction entities.
func (m *DiscordInteractionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DiscordInteractionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DiscordInteractionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DiscordInteraction.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *DiscordInteractionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DiscordInteractionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DiscordInteractionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DiscordInteractionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DiscordInteractionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DiscordInteractionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCommand sets the "command" field.
func (m *DiscordInteractionMutation) SetCommand(s string) {
	m.command = &s
}

// Command returns the value of the "command" field in the mutation.
func (m *DiscordInteractionMutation) Command() (r string, exists bool) {
	v := m.command
	if v == nil {
		return
	}
	return *v, true
}

// OldCommand returns the old "command" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldCommand(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommand is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommand requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommand: %w", err)
	}
	return oldValue.Command, nil
}

// ResetCommand resets all changes to the "command" field.
func (m *DiscordInteractionMutation) ResetCommand() {
	m.command = nil
}

// SetUserID sets the "user_id" field.
func (m *DiscordInteractionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *DiscordInteractionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *DiscordInteractionMutation) ResetUserID() {
	m.user = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *DiscordInteractionMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *DiscordInteractionMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *DiscordInteractionMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetType sets the "type" field.
func (m *DiscordInteractionMutation) SetType(mit models.DiscordInteractionType) {
	m._type = &mit
}

// GetType returns the value of the "type" field in the mutation.
func (m *DiscordInteractionMutation) GetType() (r models.DiscordInteractionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldType(ctx context.Context) (v models.DiscordInteractionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *DiscordInteractionMutation) ResetType() {
	m._type = nil
}

// SetLocale sets the "locale" field.
func (m *DiscordInteractionMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *DiscordInteractionMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ResetLocale resets all changes to the "locale" field.
func (m *DiscordInteractionMutation) ResetLocale() {
	m.locale = nil
}

// SetOptions sets the "options" field.
func (m *DiscordInteractionMutation) SetOptions(mio models.DiscordInteractionOptions) {
	m.options = &mio
}

// Options returns the value of the "options" field in the mutation.
func (m *DiscordInteractionMutation) Options() (r models.DiscordInteractionOptions, exists bool) {
	v := m.options
	if v == nil {
		return
	}
	return *v, true
}

// OldOptions returns the old "options" field's value of the DiscordInteraction entity.
// If the DiscordInteraction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DiscordInteractionMutation) OldOptions(ctx context.Context) (v models.DiscordInteractionOptions, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptions: %w", err)
	}
	return oldValue.Options, nil
}

// ResetOptions resets all changes to the "options" field.
func (m *DiscordInteractionMutation) ResetOptions() {
	m.options = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *DiscordInteractionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[discordinteraction.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *DiscordInteractionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *DiscordInteractionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *DiscordInteractionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the DiscordInteractionMutation builder.
func (m *DiscordInteractionMutation) Where(ps ...predicate.DiscordInteraction) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DiscordInteractionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DiscordInteractionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DiscordInteraction, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DiscordInteractionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DiscordInteractionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DiscordInteraction).
func (m *DiscordInteractionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DiscordInteractionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, discordinteraction.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, discordinteraction.FieldUpdatedAt)
	}
	if m.command != nil {
		fields = append(fields, discordinteraction.FieldCommand)
	}
	if m.user != nil {
		fields = append(fields, discordinteraction.FieldUserID)
	}
	if m.reference_id != nil {
		fields = append(fields, discordinteraction.FieldReferenceID)
	}
	if m._type != nil {
		fields = append(fields, discordinteraction.FieldType)
	}
	if m.locale != nil {
		fields = append(fields, discordinteraction.FieldLocale)
	}
	if m.options != nil {
		fields = append(fields, discordinteraction.FieldOptions)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DiscordInteractionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case discordinteraction.FieldCreatedAt:
		return m.CreatedAt()
	case discordinteraction.FieldUpdatedAt:
		return m.UpdatedAt()
	case discordinteraction.FieldCommand:
		return m.Command()
	case discordinteraction.FieldUserID:
		return m.UserID()
	case discordinteraction.FieldReferenceID:
		return m.ReferenceID()
	case discordinteraction.FieldType:
		return m.GetType()
	case discordinteraction.FieldLocale:
		return m.Locale()
	case discordinteraction.FieldOptions:
		return m.Options()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DiscordInteractionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case discordinteraction.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case discordinteraction.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case discordinteraction.FieldCommand:
		return m.OldCommand(ctx)
	case discordinteraction.FieldUserID:
		return m.OldUserID(ctx)
	case discordinteraction.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case discordinteraction.FieldType:
		return m.OldType(ctx)
	case discordinteraction.FieldLocale:
		return m.OldLocale(ctx)
	case discordinteraction.FieldOptions:
		return m.OldOptions(ctx)
	}
	return nil, fmt.Errorf("unknown DiscordInteraction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordInteractionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case discordinteraction.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case discordinteraction.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case discordinteraction.FieldCommand:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommand(v)
		return nil
	case discordinteraction.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case discordinteraction.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case discordinteraction.FieldType:
		v, ok := value.(models.DiscordInteractionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case discordinteraction.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case discordinteraction.FieldOptions:
		v, ok := value.(models.DiscordInteractionOptions)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptions(v)
		return nil
	}
	return fmt.Errorf("unknown DiscordInteraction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DiscordInteractionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DiscordInteractionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DiscordInteractionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DiscordInteraction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DiscordInteractionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DiscordInteractionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiscordInteractionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DiscordInteraction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DiscordInteractionMutation) ResetField(name string) error {
	switch name {
	case discordinteraction.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case discordinteraction.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case discordinteraction.FieldCommand:
		m.ResetCommand()
		return nil
	case discordinteraction.FieldUserID:
		m.ResetUserID()
		return nil
	case discordinteraction.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case discordinteraction.FieldType:
		m.ResetType()
		return nil
	case discordinteraction.FieldLocale:
		m.ResetLocale()
		return nil
	case discordinteraction.FieldOptions:
		m.ResetOptions()
		return nil
	}
	return fmt.Errorf("unknown DiscordInteraction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DiscordInteractionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, discordinteraction.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DiscordInteractionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case discordinteraction.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DiscordInteractionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DiscordInteractionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DiscordInteractionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, discordinteraction.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DiscordInteractionMutation) EdgeCleared(name string) bool {
	switch name {
	case discordinteraction.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DiscordInteractionMutation) ClearEdge(name string) error {
	switch name {
	case discordinteraction.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown DiscordInteraction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DiscordInteractionMutation) ResetEdge(name string) error {
	switch name {
	case discordinteraction.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown DiscordInteraction edge %s", name)
}

// GameMapMutation represents an operation that mutates the GameMap nodes in the graph.
type GameMapMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	created_at          *time.Time
	updated_at          *time.Time
	game_modes          *[]int
	appendgame_modes    []int
	supremacy_points    *int
	addsupremacy_points *int
	localized_names     *map[language.Tag]string
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*GameMap, error)
	predicates          []predicate.GameMap
}

var _ ent.Mutation = (*GameMapMutation)(nil)

// gamemapOption allows management of the mutation configuration using functional options.
type gamemapOption func(*GameMapMutation)

// newGameMapMutation creates new mutation for the GameMap entity.
func newGameMapMutation(c config, op Op, opts ...gamemapOption) *GameMapMutation {
	m := &GameMapMutation{
		config:        c,
		op:            op,
		typ:           TypeGameMap,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameMapID sets the ID field of the mutation.
func withGameMapID(id string) gamemapOption {
	return func(m *GameMapMutation) {
		var (
			err   error
			once  sync.Once
			value *GameMap
		)
		m.oldValue = func(ctx context.Context) (*GameMap, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameMap.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameMap sets the old GameMap of the mutation.
func withGameMap(node *GameMap) gamemapOption {
	return func(m *GameMapMutation) {
		m.oldValue = func(context.Context) (*GameMap, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameMapMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameMapMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameMap entities.
func (m *GameMapMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameMapMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameMapMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameMap.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GameMapMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameMapMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GameMap entity.
// If the GameMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMapMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameMapMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GameMapMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GameMapMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GameMap entity.
// If the GameMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMapMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GameMapMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetGameModes sets the "game_modes" field.
func (m *GameMapMutation) SetGameModes(i []int) {
	m.game_modes = &i
	m.appendgame_modes = nil
}

// GameModes returns the value of the "game_modes" field in the mutation.
func (m *GameMapMutation) GameModes() (r []int, exists bool) {
	v := m.game_modes
	if v == nil {
		return
	}
	return *v, true
}

// OldGameModes returns the old "game_modes" field's value of the GameMap entity.
// If the GameMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMapMutation) OldGameModes(ctx context.Context) (v []int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGameModes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGameModes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGameModes: %w", err)
	}
	return oldValue.GameModes, nil
}

// AppendGameModes adds i to the "game_modes" field.
func (m *GameMapMutation) AppendGameModes(i []int) {
	m.appendgame_modes = append(m.appendgame_modes, i...)
}

// AppendedGameModes returns the list of values that were appended to the "game_modes" field in this mutation.
func (m *GameMapMutation) AppendedGameModes() ([]int, bool) {
	if len(m.appendgame_modes) == 0 {
		return nil, false
	}
	return m.appendgame_modes, true
}

// ResetGameModes resets all changes to the "game_modes" field.
func (m *GameMapMutation) ResetGameModes() {
	m.game_modes = nil
	m.appendgame_modes = nil
}

// SetSupremacyPoints sets the "supremacy_points" field.
func (m *GameMapMutation) SetSupremacyPoints(i int) {
	m.supremacy_points = &i
	m.addsupremacy_points = nil
}

// SupremacyPoints returns the value of the "supremacy_points" field in the mutation.
func (m *GameMapMutation) SupremacyPoints() (r int, exists bool) {
	v := m.supremacy_points
	if v == nil {
		return
	}
	return *v, true
}

// OldSupremacyPoints returns the old "supremacy_points" field's value of the GameMap entity.
// If the GameMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMapMutation) OldSupremacyPoints(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSupremacyPoints is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSupremacyPoints requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSupremacyPoints: %w", err)
	}
	return oldValue.SupremacyPoints, nil
}

// AddSupremacyPoints adds i to the "supremacy_points" field.
func (m *GameMapMutation) AddSupremacyPoints(i int) {
	if m.addsupremacy_points != nil {
		*m.addsupremacy_points += i
	} else {
		m.addsupremacy_points = &i
	}
}

// AddedSupremacyPoints returns the value that was added to the "supremacy_points" field in this mutation.
func (m *GameMapMutation) AddedSupremacyPoints() (r int, exists bool) {
	v := m.addsupremacy_points
	if v == nil {
		return
	}
	return *v, true
}

// ResetSupremacyPoints resets all changes to the "supremacy_points" field.
func (m *GameMapMutation) ResetSupremacyPoints() {
	m.supremacy_points = nil
	m.addsupremacy_points = nil
}

// SetLocalizedNames sets the "localized_names" field.
func (m *GameMapMutation) SetLocalizedNames(value map[language.Tag]string) {
	m.localized_names = &value
}

// LocalizedNames returns the value of the "localized_names" field in the mutation.
func (m *GameMapMutation) LocalizedNames() (r map[language.Tag]string, exists bool) {
	v := m.localized_names
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalizedNames returns the old "localized_names" field's value of the GameMap entity.
// If the GameMap object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameMapMutation) OldLocalizedNames(ctx context.Context) (v map[language.Tag]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalizedNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalizedNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalizedNames: %w", err)
	}
	return oldValue.LocalizedNames, nil
}

// ResetLocalizedNames resets all changes to the "localized_names" field.
func (m *GameMapMutation) ResetLocalizedNames() {
	m.localized_names = nil
}

// Where appends a list predicates to the GameMapMutation builder.
func (m *GameMapMutation) Where(ps ...predicate.GameMap) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameMapMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameMapMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameMap, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameMapMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameMapMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameMap).
func (m *GameMapMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameMapMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, gamemap.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gamemap.FieldUpdatedAt)
	}
	if m.game_modes != nil {
		fields = append(fields, gamemap.FieldGameModes)
	}
	if m.supremacy_points != nil {
		fields = append(fields, gamemap.FieldSupremacyPoints)
	}
	if m.localized_names != nil {
		fields = append(fields, gamemap.FieldLocalizedNames)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameMapMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamemap.FieldCreatedAt:
		return m.CreatedAt()
	case gamemap.FieldUpdatedAt:
		return m.UpdatedAt()
	case gamemap.FieldGameModes:
		return m.GameModes()
	case gamemap.FieldSupremacyPoints:
		return m.SupremacyPoints()
	case gamemap.FieldLocalizedNames:
		return m.LocalizedNames()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameMapMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamemap.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gamemap.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gamemap.FieldGameModes:
		return m.OldGameModes(ctx)
	case gamemap.FieldSupremacyPoints:
		return m.OldSupremacyPoints(ctx)
	case gamemap.FieldLocalizedNames:
		return m.OldLocalizedNames(ctx)
	}
	return nil, fmt.Errorf("unknown GameMap field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMapMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamemap.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gamemap.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gamemap.FieldGameModes:
		v, ok := value.([]int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGameModes(v)
		return nil
	case gamemap.FieldSupremacyPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSupremacyPoints(v)
		return nil
	case gamemap.FieldLocalizedNames:
		v, ok := value.(map[language.Tag]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalizedNames(v)
		return nil
	}
	return fmt.Errorf("unknown GameMap field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameMapMutation) AddedFields() []string {
	var fields []string
	if m.addsupremacy_points != nil {
		fields = append(fields, gamemap.FieldSupremacyPoints)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameMapMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case gamemap.FieldSupremacyPoints:
		return m.AddedSupremacyPoints()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameMapMutation) AddField(name string, value ent.Value) error {
	switch name {
	case gamemap.FieldSupremacyPoints:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSupremacyPoints(v)
		return nil
	}
	return fmt.Errorf("unknown GameMap numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameMapMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameMapMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameMapMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameMap nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameMapMutation) ResetField(name string) error {
	switch name {
	case gamemap.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gamemap.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gamemap.FieldGameModes:
		m.ResetGameModes()
		return nil
	case gamemap.FieldSupremacyPoints:
		m.ResetSupremacyPoints()
		return nil
	case gamemap.FieldLocalizedNames:
		m.ResetLocalizedNames()
		return nil
	}
	return fmt.Errorf("unknown GameMap field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameMapMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameMapMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameMapMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameMapMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameMapMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameMapMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameMapMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GameMap unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameMapMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GameMap edge %s", name)
}

// GameModeMutation represents an operation that mutates the GameMode nodes in the graph.
type GameModeMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	localized_names *map[language.Tag]string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*GameMode, error)
	predicates      []predicate.GameMode
}

var _ ent.Mutation = (*GameModeMutation)(nil)

// gamemodeOption allows management of the mutation configuration using functional options.
type gamemodeOption func(*GameModeMutation)

// newGameModeMutation creates new mutation for the GameMode entity.
func newGameModeMutation(c config, op Op, opts ...gamemodeOption) *GameModeMutation {
	m := &GameModeMutation{
		config:        c,
		op:            op,
		typ:           TypeGameMode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGameModeID sets the ID field of the mutation.
func withGameModeID(id string) gamemodeOption {
	return func(m *GameModeMutation) {
		var (
			err   error
			once  sync.Once
			value *GameMode
		)
		m.oldValue = func(ctx context.Context) (*GameMode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().GameMode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGameMode sets the old GameMode of the mutation.
func withGameMode(node *GameMode) gamemodeOption {
	return func(m *GameModeMutation) {
		m.oldValue = func(context.Context) (*GameMode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GameModeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GameModeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of GameMode entities.
func (m *GameModeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *GameModeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *GameModeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().GameMode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *GameModeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *GameModeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the GameMode entity.
// If the GameMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameModeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *GameModeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *GameModeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *GameModeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the GameMode entity.
// If the GameMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameModeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *GameModeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLocalizedNames sets the "localized_names" field.
func (m *GameModeMutation) SetLocalizedNames(value map[language.Tag]string) {
	m.localized_names = &value
}

// LocalizedNames returns the value of the "localized_names" field in the mutation.
func (m *GameModeMutation) LocalizedNames() (r map[language.Tag]string, exists bool) {
	v := m.localized_names
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalizedNames returns the old "localized_names" field's value of the GameMode entity.
// If the GameMode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *GameModeMutation) OldLocalizedNames(ctx context.Context) (v map[language.Tag]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalizedNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalizedNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalizedNames: %w", err)
	}
	return oldValue.LocalizedNames, nil
}

// ResetLocalizedNames resets all changes to the "localized_names" field.
func (m *GameModeMutation) ResetLocalizedNames() {
	m.localized_names = nil
}

// Where appends a list predicates to the GameModeMutation builder.
func (m *GameModeMutation) Where(ps ...predicate.GameMode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the GameModeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *GameModeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.GameMode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *GameModeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *GameModeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (GameMode).
func (m *GameModeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *GameModeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, gamemode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, gamemode.FieldUpdatedAt)
	}
	if m.localized_names != nil {
		fields = append(fields, gamemode.FieldLocalizedNames)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *GameModeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gamemode.FieldCreatedAt:
		return m.CreatedAt()
	case gamemode.FieldUpdatedAt:
		return m.UpdatedAt()
	case gamemode.FieldLocalizedNames:
		return m.LocalizedNames()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *GameModeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gamemode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case gamemode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case gamemode.FieldLocalizedNames:
		return m.OldLocalizedNames(ctx)
	}
	return nil, fmt.Errorf("unknown GameMode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameModeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gamemode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case gamemode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case gamemode.FieldLocalizedNames:
		v, ok := value.(map[language.Tag]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalizedNames(v)
		return nil
	}
	return fmt.Errorf("unknown GameMode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *GameModeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *GameModeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *GameModeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown GameMode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *GameModeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *GameModeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *GameModeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown GameMode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *GameModeMutation) ResetField(name string) error {
	switch name {
	case gamemode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case gamemode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case gamemode.FieldLocalizedNames:
		m.ResetLocalizedNames()
		return nil
	}
	return fmt.Errorf("unknown GameMode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *GameModeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *GameModeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *GameModeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *GameModeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *GameModeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *GameModeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *GameModeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown GameMode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *GameModeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown GameMode edge %s", name)
}

// LeaderboardScoreMutation represents an operation that mutates the LeaderboardScore nodes in the graph.
type LeaderboardScoreMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	_type          *models.ScoreType
	score          *float32
	addscore       *float32
	reference_id   *string
	leaderboard_id *string
	meta           *map[string]interface{}
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*LeaderboardScore, error)
	predicates     []predicate.LeaderboardScore
}

var _ ent.Mutation = (*LeaderboardScoreMutation)(nil)

// leaderboardscoreOption allows management of the mutation configuration using functional options.
type leaderboardscoreOption func(*LeaderboardScoreMutation)

// newLeaderboardScoreMutation creates new mutation for the LeaderboardScore entity.
func newLeaderboardScoreMutation(c config, op Op, opts ...leaderboardscoreOption) *LeaderboardScoreMutation {
	m := &LeaderboardScoreMutation{
		config:        c,
		op:            op,
		typ:           TypeLeaderboardScore,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLeaderboardScoreID sets the ID field of the mutation.
func withLeaderboardScoreID(id string) leaderboardscoreOption {
	return func(m *LeaderboardScoreMutation) {
		var (
			err   error
			once  sync.Once
			value *LeaderboardScore
		)
		m.oldValue = func(ctx context.Context) (*LeaderboardScore, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LeaderboardScore.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLeaderboardScore sets the old LeaderboardScore of the mutation.
func withLeaderboardScore(node *LeaderboardScore) leaderboardscoreOption {
	return func(m *LeaderboardScoreMutation) {
		m.oldValue = func(context.Context) (*LeaderboardScore, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LeaderboardScoreMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LeaderboardScoreMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LeaderboardScore entities.
func (m *LeaderboardScoreMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LeaderboardScoreMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LeaderboardScoreMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LeaderboardScore.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *LeaderboardScoreMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LeaderboardScoreMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LeaderboardScoreMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *LeaderboardScoreMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *LeaderboardScoreMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *LeaderboardScoreMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *LeaderboardScoreMutation) SetType(mt models.ScoreType) {
	m._type = &mt
}

// GetType returns the value of the "type" field in the mutation.
func (m *LeaderboardScoreMutation) GetType() (r models.ScoreType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldType(ctx context.Context) (v models.ScoreType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *LeaderboardScoreMutation) ResetType() {
	m._type = nil
}

// SetScore sets the "score" field.
func (m *LeaderboardScoreMutation) SetScore(f float32) {
	m.score = &f
	m.addscore = nil
}

// Score returns the value of the "score" field in the mutation.
func (m *LeaderboardScoreMutation) Score() (r float32, exists bool) {
	v := m.score
	if v == nil {
		return
	}
	return *v, true
}

// OldScore returns the old "score" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldScore(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScore is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScore requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScore: %w", err)
	}
	return oldValue.Score, nil
}

// AddScore adds f to the "score" field.
func (m *LeaderboardScoreMutation) AddScore(f float32) {
	if m.addscore != nil {
		*m.addscore += f
	} else {
		m.addscore = &f
	}
}

// AddedScore returns the value that was added to the "score" field in this mutation.
func (m *LeaderboardScoreMutation) AddedScore() (r float32, exists bool) {
	v := m.addscore
	if v == nil {
		return
	}
	return *v, true
}

// ResetScore resets all changes to the "score" field.
func (m *LeaderboardScoreMutation) ResetScore() {
	m.score = nil
	m.addscore = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *LeaderboardScoreMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *LeaderboardScoreMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *LeaderboardScoreMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetLeaderboardID sets the "leaderboard_id" field.
func (m *LeaderboardScoreMutation) SetLeaderboardID(s string) {
	m.leaderboard_id = &s
}

// LeaderboardID returns the value of the "leaderboard_id" field in the mutation.
func (m *LeaderboardScoreMutation) LeaderboardID() (r string, exists bool) {
	v := m.leaderboard_id
	if v == nil {
		return
	}
	return *v, true
}

// OldLeaderboardID returns the old "leaderboard_id" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldLeaderboardID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLeaderboardID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLeaderboardID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLeaderboardID: %w", err)
	}
	return oldValue.LeaderboardID, nil
}

// ResetLeaderboardID resets all changes to the "leaderboard_id" field.
func (m *LeaderboardScoreMutation) ResetLeaderboardID() {
	m.leaderboard_id = nil
}

// SetMeta sets the "meta" field.
func (m *LeaderboardScoreMutation) SetMeta(value map[string]interface{}) {
	m.meta = &value
}

// Meta returns the value of the "meta" field in the mutation.
func (m *LeaderboardScoreMutation) Meta() (r map[string]interface{}, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the LeaderboardScore entity.
// If the LeaderboardScore object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LeaderboardScoreMutation) OldMeta(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// ResetMeta resets all changes to the "meta" field.
func (m *LeaderboardScoreMutation) ResetMeta() {
	m.meta = nil
}

// Where appends a list predicates to the LeaderboardScoreMutation builder.
func (m *LeaderboardScoreMutation) Where(ps ...predicate.LeaderboardScore) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LeaderboardScoreMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LeaderboardScoreMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LeaderboardScore, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LeaderboardScoreMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LeaderboardScoreMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LeaderboardScore).
func (m *LeaderboardScoreMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LeaderboardScoreMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, leaderboardscore.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, leaderboardscore.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, leaderboardscore.FieldType)
	}
	if m.score != nil {
		fields = append(fields, leaderboardscore.FieldScore)
	}
	if m.reference_id != nil {
		fields = append(fields, leaderboardscore.FieldReferenceID)
	}
	if m.leaderboard_id != nil {
		fields = append(fields, leaderboardscore.FieldLeaderboardID)
	}
	if m.meta != nil {
		fields = append(fields, leaderboardscore.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LeaderboardScoreMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case leaderboardscore.FieldCreatedAt:
		return m.CreatedAt()
	case leaderboardscore.FieldUpdatedAt:
		return m.UpdatedAt()
	case leaderboardscore.FieldType:
		return m.GetType()
	case leaderboardscore.FieldScore:
		return m.Score()
	case leaderboardscore.FieldReferenceID:
		return m.ReferenceID()
	case leaderboardscore.FieldLeaderboardID:
		return m.LeaderboardID()
	case leaderboardscore.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LeaderboardScoreMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case leaderboardscore.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case leaderboardscore.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case leaderboardscore.FieldType:
		return m.OldType(ctx)
	case leaderboardscore.FieldScore:
		return m.OldScore(ctx)
	case leaderboardscore.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case leaderboardscore.FieldLeaderboardID:
		return m.OldLeaderboardID(ctx)
	case leaderboardscore.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown LeaderboardScore field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaderboardScoreMutation) SetField(name string, value ent.Value) error {
	switch name {
	case leaderboardscore.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case leaderboardscore.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case leaderboardscore.FieldType:
		v, ok := value.(models.ScoreType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case leaderboardscore.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScore(v)
		return nil
	case leaderboardscore.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case leaderboardscore.FieldLeaderboardID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLeaderboardID(v)
		return nil
	case leaderboardscore.FieldMeta:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown LeaderboardScore field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LeaderboardScoreMutation) AddedFields() []string {
	var fields []string
	if m.addscore != nil {
		fields = append(fields, leaderboardscore.FieldScore)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LeaderboardScoreMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case leaderboardscore.FieldScore:
		return m.AddedScore()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LeaderboardScoreMutation) AddField(name string, value ent.Value) error {
	switch name {
	case leaderboardscore.FieldScore:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddScore(v)
		return nil
	}
	return fmt.Errorf("unknown LeaderboardScore numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LeaderboardScoreMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LeaderboardScoreMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LeaderboardScoreMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LeaderboardScore nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LeaderboardScoreMutation) ResetField(name string) error {
	switch name {
	case leaderboardscore.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case leaderboardscore.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case leaderboardscore.FieldType:
		m.ResetType()
		return nil
	case leaderboardscore.FieldScore:
		m.ResetScore()
		return nil
	case leaderboardscore.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case leaderboardscore.FieldLeaderboardID:
		m.ResetLeaderboardID()
		return nil
	case leaderboardscore.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown LeaderboardScore field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LeaderboardScoreMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LeaderboardScoreMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LeaderboardScoreMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LeaderboardScoreMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LeaderboardScoreMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LeaderboardScoreMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LeaderboardScoreMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LeaderboardScore unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LeaderboardScoreMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LeaderboardScore edge %s", name)
}

// ModerationRequestMutation represents an operation that mutates the ModerationRequest nodes in the graph.
type ModerationRequestMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	moderator_comment *string
	context           *string
	reference_id      *string
	action_reason     *string
	action_status     *models.ModerationStatus
	data              *map[string]interface{}
	clearedFields     map[string]struct{}
	moderator         *string
	clearedmoderator  bool
	requestor         *string
	clearedrequestor  bool
	done              bool
	oldValue          func(context.Context) (*ModerationRequest, error)
	predicates        []predicate.ModerationRequest
}

var _ ent.Mutation = (*ModerationRequestMutation)(nil)

// moderationrequestOption allows management of the mutation configuration using functional options.
type moderationrequestOption func(*ModerationRequestMutation)

// newModerationRequestMutation creates new mutation for the ModerationRequest entity.
func newModerationRequestMutation(c config, op Op, opts ...moderationrequestOption) *ModerationRequestMutation {
	m := &ModerationRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeModerationRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withModerationRequestID sets the ID field of the mutation.
func withModerationRequestID(id string) moderationrequestOption {
	return func(m *ModerationRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *ModerationRequest
		)
		m.oldValue = func(ctx context.Context) (*ModerationRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ModerationRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withModerationRequest sets the old ModerationRequest of the mutation.
func withModerationRequest(node *ModerationRequest) moderationrequestOption {
	return func(m *ModerationRequestMutation) {
		m.oldValue = func(context.Context) (*ModerationRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ModerationRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ModerationRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ModerationRequest entities.
func (m *ModerationRequestMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ModerationRequestMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ModerationRequestMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ModerationRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ModerationRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ModerationRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ModerationRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ModerationRequestMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ModerationRequestMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ModerationRequestMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetModeratorID sets the "moderator_id" field.
func (m *ModerationRequestMutation) SetModeratorID(s string) {
	m.moderator = &s
}

// ModeratorID returns the value of the "moderator_id" field in the mutation.
func (m *ModerationRequestMutation) ModeratorID() (r string, exists bool) {
	v := m.moderator
	if v == nil {
		return
	}
	return *v, true
}

// OldModeratorID returns the old "moderator_id" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldModeratorID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModeratorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModeratorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModeratorID: %w", err)
	}
	return oldValue.ModeratorID, nil
}

// ClearModeratorID clears the value of the "moderator_id" field.
func (m *ModerationRequestMutation) ClearModeratorID() {
	m.moderator = nil
	m.clearedFields[moderationrequest.FieldModeratorID] = struct{}{}
}

// ModeratorIDCleared returns if the "moderator_id" field was cleared in this mutation.
func (m *ModerationRequestMutation) ModeratorIDCleared() bool {
	_, ok := m.clearedFields[moderationrequest.FieldModeratorID]
	return ok
}

// ResetModeratorID resets all changes to the "moderator_id" field.
func (m *ModerationRequestMutation) ResetModeratorID() {
	m.moderator = nil
	delete(m.clearedFields, moderationrequest.FieldModeratorID)
}

// SetModeratorComment sets the "moderator_comment" field.
func (m *ModerationRequestMutation) SetModeratorComment(s string) {
	m.moderator_comment = &s
}

// ModeratorComment returns the value of the "moderator_comment" field in the mutation.
func (m *ModerationRequestMutation) ModeratorComment() (r string, exists bool) {
	v := m.moderator_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldModeratorComment returns the old "moderator_comment" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldModeratorComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModeratorComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModeratorComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModeratorComment: %w", err)
	}
	return oldValue.ModeratorComment, nil
}

// ClearModeratorComment clears the value of the "moderator_comment" field.
func (m *ModerationRequestMutation) ClearModeratorComment() {
	m.moderator_comment = nil
	m.clearedFields[moderationrequest.FieldModeratorComment] = struct{}{}
}

// ModeratorCommentCleared returns if the "moderator_comment" field was cleared in this mutation.
func (m *ModerationRequestMutation) ModeratorCommentCleared() bool {
	_, ok := m.clearedFields[moderationrequest.FieldModeratorComment]
	return ok
}

// ResetModeratorComment resets all changes to the "moderator_comment" field.
func (m *ModerationRequestMutation) ResetModeratorComment() {
	m.moderator_comment = nil
	delete(m.clearedFields, moderationrequest.FieldModeratorComment)
}

// SetContext sets the "context" field.
func (m *ModerationRequestMutation) SetContext(s string) {
	m.context = &s
}

// Context returns the value of the "context" field in the mutation.
func (m *ModerationRequestMutation) Context() (r string, exists bool) {
	v := m.context
	if v == nil {
		return
	}
	return *v, true
}

// OldContext returns the old "context" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContext: %w", err)
	}
	return oldValue.Context, nil
}

// ClearContext clears the value of the "context" field.
func (m *ModerationRequestMutation) ClearContext() {
	m.context = nil
	m.clearedFields[moderationrequest.FieldContext] = struct{}{}
}

// ContextCleared returns if the "context" field was cleared in this mutation.
func (m *ModerationRequestMutation) ContextCleared() bool {
	_, ok := m.clearedFields[moderationrequest.FieldContext]
	return ok
}

// ResetContext resets all changes to the "context" field.
func (m *ModerationRequestMutation) ResetContext() {
	m.context = nil
	delete(m.clearedFields, moderationrequest.FieldContext)
}

// SetReferenceID sets the "reference_id" field.
func (m *ModerationRequestMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *ModerationRequestMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *ModerationRequestMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetRequestorID sets the "requestor_id" field.
func (m *ModerationRequestMutation) SetRequestorID(s string) {
	m.requestor = &s
}

// RequestorID returns the value of the "requestor_id" field in the mutation.
func (m *ModerationRequestMutation) RequestorID() (r string, exists bool) {
	v := m.requestor
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestorID returns the old "requestor_id" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldRequestorID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestorID: %w", err)
	}
	return oldValue.RequestorID, nil
}

// ResetRequestorID resets all changes to the "requestor_id" field.
func (m *ModerationRequestMutation) ResetRequestorID() {
	m.requestor = nil
}

// SetActionReason sets the "action_reason" field.
func (m *ModerationRequestMutation) SetActionReason(s string) {
	m.action_reason = &s
}

// ActionReason returns the value of the "action_reason" field in the mutation.
func (m *ModerationRequestMutation) ActionReason() (r string, exists bool) {
	v := m.action_reason
	if v == nil {
		return
	}
	return *v, true
}

// OldActionReason returns the old "action_reason" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldActionReason(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionReason is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionReason requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionReason: %w", err)
	}
	return oldValue.ActionReason, nil
}

// ClearActionReason clears the value of the "action_reason" field.
func (m *ModerationRequestMutation) ClearActionReason() {
	m.action_reason = nil
	m.clearedFields[moderationrequest.FieldActionReason] = struct{}{}
}

// ActionReasonCleared returns if the "action_reason" field was cleared in this mutation.
func (m *ModerationRequestMutation) ActionReasonCleared() bool {
	_, ok := m.clearedFields[moderationrequest.FieldActionReason]
	return ok
}

// ResetActionReason resets all changes to the "action_reason" field.
func (m *ModerationRequestMutation) ResetActionReason() {
	m.action_reason = nil
	delete(m.clearedFields, moderationrequest.FieldActionReason)
}

// SetActionStatus sets the "action_status" field.
func (m *ModerationRequestMutation) SetActionStatus(ms models.ModerationStatus) {
	m.action_status = &ms
}

// ActionStatus returns the value of the "action_status" field in the mutation.
func (m *ModerationRequestMutation) ActionStatus() (r models.ModerationStatus, exists bool) {
	v := m.action_status
	if v == nil {
		return
	}
	return *v, true
}

// OldActionStatus returns the old "action_status" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldActionStatus(ctx context.Context) (v models.ModerationStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionStatus: %w", err)
	}
	return oldValue.ActionStatus, nil
}

// ResetActionStatus resets all changes to the "action_status" field.
func (m *ModerationRequestMutation) ResetActionStatus() {
	m.action_status = nil
}

// SetData sets the "data" field.
func (m *ModerationRequestMutation) SetData(value map[string]interface{}) {
	m.data = &value
}

// Data returns the value of the "data" field in the mutation.
func (m *ModerationRequestMutation) Data() (r map[string]interface{}, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the ModerationRequest entity.
// If the ModerationRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ModerationRequestMutation) OldData(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *ModerationRequestMutation) ResetData() {
	m.data = nil
}

// ClearModerator clears the "moderator" edge to the User entity.
func (m *ModerationRequestMutation) ClearModerator() {
	m.clearedmoderator = true
	m.clearedFields[moderationrequest.FieldModeratorID] = struct{}{}
}

// ModeratorCleared reports if the "moderator" edge to the User entity was cleared.
func (m *ModerationRequestMutation) ModeratorCleared() bool {
	return m.ModeratorIDCleared() || m.clearedmoderator
}

// ModeratorIDs returns the "moderator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ModeratorID instead. It exists only for internal usage by the builders.
func (m *ModerationRequestMutation) ModeratorIDs() (ids []string) {
	if id := m.moderator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetModerator resets all changes to the "moderator" edge.
func (m *ModerationRequestMutation) ResetModerator() {
	m.moderator = nil
	m.clearedmoderator = false
}

// ClearRequestor clears the "requestor" edge to the User entity.
func (m *ModerationRequestMutation) ClearRequestor() {
	m.clearedrequestor = true
	m.clearedFields[moderationrequest.FieldRequestorID] = struct{}{}
}

// RequestorCleared reports if the "requestor" edge to the User entity was cleared.
func (m *ModerationRequestMutation) RequestorCleared() bool {
	return m.clearedrequestor
}

// RequestorIDs returns the "requestor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RequestorID instead. It exists only for internal usage by the builders.
func (m *ModerationRequestMutation) RequestorIDs() (ids []string) {
	if id := m.requestor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRequestor resets all changes to the "requestor" edge.
func (m *ModerationRequestMutation) ResetRequestor() {
	m.requestor = nil
	m.clearedrequestor = false
}

// Where appends a list predicates to the ModerationRequestMutation builder.
func (m *ModerationRequestMutation) Where(ps ...predicate.ModerationRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ModerationRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ModerationRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ModerationRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ModerationRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ModerationRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ModerationRequest).
func (m *ModerationRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ModerationRequestMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, moderationrequest.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, moderationrequest.FieldUpdatedAt)
	}
	if m.moderator != nil {
		fields = append(fields, moderationrequest.FieldModeratorID)
	}
	if m.moderator_comment != nil {
		fields = append(fields, moderationrequest.FieldModeratorComment)
	}
	if m.context != nil {
		fields = append(fields, moderationrequest.FieldContext)
	}
	if m.reference_id != nil {
		fields = append(fields, moderationrequest.FieldReferenceID)
	}
	if m.requestor != nil {
		fields = append(fields, moderationrequest.FieldRequestorID)
	}
	if m.action_reason != nil {
		fields = append(fields, moderationrequest.FieldActionReason)
	}
	if m.action_status != nil {
		fields = append(fields, moderationrequest.FieldActionStatus)
	}
	if m.data != nil {
		fields = append(fields, moderationrequest.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ModerationRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moderationrequest.FieldCreatedAt:
		return m.CreatedAt()
	case moderationrequest.FieldUpdatedAt:
		return m.UpdatedAt()
	case moderationrequest.FieldModeratorID:
		return m.ModeratorID()
	case moderationrequest.FieldModeratorComment:
		return m.ModeratorComment()
	case moderationrequest.FieldContext:
		return m.Context()
	case moderationrequest.FieldReferenceID:
		return m.ReferenceID()
	case moderationrequest.FieldRequestorID:
		return m.RequestorID()
	case moderationrequest.FieldActionReason:
		return m.ActionReason()
	case moderationrequest.FieldActionStatus:
		return m.ActionStatus()
	case moderationrequest.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ModerationRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moderationrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case moderationrequest.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case moderationrequest.FieldModeratorID:
		return m.OldModeratorID(ctx)
	case moderationrequest.FieldModeratorComment:
		return m.OldModeratorComment(ctx)
	case moderationrequest.FieldContext:
		return m.OldContext(ctx)
	case moderationrequest.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case moderationrequest.FieldRequestorID:
		return m.OldRequestorID(ctx)
	case moderationrequest.FieldActionReason:
		return m.OldActionReason(ctx)
	case moderationrequest.FieldActionStatus:
		return m.OldActionStatus(ctx)
	case moderationrequest.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown ModerationRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModerationRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moderationrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case moderationrequest.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case moderationrequest.FieldModeratorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModeratorID(v)
		return nil
	case moderationrequest.FieldModeratorComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModeratorComment(v)
		return nil
	case moderationrequest.FieldContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContext(v)
		return nil
	case moderationrequest.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case moderationrequest.FieldRequestorID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestorID(v)
		return nil
	case moderationrequest.FieldActionReason:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionReason(v)
		return nil
	case moderationrequest.FieldActionStatus:
		v, ok := value.(models.ModerationStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionStatus(v)
		return nil
	case moderationrequest.FieldData:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown ModerationRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ModerationRequestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ModerationRequestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ModerationRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ModerationRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ModerationRequestMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(moderationrequest.FieldModeratorID) {
		fields = append(fields, moderationrequest.FieldModeratorID)
	}
	if m.FieldCleared(moderationrequest.FieldModeratorComment) {
		fields = append(fields, moderationrequest.FieldModeratorComment)
	}
	if m.FieldCleared(moderationrequest.FieldContext) {
		fields = append(fields, moderationrequest.FieldContext)
	}
	if m.FieldCleared(moderationrequest.FieldActionReason) {
		fields = append(fields, moderationrequest.FieldActionReason)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ModerationRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ModerationRequestMutation) ClearField(name string) error {
	switch name {
	case moderationrequest.FieldModeratorID:
		m.ClearModeratorID()
		return nil
	case moderationrequest.FieldModeratorComment:
		m.ClearModeratorComment()
		return nil
	case moderationrequest.FieldContext:
		m.ClearContext()
		return nil
	case moderationrequest.FieldActionReason:
		m.ClearActionReason()
		return nil
	}
	return fmt.Errorf("unknown ModerationRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ModerationRequestMutation) ResetField(name string) error {
	switch name {
	case moderationrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case moderationrequest.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case moderationrequest.FieldModeratorID:
		m.ResetModeratorID()
		return nil
	case moderationrequest.FieldModeratorComment:
		m.ResetModeratorComment()
		return nil
	case moderationrequest.FieldContext:
		m.ResetContext()
		return nil
	case moderationrequest.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case moderationrequest.FieldRequestorID:
		m.ResetRequestorID()
		return nil
	case moderationrequest.FieldActionReason:
		m.ResetActionReason()
		return nil
	case moderationrequest.FieldActionStatus:
		m.ResetActionStatus()
		return nil
	case moderationrequest.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown ModerationRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ModerationRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.moderator != nil {
		edges = append(edges, moderationrequest.EdgeModerator)
	}
	if m.requestor != nil {
		edges = append(edges, moderationrequest.EdgeRequestor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ModerationRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moderationrequest.EdgeModerator:
		if id := m.moderator; id != nil {
			return []ent.Value{*id}
		}
	case moderationrequest.EdgeRequestor:
		if id := m.requestor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ModerationRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ModerationRequestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ModerationRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedmoderator {
		edges = append(edges, moderationrequest.EdgeModerator)
	}
	if m.clearedrequestor {
		edges = append(edges, moderationrequest.EdgeRequestor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ModerationRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case moderationrequest.EdgeModerator:
		return m.clearedmoderator
	case moderationrequest.EdgeRequestor:
		return m.clearedrequestor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ModerationRequestMutation) ClearEdge(name string) error {
	switch name {
	case moderationrequest.EdgeModerator:
		m.ClearModerator()
		return nil
	case moderationrequest.EdgeRequestor:
		m.ClearRequestor()
		return nil
	}
	return fmt.Errorf("unknown ModerationRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ModerationRequestMutation) ResetEdge(name string) error {
	switch name {
	case moderationrequest.EdgeModerator:
		m.ResetModerator()
		return nil
	case moderationrequest.EdgeRequestor:
		m.ResetRequestor()
		return nil
	}
	return fmt.Errorf("unknown ModerationRequest edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	expires_at    *time.Time
	public_id     *string
	metadata      *map[string]string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
}

// SetPublicID sets the "public_id" field.
func (m *SessionMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *SessionMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *SessionMutation) ResetPublicID() {
	m.public_id = nil
}

// SetMetadata sets the "metadata" field.
func (m *SessionMutation) SetMetadata(value map[string]string) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *SessionMutation) Metadata() (r map[string]string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldMetadata(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *SessionMutation) ResetMetadata() {
	m.metadata = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.public_id != nil {
		fields = append(fields, session.FieldPublicID)
	}
	if m.metadata != nil {
		fields = append(fields, session.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldUserID:
		return m.UserID()
	case session.FieldPublicID:
		return m.PublicID()
	case session.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldPublicID:
		return m.OldPublicID(ctx)
	case session.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case session.FieldMetadata:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldPublicID:
		m.ResetPublicID()
		return nil
	case session.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                          Op
	typ                         string
	id                          *string
	created_at                  *time.Time
	updated_at                  *time.Time
	username                    *string
	permissions                 *string
	feature_flags               *[]string
	appendfeature_flags         []string
	clearedFields               map[string]struct{}
	discord_interactions        map[string]struct{}
	removeddiscord_interactions map[string]struct{}
	cleareddiscord_interactions bool
	subscriptions               map[string]struct{}
	removedsubscriptions        map[string]struct{}
	clearedsubscriptions        bool
	connections                 map[string]struct{}
	removedconnections          map[string]struct{}
	clearedconnections          bool
	widgets                     map[string]struct{}
	removedwidgets              map[string]struct{}
	clearedwidgets              bool
	content                     map[string]struct{}
	removedcontent              map[string]struct{}
	clearedcontent              bool
	sessions                    map[string]struct{}
	removedsessions             map[string]struct{}
	clearedsessions             bool
	moderation_requests         map[string]struct{}
	removedmoderation_requests  map[string]struct{}
	clearedmoderation_requests  bool
	moderation_actions          map[string]struct{}
	removedmoderation_actions   map[string]struct{}
	clearedmoderation_actions   bool
	done                        bool
	oldValue                    func(context.Context) (*User, error)
	predicates                  []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetPermissions sets the "permissions" field.
func (m *UserMutation) SetPermissions(s string) {
	m.permissions = &s
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserMutation) Permissions() (r string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPermissions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserMutation) ResetPermissions() {
	m.permissions = nil
}

// SetFeatureFlags sets the "feature_flags" field.
func (m *UserMutation) SetFeatureFlags(s []string) {
	m.feature_flags = &s
	m.appendfeature_flags = nil
}

// FeatureFlags returns the value of the "feature_flags" field in the mutation.
func (m *UserMutation) FeatureFlags() (r []string, exists bool) {
	v := m.feature_flags
	if v == nil {
		return
	}
	return *v, true
}

// OldFeatureFlags returns the old "feature_flags" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFeatureFlags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFeatureFlags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFeatureFlags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFeatureFlags: %w", err)
	}
	return oldValue.FeatureFlags, nil
}

// AppendFeatureFlags adds s to the "feature_flags" field.
func (m *UserMutation) AppendFeatureFlags(s []string) {
	m.appendfeature_flags = append(m.appendfeature_flags, s...)
}

// AppendedFeatureFlags returns the list of values that were appended to the "feature_flags" field in this mutation.
func (m *UserMutation) AppendedFeatureFlags() ([]string, bool) {
	if len(m.appendfeature_flags) == 0 {
		return nil, false
	}
	return m.appendfeature_flags, true
}

// ClearFeatureFlags clears the value of the "feature_flags" field.
func (m *UserMutation) ClearFeatureFlags() {
	m.feature_flags = nil
	m.appendfeature_flags = nil
	m.clearedFields[user.FieldFeatureFlags] = struct{}{}
}

// FeatureFlagsCleared returns if the "feature_flags" field was cleared in this mutation.
func (m *UserMutation) FeatureFlagsCleared() bool {
	_, ok := m.clearedFields[user.FieldFeatureFlags]
	return ok
}

// ResetFeatureFlags resets all changes to the "feature_flags" field.
func (m *UserMutation) ResetFeatureFlags() {
	m.feature_flags = nil
	m.appendfeature_flags = nil
	delete(m.clearedFields, user.FieldFeatureFlags)
}

// AddDiscordInteractionIDs adds the "discord_interactions" edge to the DiscordInteraction entity by ids.
func (m *UserMutation) AddDiscordInteractionIDs(ids ...string) {
	if m.discord_interactions == nil {
		m.discord_interactions = make(map[string]struct{})
	}
	for i := range ids {
		m.discord_interactions[ids[i]] = struct{}{}
	}
}

// ClearDiscordInteractions clears the "discord_interactions" edge to the DiscordInteraction entity.
func (m *UserMutation) ClearDiscordInteractions() {
	m.cleareddiscord_interactions = true
}

// DiscordInteractionsCleared reports if the "discord_interactions" edge to the DiscordInteraction entity was cleared.
func (m *UserMutation) DiscordInteractionsCleared() bool {
	return m.cleareddiscord_interactions
}

// RemoveDiscordInteractionIDs removes the "discord_interactions" edge to the DiscordInteraction entity by IDs.
func (m *UserMutation) RemoveDiscordInteractionIDs(ids ...string) {
	if m.removeddiscord_interactions == nil {
		m.removeddiscord_interactions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.discord_interactions, ids[i])
		m.removeddiscord_interactions[ids[i]] = struct{}{}
	}
}

// RemovedDiscordInteractions returns the removed IDs of the "discord_interactions" edge to the DiscordInteraction entity.
func (m *UserMutation) RemovedDiscordInteractionsIDs() (ids []string) {
	for id := range m.removeddiscord_interactions {
		ids = append(ids, id)
	}
	return
}

// DiscordInteractionsIDs returns the "discord_interactions" edge IDs in the mutation.
func (m *UserMutation) DiscordInteractionsIDs() (ids []string) {
	for id := range m.discord_interactions {
		ids = append(ids, id)
	}
	return
}

// ResetDiscordInteractions resets all changes to the "discord_interactions" edge.
func (m *UserMutation) ResetDiscordInteractions() {
	m.discord_interactions = nil
	m.cleareddiscord_interactions = false
	m.removeddiscord_interactions = nil
}

// AddSubscriptionIDs adds the "subscriptions" edge to the UserSubscription entity by ids.
func (m *UserMutation) AddSubscriptionIDs(ids ...string) {
	if m.subscriptions == nil {
		m.subscriptions = make(map[string]struct{})
	}
	for i := range ids {
		m.subscriptions[ids[i]] = struct{}{}
	}
}

// ClearSubscriptions clears the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) ClearSubscriptions() {
	m.clearedsubscriptions = true
}

// SubscriptionsCleared reports if the "subscriptions" edge to the UserSubscription entity was cleared.
func (m *UserMutation) SubscriptionsCleared() bool {
	return m.clearedsubscriptions
}

// RemoveSubscriptionIDs removes the "subscriptions" edge to the UserSubscription entity by IDs.
func (m *UserMutation) RemoveSubscriptionIDs(ids ...string) {
	if m.removedsubscriptions == nil {
		m.removedsubscriptions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.subscriptions, ids[i])
		m.removedsubscriptions[ids[i]] = struct{}{}
	}
}

// RemovedSubscriptions returns the removed IDs of the "subscriptions" edge to the UserSubscription entity.
func (m *UserMutation) RemovedSubscriptionsIDs() (ids []string) {
	for id := range m.removedsubscriptions {
		ids = append(ids, id)
	}
	return
}

// SubscriptionsIDs returns the "subscriptions" edge IDs in the mutation.
func (m *UserMutation) SubscriptionsIDs() (ids []string) {
	for id := range m.subscriptions {
		ids = append(ids, id)
	}
	return
}

// ResetSubscriptions resets all changes to the "subscriptions" edge.
func (m *UserMutation) ResetSubscriptions() {
	m.subscriptions = nil
	m.clearedsubscriptions = false
	m.removedsubscriptions = nil
}

// AddConnectionIDs adds the "connections" edge to the UserConnection entity by ids.
func (m *UserMutation) AddConnectionIDs(ids ...string) {
	if m.connections == nil {
		m.connections = make(map[string]struct{})
	}
	for i := range ids {
		m.connections[ids[i]] = struct{}{}
	}
}

// ClearConnections clears the "connections" edge to the UserConnection entity.
func (m *UserMutation) ClearConnections() {
	m.clearedconnections = true
}

// ConnectionsCleared reports if the "connections" edge to the UserConnection entity was cleared.
func (m *UserMutation) ConnectionsCleared() bool {
	return m.clearedconnections
}

// RemoveConnectionIDs removes the "connections" edge to the UserConnection entity by IDs.
func (m *UserMutation) RemoveConnectionIDs(ids ...string) {
	if m.removedconnections == nil {
		m.removedconnections = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.connections, ids[i])
		m.removedconnections[ids[i]] = struct{}{}
	}
}

// RemovedConnections returns the removed IDs of the "connections" edge to the UserConnection entity.
func (m *UserMutation) RemovedConnectionsIDs() (ids []string) {
	for id := range m.removedconnections {
		ids = append(ids, id)
	}
	return
}

// ConnectionsIDs returns the "connections" edge IDs in the mutation.
func (m *UserMutation) ConnectionsIDs() (ids []string) {
	for id := range m.connections {
		ids = append(ids, id)
	}
	return
}

// ResetConnections resets all changes to the "connections" edge.
func (m *UserMutation) ResetConnections() {
	m.connections = nil
	m.clearedconnections = false
	m.removedconnections = nil
}

// AddWidgetIDs adds the "widgets" edge to the WidgetSettings entity by ids.
func (m *UserMutation) AddWidgetIDs(ids ...string) {
	if m.widgets == nil {
		m.widgets = make(map[string]struct{})
	}
	for i := range ids {
		m.widgets[ids[i]] = struct{}{}
	}
}

// ClearWidgets clears the "widgets" edge to the WidgetSettings entity.
func (m *UserMutation) ClearWidgets() {
	m.clearedwidgets = true
}

// WidgetsCleared reports if the "widgets" edge to the WidgetSettings entity was cleared.
func (m *UserMutation) WidgetsCleared() bool {
	return m.clearedwidgets
}

// RemoveWidgetIDs removes the "widgets" edge to the WidgetSettings entity by IDs.
func (m *UserMutation) RemoveWidgetIDs(ids ...string) {
	if m.removedwidgets == nil {
		m.removedwidgets = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.widgets, ids[i])
		m.removedwidgets[ids[i]] = struct{}{}
	}
}

// RemovedWidgets returns the removed IDs of the "widgets" edge to the WidgetSettings entity.
func (m *UserMutation) RemovedWidgetsIDs() (ids []string) {
	for id := range m.removedwidgets {
		ids = append(ids, id)
	}
	return
}

// WidgetsIDs returns the "widgets" edge IDs in the mutation.
func (m *UserMutation) WidgetsIDs() (ids []string) {
	for id := range m.widgets {
		ids = append(ids, id)
	}
	return
}

// ResetWidgets resets all changes to the "widgets" edge.
func (m *UserMutation) ResetWidgets() {
	m.widgets = nil
	m.clearedwidgets = false
	m.removedwidgets = nil
}

// AddContentIDs adds the "content" edge to the UserContent entity by ids.
func (m *UserMutation) AddContentIDs(ids ...string) {
	if m.content == nil {
		m.content = make(map[string]struct{})
	}
	for i := range ids {
		m.content[ids[i]] = struct{}{}
	}
}

// ClearContent clears the "content" edge to the UserContent entity.
func (m *UserMutation) ClearContent() {
	m.clearedcontent = true
}

// ContentCleared reports if the "content" edge to the UserContent entity was cleared.
func (m *UserMutation) ContentCleared() bool {
	return m.clearedcontent
}

// RemoveContentIDs removes the "content" edge to the UserContent entity by IDs.
func (m *UserMutation) RemoveContentIDs(ids ...string) {
	if m.removedcontent == nil {
		m.removedcontent = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.content, ids[i])
		m.removedcontent[ids[i]] = struct{}{}
	}
}

// RemovedContent returns the removed IDs of the "content" edge to the UserContent entity.
func (m *UserMutation) RemovedContentIDs() (ids []string) {
	for id := range m.removedcontent {
		ids = append(ids, id)
	}
	return
}

// ContentIDs returns the "content" edge IDs in the mutation.
func (m *UserMutation) ContentIDs() (ids []string) {
	for id := range m.content {
		ids = append(ids, id)
	}
	return
}

// ResetContent resets all changes to the "content" edge.
func (m *UserMutation) ResetContent() {
	m.content = nil
	m.clearedcontent = false
	m.removedcontent = nil
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddModerationRequestIDs adds the "moderation_requests" edge to the ModerationRequest entity by ids.
func (m *UserMutation) AddModerationRequestIDs(ids ...string) {
	if m.moderation_requests == nil {
		m.moderation_requests = make(map[string]struct{})
	}
	for i := range ids {
		m.moderation_requests[ids[i]] = struct{}{}
	}
}

// ClearModerationRequests clears the "moderation_requests" edge to the ModerationRequest entity.
func (m *UserMutation) ClearModerationRequests() {
	m.clearedmoderation_requests = true
}

// ModerationRequestsCleared reports if the "moderation_requests" edge to the ModerationRequest entity was cleared.
func (m *UserMutation) ModerationRequestsCleared() bool {
	return m.clearedmoderation_requests
}

// RemoveModerationRequestIDs removes the "moderation_requests" edge to the ModerationRequest entity by IDs.
func (m *UserMutation) RemoveModerationRequestIDs(ids ...string) {
	if m.removedmoderation_requests == nil {
		m.removedmoderation_requests = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.moderation_requests, ids[i])
		m.removedmoderation_requests[ids[i]] = struct{}{}
	}
}

// RemovedModerationRequests returns the removed IDs of the "moderation_requests" edge to the ModerationRequest entity.
func (m *UserMutation) RemovedModerationRequestsIDs() (ids []string) {
	for id := range m.removedmoderation_requests {
		ids = append(ids, id)
	}
	return
}

// ModerationRequestsIDs returns the "moderation_requests" edge IDs in the mutation.
func (m *UserMutation) ModerationRequestsIDs() (ids []string) {
	for id := range m.moderation_requests {
		ids = append(ids, id)
	}
	return
}

// ResetModerationRequests resets all changes to the "moderation_requests" edge.
func (m *UserMutation) ResetModerationRequests() {
	m.moderation_requests = nil
	m.clearedmoderation_requests = false
	m.removedmoderation_requests = nil
}

// AddModerationActionIDs adds the "moderation_actions" edge to the ModerationRequest entity by ids.
func (m *UserMutation) AddModerationActionIDs(ids ...string) {
	if m.moderation_actions == nil {
		m.moderation_actions = make(map[string]struct{})
	}
	for i := range ids {
		m.moderation_actions[ids[i]] = struct{}{}
	}
}

// ClearModerationActions clears the "moderation_actions" edge to the ModerationRequest entity.
func (m *UserMutation) ClearModerationActions() {
	m.clearedmoderation_actions = true
}

// ModerationActionsCleared reports if the "moderation_actions" edge to the ModerationRequest entity was cleared.
func (m *UserMutation) ModerationActionsCleared() bool {
	return m.clearedmoderation_actions
}

// RemoveModerationActionIDs removes the "moderation_actions" edge to the ModerationRequest entity by IDs.
func (m *UserMutation) RemoveModerationActionIDs(ids ...string) {
	if m.removedmoderation_actions == nil {
		m.removedmoderation_actions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.moderation_actions, ids[i])
		m.removedmoderation_actions[ids[i]] = struct{}{}
	}
}

// RemovedModerationActions returns the removed IDs of the "moderation_actions" edge to the ModerationRequest entity.
func (m *UserMutation) RemovedModerationActionsIDs() (ids []string) {
	for id := range m.removedmoderation_actions {
		ids = append(ids, id)
	}
	return
}

// ModerationActionsIDs returns the "moderation_actions" edge IDs in the mutation.
func (m *UserMutation) ModerationActionsIDs() (ids []string) {
	for id := range m.moderation_actions {
		ids = append(ids, id)
	}
	return
}

// ResetModerationActions resets all changes to the "moderation_actions" edge.
func (m *UserMutation) ResetModerationActions() {
	m.moderation_actions = nil
	m.clearedmoderation_actions = false
	m.removedmoderation_actions = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.permissions != nil {
		fields = append(fields, user.FieldPermissions)
	}
	if m.feature_flags != nil {
		fields = append(fields, user.FieldFeatureFlags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUsername:
		return m.Username()
	case user.FieldPermissions:
		return m.Permissions()
	case user.FieldFeatureFlags:
		return m.FeatureFlags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldPermissions:
		return m.OldPermissions(ctx)
	case user.FieldFeatureFlags:
		return m.OldFeatureFlags(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldPermissions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case user.FieldFeatureFlags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFeatureFlags(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldFeatureFlags) {
		fields = append(fields, user.FieldFeatureFlags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldFeatureFlags:
		m.ClearFeatureFlags()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldPermissions:
		m.ResetPermissions()
		return nil
	case user.FieldFeatureFlags:
		m.ResetFeatureFlags()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.discord_interactions != nil {
		edges = append(edges, user.EdgeDiscordInteractions)
	}
	if m.subscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.connections != nil {
		edges = append(edges, user.EdgeConnections)
	}
	if m.widgets != nil {
		edges = append(edges, user.EdgeWidgets)
	}
	if m.content != nil {
		edges = append(edges, user.EdgeContent)
	}
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.moderation_requests != nil {
		edges = append(edges, user.EdgeModerationRequests)
	}
	if m.moderation_actions != nil {
		edges = append(edges, user.EdgeModerationActions)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDiscordInteractions:
		ids := make([]ent.Value, 0, len(m.discord_interactions))
		for id := range m.discord_interactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.subscriptions))
		for id := range m.subscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConnections:
		ids := make([]ent.Value, 0, len(m.connections))
		for id := range m.connections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWidgets:
		ids := make([]ent.Value, 0, len(m.widgets))
		for id := range m.widgets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContent:
		ids := make([]ent.Value, 0, len(m.content))
		for id := range m.content {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModerationRequests:
		ids := make([]ent.Value, 0, len(m.moderation_requests))
		for id := range m.moderation_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModerationActions:
		ids := make([]ent.Value, 0, len(m.moderation_actions))
		for id := range m.moderation_actions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removeddiscord_interactions != nil {
		edges = append(edges, user.EdgeDiscordInteractions)
	}
	if m.removedsubscriptions != nil {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.removedconnections != nil {
		edges = append(edges, user.EdgeConnections)
	}
	if m.removedwidgets != nil {
		edges = append(edges, user.EdgeWidgets)
	}
	if m.removedcontent != nil {
		edges = append(edges, user.EdgeContent)
	}
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedmoderation_requests != nil {
		edges = append(edges, user.EdgeModerationRequests)
	}
	if m.removedmoderation_actions != nil {
		edges = append(edges, user.EdgeModerationActions)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeDiscordInteractions:
		ids := make([]ent.Value, 0, len(m.removeddiscord_interactions))
		for id := range m.removeddiscord_interactions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSubscriptions:
		ids := make([]ent.Value, 0, len(m.removedsubscriptions))
		for id := range m.removedsubscriptions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConnections:
		ids := make([]ent.Value, 0, len(m.removedconnections))
		for id := range m.removedconnections {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWidgets:
		ids := make([]ent.Value, 0, len(m.removedwidgets))
		for id := range m.removedwidgets {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeContent:
		ids := make([]ent.Value, 0, len(m.removedcontent))
		for id := range m.removedcontent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModerationRequests:
		ids := make([]ent.Value, 0, len(m.removedmoderation_requests))
		for id := range m.removedmoderation_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeModerationActions:
		ids := make([]ent.Value, 0, len(m.removedmoderation_actions))
		for id := range m.removedmoderation_actions {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.cleareddiscord_interactions {
		edges = append(edges, user.EdgeDiscordInteractions)
	}
	if m.clearedsubscriptions {
		edges = append(edges, user.EdgeSubscriptions)
	}
	if m.clearedconnections {
		edges = append(edges, user.EdgeConnections)
	}
	if m.clearedwidgets {
		edges = append(edges, user.EdgeWidgets)
	}
	if m.clearedcontent {
		edges = append(edges, user.EdgeContent)
	}
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedmoderation_requests {
		edges = append(edges, user.EdgeModerationRequests)
	}
	if m.clearedmoderation_actions {
		edges = append(edges, user.EdgeModerationActions)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeDiscordInteractions:
		return m.cleareddiscord_interactions
	case user.EdgeSubscriptions:
		return m.clearedsubscriptions
	case user.EdgeConnections:
		return m.clearedconnections
	case user.EdgeWidgets:
		return m.clearedwidgets
	case user.EdgeContent:
		return m.clearedcontent
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeModerationRequests:
		return m.clearedmoderation_requests
	case user.EdgeModerationActions:
		return m.clearedmoderation_actions
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeDiscordInteractions:
		m.ResetDiscordInteractions()
		return nil
	case user.EdgeSubscriptions:
		m.ResetSubscriptions()
		return nil
	case user.EdgeConnections:
		m.ResetConnections()
		return nil
	case user.EdgeWidgets:
		m.ResetWidgets()
		return nil
	case user.EdgeContent:
		m.ResetContent()
		return nil
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeModerationRequests:
		m.ResetModerationRequests()
		return nil
	case user.EdgeModerationActions:
		m.ResetModerationActions()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserConnectionMutation represents an operation that mutates the UserConnection nodes in the graph.
type UserConnectionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	_type         *models.ConnectionType
	reference_id  *string
	permissions   *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserConnection, error)
	predicates    []predicate.UserConnection
}

var _ ent.Mutation = (*UserConnectionMutation)(nil)

// userconnectionOption allows management of the mutation configuration using functional options.
type userconnectionOption func(*UserConnectionMutation)

// newUserConnectionMutation creates new mutation for the UserConnection entity.
func newUserConnectionMutation(c config, op Op, opts ...userconnectionOption) *UserConnectionMutation {
	m := &UserConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserConnectionID sets the ID field of the mutation.
func withUserConnectionID(id string) userconnectionOption {
	return func(m *UserConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserConnection
		)
		m.oldValue = func(ctx context.Context) (*UserConnection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserConnection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserConnection sets the old UserConnection of the mutation.
func withUserConnection(node *UserConnection) userconnectionOption {
	return func(m *UserConnectionMutation) {
		m.oldValue = func(context.Context) (*UserConnection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserConnection entities.
func (m *UserConnectionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserConnectionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserConnectionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserConnection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *UserConnectionMutation) SetType(mt models.ConnectionType) {
	m._type = &mt
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserConnectionMutation) GetType() (r models.ConnectionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldType(ctx context.Context) (v models.ConnectionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserConnectionMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *UserConnectionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserConnectionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserConnectionMutation) ResetUserID() {
	m.user = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *UserConnectionMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *UserConnectionMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *UserConnectionMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetPermissions sets the "permissions" field.
func (m *UserConnectionMutation) SetPermissions(s string) {
	m.permissions = &s
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserConnectionMutation) Permissions() (r string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldPermissions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ClearPermissions clears the value of the "permissions" field.
func (m *UserConnectionMutation) ClearPermissions() {
	m.permissions = nil
	m.clearedFields[userconnection.FieldPermissions] = struct{}{}
}

// PermissionsCleared returns if the "permissions" field was cleared in this mutation.
func (m *UserConnectionMutation) PermissionsCleared() bool {
	_, ok := m.clearedFields[userconnection.FieldPermissions]
	return ok
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserConnectionMutation) ResetPermissions() {
	m.permissions = nil
	delete(m.clearedFields, userconnection.FieldPermissions)
}

// SetMetadata sets the "metadata" field.
func (m *UserConnectionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserConnectionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the UserConnection entity.
// If the UserConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserConnectionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *UserConnectionMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[userconnection.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *UserConnectionMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[userconnection.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserConnectionMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, userconnection.FieldMetadata)
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserConnectionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[userconnection.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserConnectionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserConnectionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserConnectionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserConnectionMutation builder.
func (m *UserConnectionMutation) Where(ps ...predicate.UserConnection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserConnection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserConnection).
func (m *UserConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserConnectionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, userconnection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, userconnection.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, userconnection.FieldType)
	}
	if m.user != nil {
		fields = append(fields, userconnection.FieldUserID)
	}
	if m.reference_id != nil {
		fields = append(fields, userconnection.FieldReferenceID)
	}
	if m.permissions != nil {
		fields = append(fields, userconnection.FieldPermissions)
	}
	if m.metadata != nil {
		fields = append(fields, userconnection.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userconnection.FieldCreatedAt:
		return m.CreatedAt()
	case userconnection.FieldUpdatedAt:
		return m.UpdatedAt()
	case userconnection.FieldType:
		return m.GetType()
	case userconnection.FieldUserID:
		return m.UserID()
	case userconnection.FieldReferenceID:
		return m.ReferenceID()
	case userconnection.FieldPermissions:
		return m.Permissions()
	case userconnection.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userconnection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case userconnection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case userconnection.FieldType:
		return m.OldType(ctx)
	case userconnection.FieldUserID:
		return m.OldUserID(ctx)
	case userconnection.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case userconnection.FieldPermissions:
		return m.OldPermissions(ctx)
	case userconnection.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown UserConnection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userconnection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case userconnection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case userconnection.FieldType:
		v, ok := value.(models.ConnectionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case userconnection.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case userconnection.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case userconnection.FieldPermissions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case userconnection.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown UserConnection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserConnection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userconnection.FieldPermissions) {
		fields = append(fields, userconnection.FieldPermissions)
	}
	if m.FieldCleared(userconnection.FieldMetadata) {
		fields = append(fields, userconnection.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserConnectionMutation) ClearField(name string) error {
	switch name {
	case userconnection.FieldPermissions:
		m.ClearPermissions()
		return nil
	case userconnection.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown UserConnection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserConnectionMutation) ResetField(name string) error {
	switch name {
	case userconnection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case userconnection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case userconnection.FieldType:
		m.ResetType()
		return nil
	case userconnection.FieldUserID:
		m.ResetUserID()
		return nil
	case userconnection.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case userconnection.FieldPermissions:
		m.ResetPermissions()
		return nil
	case userconnection.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown UserConnection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, userconnection.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userconnection.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserConnectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, userconnection.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case userconnection.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserConnectionMutation) ClearEdge(name string) error {
	switch name {
	case userconnection.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserConnection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserConnectionMutation) ResetEdge(name string) error {
	switch name {
	case userconnection.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserConnection edge %s", name)
}

// UserContentMutation represents an operation that mutates the UserContent nodes in the graph.
type UserContentMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	_type         *models.UserContentType
	reference_id  *string
	value         *string
	metadata      *map[string]interface{}
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserContent, error)
	predicates    []predicate.UserContent
}

var _ ent.Mutation = (*UserContentMutation)(nil)

// usercontentOption allows management of the mutation configuration using functional options.
type usercontentOption func(*UserContentMutation)

// newUserContentMutation creates new mutation for the UserContent entity.
func newUserContentMutation(c config, op Op, opts ...usercontentOption) *UserContentMutation {
	m := &UserContentMutation{
		config:        c,
		op:            op,
		typ:           TypeUserContent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserContentID sets the ID field of the mutation.
func withUserContentID(id string) usercontentOption {
	return func(m *UserContentMutation) {
		var (
			err   error
			once  sync.Once
			value *UserContent
		)
		m.oldValue = func(ctx context.Context) (*UserContent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserContent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserContent sets the old UserContent of the mutation.
func withUserContent(node *UserContent) usercontentOption {
	return func(m *UserContentMutation) {
		m.oldValue = func(context.Context) (*UserContent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserContentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserContentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserContent entities.
func (m *UserContentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserContentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserContentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserContent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserContentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserContentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserContentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserContentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserContentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserContentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *UserContentMutation) SetType(mct models.UserContentType) {
	m._type = &mct
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserContentMutation) GetType() (r models.UserContentType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldType(ctx context.Context) (v models.UserContentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserContentMutation) ResetType() {
	m._type = nil
}

// SetUserID sets the "user_id" field.
func (m *UserContentMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserContentMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserContentMutation) ResetUserID() {
	m.user = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *UserContentMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *UserContentMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *UserContentMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetValue sets the "value" field.
func (m *UserContentMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *UserContentMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *UserContentMutation) ResetValue() {
	m.value = nil
}

// SetMetadata sets the "metadata" field.
func (m *UserContentMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *UserContentMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the UserContent entity.
// If the UserContent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserContentMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *UserContentMutation) ResetMetadata() {
	m.metadata = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserContentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usercontent.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserContentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserContentMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserContentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserContentMutation builder.
func (m *UserContentMutation) Where(ps ...predicate.UserContent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserContentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserContentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserContent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserContentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserContentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserContent).
func (m *UserContentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserContentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, usercontent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usercontent.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, usercontent.FieldType)
	}
	if m.user != nil {
		fields = append(fields, usercontent.FieldUserID)
	}
	if m.reference_id != nil {
		fields = append(fields, usercontent.FieldReferenceID)
	}
	if m.value != nil {
		fields = append(fields, usercontent.FieldValue)
	}
	if m.metadata != nil {
		fields = append(fields, usercontent.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserContentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usercontent.FieldCreatedAt:
		return m.CreatedAt()
	case usercontent.FieldUpdatedAt:
		return m.UpdatedAt()
	case usercontent.FieldType:
		return m.GetType()
	case usercontent.FieldUserID:
		return m.UserID()
	case usercontent.FieldReferenceID:
		return m.ReferenceID()
	case usercontent.FieldValue:
		return m.Value()
	case usercontent.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserContentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usercontent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usercontent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usercontent.FieldType:
		return m.OldType(ctx)
	case usercontent.FieldUserID:
		return m.OldUserID(ctx)
	case usercontent.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case usercontent.FieldValue:
		return m.OldValue(ctx)
	case usercontent.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown UserContent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserContentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usercontent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usercontent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usercontent.FieldType:
		v, ok := value.(models.UserContentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usercontent.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usercontent.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case usercontent.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case usercontent.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown UserContent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserContentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserContentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserContentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserContent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserContentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserContentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserContentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserContent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserContentMutation) ResetField(name string) error {
	switch name {
	case usercontent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usercontent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usercontent.FieldType:
		m.ResetType()
		return nil
	case usercontent.FieldUserID:
		m.ResetUserID()
		return nil
	case usercontent.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case usercontent.FieldValue:
		m.ResetValue()
		return nil
	case usercontent.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown UserContent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserContentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usercontent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserContentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usercontent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserContentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserContentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserContentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usercontent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserContentMutation) EdgeCleared(name string) bool {
	switch name {
	case usercontent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserContentMutation) ClearEdge(name string) error {
	switch name {
	case usercontent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserContent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserContentMutation) ResetEdge(name string) error {
	switch name {
	case usercontent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserContent edge %s", name)
}

// UserSubscriptionMutation represents an operation that mutates the UserSubscription nodes in the graph.
type UserSubscriptionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	_type         *models.SubscriptionType
	expires_at    *time.Time
	permissions   *string
	reference_id  *string
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*UserSubscription, error)
	predicates    []predicate.UserSubscription
}

var _ ent.Mutation = (*UserSubscriptionMutation)(nil)

// usersubscriptionOption allows management of the mutation configuration using functional options.
type usersubscriptionOption func(*UserSubscriptionMutation)

// newUserSubscriptionMutation creates new mutation for the UserSubscription entity.
func newUserSubscriptionMutation(c config, op Op, opts ...usersubscriptionOption) *UserSubscriptionMutation {
	m := &UserSubscriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSubscription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSubscriptionID sets the ID field of the mutation.
func withUserSubscriptionID(id string) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSubscription
		)
		m.oldValue = func(ctx context.Context) (*UserSubscription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSubscription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSubscription sets the old UserSubscription of the mutation.
func withUserSubscription(node *UserSubscription) usersubscriptionOption {
	return func(m *UserSubscriptionMutation) {
		m.oldValue = func(context.Context) (*UserSubscription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSubscriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSubscriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSubscription entities.
func (m *UserSubscriptionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSubscriptionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSubscriptionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSubscription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSubscriptionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSubscriptionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSubscriptionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserSubscriptionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserSubscriptionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserSubscriptionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *UserSubscriptionMutation) SetType(mt models.SubscriptionType) {
	m._type = &mt
}

// GetType returns the value of the "type" field in the mutation.
func (m *UserSubscriptionMutation) GetType() (r models.SubscriptionType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldType(ctx context.Context) (v models.SubscriptionType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *UserSubscriptionMutation) ResetType() {
	m._type = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *UserSubscriptionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *UserSubscriptionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *UserSubscriptionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetUserID sets the "user_id" field.
func (m *UserSubscriptionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *UserSubscriptionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *UserSubscriptionMutation) ResetUserID() {
	m.user = nil
}

// SetPermissions sets the "permissions" field.
func (m *UserSubscriptionMutation) SetPermissions(s string) {
	m.permissions = &s
}

// Permissions returns the value of the "permissions" field in the mutation.
func (m *UserSubscriptionMutation) Permissions() (r string, exists bool) {
	v := m.permissions
	if v == nil {
		return
	}
	return *v, true
}

// OldPermissions returns the old "permissions" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldPermissions(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPermissions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPermissions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPermissions: %w", err)
	}
	return oldValue.Permissions, nil
}

// ResetPermissions resets all changes to the "permissions" field.
func (m *UserSubscriptionMutation) ResetPermissions() {
	m.permissions = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *UserSubscriptionMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *UserSubscriptionMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the UserSubscription entity.
// If the UserSubscription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSubscriptionMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *UserSubscriptionMutation) ResetReferenceID() {
	m.reference_id = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserSubscriptionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[usersubscription.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserSubscriptionMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSubscriptionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserSubscriptionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the UserSubscriptionMutation builder.
func (m *UserSubscriptionMutation) Where(ps ...predicate.UserSubscription) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSubscriptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSubscriptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSubscription, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSubscriptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSubscriptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSubscription).
func (m *UserSubscriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSubscriptionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, usersubscription.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, usersubscription.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, usersubscription.FieldType)
	}
	if m.expires_at != nil {
		fields = append(fields, usersubscription.FieldExpiresAt)
	}
	if m.user != nil {
		fields = append(fields, usersubscription.FieldUserID)
	}
	if m.permissions != nil {
		fields = append(fields, usersubscription.FieldPermissions)
	}
	if m.reference_id != nil {
		fields = append(fields, usersubscription.FieldReferenceID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSubscriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.CreatedAt()
	case usersubscription.FieldUpdatedAt:
		return m.UpdatedAt()
	case usersubscription.FieldType:
		return m.GetType()
	case usersubscription.FieldExpiresAt:
		return m.ExpiresAt()
	case usersubscription.FieldUserID:
		return m.UserID()
	case usersubscription.FieldPermissions:
		return m.Permissions()
	case usersubscription.FieldReferenceID:
		return m.ReferenceID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSubscriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usersubscription.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case usersubscription.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case usersubscription.FieldType:
		return m.OldType(ctx)
	case usersubscription.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case usersubscription.FieldUserID:
		return m.OldUserID(ctx)
	case usersubscription.FieldPermissions:
		return m.OldPermissions(ctx)
	case usersubscription.FieldReferenceID:
		return m.OldReferenceID(ctx)
	}
	return nil, fmt.Errorf("unknown UserSubscription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case usersubscription.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case usersubscription.FieldType:
		v, ok := value.(models.SubscriptionType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case usersubscription.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case usersubscription.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case usersubscription.FieldPermissions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPermissions(v)
		return nil
	case usersubscription.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSubscriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSubscriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSubscriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSubscription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSubscriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSubscriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserSubscription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSubscriptionMutation) ResetField(name string) error {
	switch name {
	case usersubscription.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case usersubscription.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case usersubscription.FieldType:
		m.ResetType()
		return nil
	case usersubscription.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case usersubscription.FieldUserID:
		m.ResetUserID()
		return nil
	case usersubscription.FieldPermissions:
		m.ResetPermissions()
		return nil
	case usersubscription.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSubscriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersubscription.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSubscriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersubscription.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSubscriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSubscriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSubscriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersubscription.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSubscriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case usersubscription.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSubscriptionMutation) ClearEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSubscriptionMutation) ResetEdge(name string) error {
	switch name {
	case usersubscription.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSubscription edge %s", name)
}

// VehicleMutation represents an operation that mutates the Vehicle nodes in the graph.
type VehicleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	tier            *int
	addtier         *int
	localized_names *map[language.Tag]string
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Vehicle, error)
	predicates      []predicate.Vehicle
}

var _ ent.Mutation = (*VehicleMutation)(nil)

// vehicleOption allows management of the mutation configuration using functional options.
type vehicleOption func(*VehicleMutation)

// newVehicleMutation creates new mutation for the Vehicle entity.
func newVehicleMutation(c config, op Op, opts ...vehicleOption) *VehicleMutation {
	m := &VehicleMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleID sets the ID field of the mutation.
func withVehicleID(id string) vehicleOption {
	return func(m *VehicleMutation) {
		var (
			err   error
			once  sync.Once
			value *Vehicle
		)
		m.oldValue = func(ctx context.Context) (*Vehicle, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vehicle.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicle sets the old Vehicle of the mutation.
func withVehicle(node *Vehicle) vehicleOption {
	return func(m *VehicleMutation) {
		m.oldValue = func(context.Context) (*Vehicle, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Vehicle entities.
func (m *VehicleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vehicle.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetTier sets the "tier" field.
func (m *VehicleMutation) SetTier(i int) {
	m.tier = &i
	m.addtier = nil
}

// Tier returns the value of the "tier" field in the mutation.
func (m *VehicleMutation) Tier() (r int, exists bool) {
	v := m.tier
	if v == nil {
		return
	}
	return *v, true
}

// OldTier returns the old "tier" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldTier(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTier: %w", err)
	}
	return oldValue.Tier, nil
}

// AddTier adds i to the "tier" field.
func (m *VehicleMutation) AddTier(i int) {
	if m.addtier != nil {
		*m.addtier += i
	} else {
		m.addtier = &i
	}
}

// AddedTier returns the value that was added to the "tier" field in this mutation.
func (m *VehicleMutation) AddedTier() (r int, exists bool) {
	v := m.addtier
	if v == nil {
		return
	}
	return *v, true
}

// ResetTier resets all changes to the "tier" field.
func (m *VehicleMutation) ResetTier() {
	m.tier = nil
	m.addtier = nil
}

// SetLocalizedNames sets the "localized_names" field.
func (m *VehicleMutation) SetLocalizedNames(value map[language.Tag]string) {
	m.localized_names = &value
}

// LocalizedNames returns the value of the "localized_names" field in the mutation.
func (m *VehicleMutation) LocalizedNames() (r map[language.Tag]string, exists bool) {
	v := m.localized_names
	if v == nil {
		return
	}
	return *v, true
}

// OldLocalizedNames returns the old "localized_names" field's value of the Vehicle entity.
// If the Vehicle object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleMutation) OldLocalizedNames(ctx context.Context) (v map[language.Tag]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocalizedNames is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocalizedNames requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocalizedNames: %w", err)
	}
	return oldValue.LocalizedNames, nil
}

// ResetLocalizedNames resets all changes to the "localized_names" field.
func (m *VehicleMutation) ResetLocalizedNames() {
	m.localized_names = nil
}

// Where appends a list predicates to the VehicleMutation builder.
func (m *VehicleMutation) Where(ps ...predicate.Vehicle) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vehicle, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vehicle).
func (m *VehicleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, vehicle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicle.FieldUpdatedAt)
	}
	if m.tier != nil {
		fields = append(fields, vehicle.FieldTier)
	}
	if m.localized_names != nil {
		fields = append(fields, vehicle.FieldLocalizedNames)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldCreatedAt:
		return m.CreatedAt()
	case vehicle.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicle.FieldTier:
		return m.Tier()
	case vehicle.FieldLocalizedNames:
		return m.LocalizedNames()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicle.FieldTier:
		return m.OldTier(ctx)
	case vehicle.FieldLocalizedNames:
		return m.OldLocalizedNames(ctx)
	}
	return nil, fmt.Errorf("unknown Vehicle field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicle.FieldTier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTier(v)
		return nil
	case vehicle.FieldLocalizedNames:
		v, ok := value.(map[language.Tag]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocalizedNames(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleMutation) AddedFields() []string {
	var fields []string
	if m.addtier != nil {
		fields = append(fields, vehicle.FieldTier)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehicle.FieldTier:
		return m.AddedTier()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehicle.FieldTier:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTier(v)
		return nil
	}
	return fmt.Errorf("unknown Vehicle numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vehicle nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleMutation) ResetField(name string) error {
	switch name {
	case vehicle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicle.FieldTier:
		m.ResetTier()
		return nil
	case vehicle.FieldLocalizedNames:
		m.ResetLocalizedNames()
		return nil
	}
	return fmt.Errorf("unknown Vehicle field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Vehicle unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Vehicle edge %s", name)
}

// VehicleAverageMutation represents an operation that mutates the VehicleAverage nodes in the graph.
type VehicleAverageMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	data          *frame.StatsFrame
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*VehicleAverage, error)
	predicates    []predicate.VehicleAverage
}

var _ ent.Mutation = (*VehicleAverageMutation)(nil)

// vehicleaverageOption allows management of the mutation configuration using functional options.
type vehicleaverageOption func(*VehicleAverageMutation)

// newVehicleAverageMutation creates new mutation for the VehicleAverage entity.
func newVehicleAverageMutation(c config, op Op, opts ...vehicleaverageOption) *VehicleAverageMutation {
	m := &VehicleAverageMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleAverage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleAverageID sets the ID field of the mutation.
func withVehicleAverageID(id string) vehicleaverageOption {
	return func(m *VehicleAverageMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleAverage
		)
		m.oldValue = func(ctx context.Context) (*VehicleAverage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleAverage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleAverage sets the old VehicleAverage of the mutation.
func withVehicleAverage(node *VehicleAverage) vehicleaverageOption {
	return func(m *VehicleAverageMutation) {
		m.oldValue = func(context.Context) (*VehicleAverage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleAverageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleAverageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VehicleAverage entities.
func (m *VehicleAverageMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleAverageMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleAverageMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VehicleAverage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleAverageMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleAverageMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleAverage entity.
// If the VehicleAverage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleAverageMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleAverageMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleAverageMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleAverageMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleAverage entity.
// If the VehicleAverage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleAverageMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleAverageMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetData sets the "data" field.
func (m *VehicleAverageMutation) SetData(ff frame.StatsFrame) {
	m.data = &ff
}

// Data returns the value of the "data" field in the mutation.
func (m *VehicleAverageMutation) Data() (r frame.StatsFrame, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the VehicleAverage entity.
// If the VehicleAverage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleAverageMutation) OldData(ctx context.Context) (v frame.StatsFrame, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *VehicleAverageMutation) ResetData() {
	m.data = nil
}

// Where appends a list predicates to the VehicleAverageMutation builder.
func (m *VehicleAverageMutation) Where(ps ...predicate.VehicleAverage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleAverageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleAverageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VehicleAverage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleAverageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleAverageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VehicleAverage).
func (m *VehicleAverageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleAverageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.created_at != nil {
		fields = append(fields, vehicleaverage.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vehicleaverage.FieldUpdatedAt)
	}
	if m.data != nil {
		fields = append(fields, vehicleaverage.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleAverageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehicleaverage.FieldCreatedAt:
		return m.CreatedAt()
	case vehicleaverage.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehicleaverage.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleAverageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehicleaverage.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehicleaverage.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehicleaverage.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleAverage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleAverageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehicleaverage.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehicleaverage.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehicleaverage.FieldData:
		v, ok := value.(frame.StatsFrame)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleAverage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleAverageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleAverageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleAverageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VehicleAverage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleAverageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleAverageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleAverageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VehicleAverage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleAverageMutation) ResetField(name string) error {
	switch name {
	case vehicleaverage.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehicleaverage.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehicleaverage.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown VehicleAverage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleAverageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleAverageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleAverageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleAverageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleAverageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleAverageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleAverageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown VehicleAverage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleAverageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown VehicleAverage edge %s", name)
}

// VehicleSnapshotMutation represents an operation that mutates the VehicleSnapshot nodes in the graph.
type VehicleSnapshotMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	_type            *models.SnapshotType
	vehicle_id       *string
	reference_id     *string
	battles          *int
	addbattles       *int
	last_battle_time *time.Time
	frame            *frame.StatsFrame
	clearedFields    map[string]struct{}
	account          *string
	clearedaccount   bool
	done             bool
	oldValue         func(context.Context) (*VehicleSnapshot, error)
	predicates       []predicate.VehicleSnapshot
}

var _ ent.Mutation = (*VehicleSnapshotMutation)(nil)

// vehiclesnapshotOption allows management of the mutation configuration using functional options.
type vehiclesnapshotOption func(*VehicleSnapshotMutation)

// newVehicleSnapshotMutation creates new mutation for the VehicleSnapshot entity.
func newVehicleSnapshotMutation(c config, op Op, opts ...vehiclesnapshotOption) *VehicleSnapshotMutation {
	m := &VehicleSnapshotMutation{
		config:        c,
		op:            op,
		typ:           TypeVehicleSnapshot,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVehicleSnapshotID sets the ID field of the mutation.
func withVehicleSnapshotID(id string) vehiclesnapshotOption {
	return func(m *VehicleSnapshotMutation) {
		var (
			err   error
			once  sync.Once
			value *VehicleSnapshot
		)
		m.oldValue = func(ctx context.Context) (*VehicleSnapshot, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VehicleSnapshot.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVehicleSnapshot sets the old VehicleSnapshot of the mutation.
func withVehicleSnapshot(node *VehicleSnapshot) vehiclesnapshotOption {
	return func(m *VehicleSnapshotMutation) {
		m.oldValue = func(context.Context) (*VehicleSnapshot, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VehicleSnapshotMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VehicleSnapshotMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VehicleSnapshot entities.
func (m *VehicleSnapshotMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VehicleSnapshotMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VehicleSnapshotMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VehicleSnapshot.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VehicleSnapshotMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VehicleSnapshotMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VehicleSnapshotMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VehicleSnapshotMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VehicleSnapshotMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VehicleSnapshotMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetType sets the "type" field.
func (m *VehicleSnapshotMutation) SetType(mt models.SnapshotType) {
	m._type = &mt
}

// GetType returns the value of the "type" field in the mutation.
func (m *VehicleSnapshotMutation) GetType() (r models.SnapshotType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldType(ctx context.Context) (v models.SnapshotType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *VehicleSnapshotMutation) ResetType() {
	m._type = nil
}

// SetAccountID sets the "account_id" field.
func (m *VehicleSnapshotMutation) SetAccountID(s string) {
	m.account = &s
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *VehicleSnapshotMutation) AccountID() (r string, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldAccountID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *VehicleSnapshotMutation) ResetAccountID() {
	m.account = nil
}

// SetVehicleID sets the "vehicle_id" field.
func (m *VehicleSnapshotMutation) SetVehicleID(s string) {
	m.vehicle_id = &s
}

// VehicleID returns the value of the "vehicle_id" field in the mutation.
func (m *VehicleSnapshotMutation) VehicleID() (r string, exists bool) {
	v := m.vehicle_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVehicleID returns the old "vehicle_id" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldVehicleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVehicleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVehicleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVehicleID: %w", err)
	}
	return oldValue.VehicleID, nil
}

// ResetVehicleID resets all changes to the "vehicle_id" field.
func (m *VehicleSnapshotMutation) ResetVehicleID() {
	m.vehicle_id = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *VehicleSnapshotMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *VehicleSnapshotMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *VehicleSnapshotMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetBattles sets the "battles" field.
func (m *VehicleSnapshotMutation) SetBattles(i int) {
	m.battles = &i
	m.addbattles = nil
}

// Battles returns the value of the "battles" field in the mutation.
func (m *VehicleSnapshotMutation) Battles() (r int, exists bool) {
	v := m.battles
	if v == nil {
		return
	}
	return *v, true
}

// OldBattles returns the old "battles" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldBattles(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBattles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBattles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBattles: %w", err)
	}
	return oldValue.Battles, nil
}

// AddBattles adds i to the "battles" field.
func (m *VehicleSnapshotMutation) AddBattles(i int) {
	if m.addbattles != nil {
		*m.addbattles += i
	} else {
		m.addbattles = &i
	}
}

// AddedBattles returns the value that was added to the "battles" field in this mutation.
func (m *VehicleSnapshotMutation) AddedBattles() (r int, exists bool) {
	v := m.addbattles
	if v == nil {
		return
	}
	return *v, true
}

// ResetBattles resets all changes to the "battles" field.
func (m *VehicleSnapshotMutation) ResetBattles() {
	m.battles = nil
	m.addbattles = nil
}

// SetLastBattleTime sets the "last_battle_time" field.
func (m *VehicleSnapshotMutation) SetLastBattleTime(t time.Time) {
	m.last_battle_time = &t
}

// LastBattleTime returns the value of the "last_battle_time" field in the mutation.
func (m *VehicleSnapshotMutation) LastBattleTime() (r time.Time, exists bool) {
	v := m.last_battle_time
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBattleTime returns the old "last_battle_time" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldLastBattleTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBattleTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBattleTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBattleTime: %w", err)
	}
	return oldValue.LastBattleTime, nil
}

// ResetLastBattleTime resets all changes to the "last_battle_time" field.
func (m *VehicleSnapshotMutation) ResetLastBattleTime() {
	m.last_battle_time = nil
}

// SetFrame sets the "frame" field.
func (m *VehicleSnapshotMutation) SetFrame(ff frame.StatsFrame) {
	m.frame = &ff
}

// Frame returns the value of the "frame" field in the mutation.
func (m *VehicleSnapshotMutation) Frame() (r frame.StatsFrame, exists bool) {
	v := m.frame
	if v == nil {
		return
	}
	return *v, true
}

// OldFrame returns the old "frame" field's value of the VehicleSnapshot entity.
// If the VehicleSnapshot object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VehicleSnapshotMutation) OldFrame(ctx context.Context) (v frame.StatsFrame, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFrame: %w", err)
	}
	return oldValue.Frame, nil
}

// ResetFrame resets all changes to the "frame" field.
func (m *VehicleSnapshotMutation) ResetFrame() {
	m.frame = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *VehicleSnapshotMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[vehiclesnapshot.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *VehicleSnapshotMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *VehicleSnapshotMutation) AccountIDs() (ids []string) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *VehicleSnapshotMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the VehicleSnapshotMutation builder.
func (m *VehicleSnapshotMutation) Where(ps ...predicate.VehicleSnapshot) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VehicleSnapshotMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VehicleSnapshotMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.VehicleSnapshot, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VehicleSnapshotMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VehicleSnapshotMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (VehicleSnapshot).
func (m *VehicleSnapshotMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VehicleSnapshotMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, vehiclesnapshot.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vehiclesnapshot.FieldUpdatedAt)
	}
	if m._type != nil {
		fields = append(fields, vehiclesnapshot.FieldType)
	}
	if m.account != nil {
		fields = append(fields, vehiclesnapshot.FieldAccountID)
	}
	if m.vehicle_id != nil {
		fields = append(fields, vehiclesnapshot.FieldVehicleID)
	}
	if m.reference_id != nil {
		fields = append(fields, vehiclesnapshot.FieldReferenceID)
	}
	if m.battles != nil {
		fields = append(fields, vehiclesnapshot.FieldBattles)
	}
	if m.last_battle_time != nil {
		fields = append(fields, vehiclesnapshot.FieldLastBattleTime)
	}
	if m.frame != nil {
		fields = append(fields, vehiclesnapshot.FieldFrame)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VehicleSnapshotMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vehiclesnapshot.FieldCreatedAt:
		return m.CreatedAt()
	case vehiclesnapshot.FieldUpdatedAt:
		return m.UpdatedAt()
	case vehiclesnapshot.FieldType:
		return m.GetType()
	case vehiclesnapshot.FieldAccountID:
		return m.AccountID()
	case vehiclesnapshot.FieldVehicleID:
		return m.VehicleID()
	case vehiclesnapshot.FieldReferenceID:
		return m.ReferenceID()
	case vehiclesnapshot.FieldBattles:
		return m.Battles()
	case vehiclesnapshot.FieldLastBattleTime:
		return m.LastBattleTime()
	case vehiclesnapshot.FieldFrame:
		return m.Frame()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VehicleSnapshotMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vehiclesnapshot.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vehiclesnapshot.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vehiclesnapshot.FieldType:
		return m.OldType(ctx)
	case vehiclesnapshot.FieldAccountID:
		return m.OldAccountID(ctx)
	case vehiclesnapshot.FieldVehicleID:
		return m.OldVehicleID(ctx)
	case vehiclesnapshot.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case vehiclesnapshot.FieldBattles:
		return m.OldBattles(ctx)
	case vehiclesnapshot.FieldLastBattleTime:
		return m.OldLastBattleTime(ctx)
	case vehiclesnapshot.FieldFrame:
		return m.OldFrame(ctx)
	}
	return nil, fmt.Errorf("unknown VehicleSnapshot field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleSnapshotMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vehiclesnapshot.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vehiclesnapshot.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vehiclesnapshot.FieldType:
		v, ok := value.(models.SnapshotType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case vehiclesnapshot.FieldAccountID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case vehiclesnapshot.FieldVehicleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVehicleID(v)
		return nil
	case vehiclesnapshot.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case vehiclesnapshot.FieldBattles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBattles(v)
		return nil
	case vehiclesnapshot.FieldLastBattleTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBattleTime(v)
		return nil
	case vehiclesnapshot.FieldFrame:
		v, ok := value.(frame.StatsFrame)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFrame(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleSnapshot field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VehicleSnapshotMutation) AddedFields() []string {
	var fields []string
	if m.addbattles != nil {
		fields = append(fields, vehiclesnapshot.FieldBattles)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VehicleSnapshotMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vehiclesnapshot.FieldBattles:
		return m.AddedBattles()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VehicleSnapshotMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vehiclesnapshot.FieldBattles:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBattles(v)
		return nil
	}
	return fmt.Errorf("unknown VehicleSnapshot numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VehicleSnapshotMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VehicleSnapshotMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VehicleSnapshotMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VehicleSnapshot nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VehicleSnapshotMutation) ResetField(name string) error {
	switch name {
	case vehiclesnapshot.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vehiclesnapshot.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vehiclesnapshot.FieldType:
		m.ResetType()
		return nil
	case vehiclesnapshot.FieldAccountID:
		m.ResetAccountID()
		return nil
	case vehiclesnapshot.FieldVehicleID:
		m.ResetVehicleID()
		return nil
	case vehiclesnapshot.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case vehiclesnapshot.FieldBattles:
		m.ResetBattles()
		return nil
	case vehiclesnapshot.FieldLastBattleTime:
		m.ResetLastBattleTime()
		return nil
	case vehiclesnapshot.FieldFrame:
		m.ResetFrame()
		return nil
	}
	return fmt.Errorf("unknown VehicleSnapshot field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VehicleSnapshotMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, vehiclesnapshot.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VehicleSnapshotMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vehiclesnapshot.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VehicleSnapshotMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VehicleSnapshotMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VehicleSnapshotMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, vehiclesnapshot.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VehicleSnapshotMutation) EdgeCleared(name string) bool {
	switch name {
	case vehiclesnapshot.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VehicleSnapshotMutation) ClearEdge(name string) error {
	switch name {
	case vehiclesnapshot.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown VehicleSnapshot unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VehicleSnapshotMutation) ResetEdge(name string) error {
	switch name {
	case vehiclesnapshot.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown VehicleSnapshot edge %s", name)
}

// WidgetSettingsMutation represents an operation that mutates the WidgetSettings nodes in the graph.
type WidgetSettingsMutation struct {
	config
	op                   Op
	typ                  string
	id                   *string
	created_at           *time.Time
	updated_at           *time.Time
	reference_id         *string
	title                *string
	session_from         *time.Time
	session_reference_id *string
	metadata             *map[string]interface{}
	styles               *models.WidgetStyling
	clearedFields        map[string]struct{}
	user                 *string
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*WidgetSettings, error)
	predicates           []predicate.WidgetSettings
}

var _ ent.Mutation = (*WidgetSettingsMutation)(nil)

// widgetsettingsOption allows management of the mutation configuration using functional options.
type widgetsettingsOption func(*WidgetSettingsMutation)

// newWidgetSettingsMutation creates new mutation for the WidgetSettings entity.
func newWidgetSettingsMutation(c config, op Op, opts ...widgetsettingsOption) *WidgetSettingsMutation {
	m := &WidgetSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeWidgetSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWidgetSettingsID sets the ID field of the mutation.
func withWidgetSettingsID(id string) widgetsettingsOption {
	return func(m *WidgetSettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *WidgetSettings
		)
		m.oldValue = func(ctx context.Context) (*WidgetSettings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WidgetSettings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWidgetSettings sets the old WidgetSettings of the mutation.
func withWidgetSettings(node *WidgetSettings) widgetsettingsOption {
	return func(m *WidgetSettingsMutation) {
		m.oldValue = func(context.Context) (*WidgetSettings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WidgetSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WidgetSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("db: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WidgetSettings entities.
func (m *WidgetSettingsMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WidgetSettingsMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WidgetSettingsMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WidgetSettings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WidgetSettingsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WidgetSettingsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WidgetSettingsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WidgetSettingsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WidgetSettingsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WidgetSettingsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetReferenceID sets the "reference_id" field.
func (m *WidgetSettingsMutation) SetReferenceID(s string) {
	m.reference_id = &s
}

// ReferenceID returns the value of the "reference_id" field in the mutation.
func (m *WidgetSettingsMutation) ReferenceID() (r string, exists bool) {
	v := m.reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldReferenceID returns the old "reference_id" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReferenceID: %w", err)
	}
	return oldValue.ReferenceID, nil
}

// ResetReferenceID resets all changes to the "reference_id" field.
func (m *WidgetSettingsMutation) ResetReferenceID() {
	m.reference_id = nil
}

// SetTitle sets the "title" field.
func (m *WidgetSettingsMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *WidgetSettingsMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ClearTitle clears the value of the "title" field.
func (m *WidgetSettingsMutation) ClearTitle() {
	m.title = nil
	m.clearedFields[widgetsettings.FieldTitle] = struct{}{}
}

// TitleCleared returns if the "title" field was cleared in this mutation.
func (m *WidgetSettingsMutation) TitleCleared() bool {
	_, ok := m.clearedFields[widgetsettings.FieldTitle]
	return ok
}

// ResetTitle resets all changes to the "title" field.
func (m *WidgetSettingsMutation) ResetTitle() {
	m.title = nil
	delete(m.clearedFields, widgetsettings.FieldTitle)
}

// SetUserID sets the "user_id" field.
func (m *WidgetSettingsMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WidgetSettingsMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WidgetSettingsMutation) ResetUserID() {
	m.user = nil
}

// SetSessionFrom sets the "session_from" field.
func (m *WidgetSettingsMutation) SetSessionFrom(t time.Time) {
	m.session_from = &t
}

// SessionFrom returns the value of the "session_from" field in the mutation.
func (m *WidgetSettingsMutation) SessionFrom() (r time.Time, exists bool) {
	v := m.session_from
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionFrom returns the old "session_from" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldSessionFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionFrom: %w", err)
	}
	return oldValue.SessionFrom, nil
}

// ClearSessionFrom clears the value of the "session_from" field.
func (m *WidgetSettingsMutation) ClearSessionFrom() {
	m.session_from = nil
	m.clearedFields[widgetsettings.FieldSessionFrom] = struct{}{}
}

// SessionFromCleared returns if the "session_from" field was cleared in this mutation.
func (m *WidgetSettingsMutation) SessionFromCleared() bool {
	_, ok := m.clearedFields[widgetsettings.FieldSessionFrom]
	return ok
}

// ResetSessionFrom resets all changes to the "session_from" field.
func (m *WidgetSettingsMutation) ResetSessionFrom() {
	m.session_from = nil
	delete(m.clearedFields, widgetsettings.FieldSessionFrom)
}

// SetSessionReferenceID sets the "session_reference_id" field.
func (m *WidgetSettingsMutation) SetSessionReferenceID(s string) {
	m.session_reference_id = &s
}

// SessionReferenceID returns the value of the "session_reference_id" field in the mutation.
func (m *WidgetSettingsMutation) SessionReferenceID() (r string, exists bool) {
	v := m.session_reference_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSessionReferenceID returns the old "session_reference_id" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldSessionReferenceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSessionReferenceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSessionReferenceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSessionReferenceID: %w", err)
	}
	return oldValue.SessionReferenceID, nil
}

// ClearSessionReferenceID clears the value of the "session_reference_id" field.
func (m *WidgetSettingsMutation) ClearSessionReferenceID() {
	m.session_reference_id = nil
	m.clearedFields[widgetsettings.FieldSessionReferenceID] = struct{}{}
}

// SessionReferenceIDCleared returns if the "session_reference_id" field was cleared in this mutation.
func (m *WidgetSettingsMutation) SessionReferenceIDCleared() bool {
	_, ok := m.clearedFields[widgetsettings.FieldSessionReferenceID]
	return ok
}

// ResetSessionReferenceID resets all changes to the "session_reference_id" field.
func (m *WidgetSettingsMutation) ResetSessionReferenceID() {
	m.session_reference_id = nil
	delete(m.clearedFields, widgetsettings.FieldSessionReferenceID)
}

// SetMetadata sets the "metadata" field.
func (m *WidgetSettingsMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *WidgetSettingsMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *WidgetSettingsMutation) ResetMetadata() {
	m.metadata = nil
}

// SetStyles sets the "styles" field.
func (m *WidgetSettingsMutation) SetStyles(ms models.WidgetStyling) {
	m.styles = &ms
}

// Styles returns the value of the "styles" field in the mutation.
func (m *WidgetSettingsMutation) Styles() (r models.WidgetStyling, exists bool) {
	v := m.styles
	if v == nil {
		return
	}
	return *v, true
}

// OldStyles returns the old "styles" field's value of the WidgetSettings entity.
// If the WidgetSettings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WidgetSettingsMutation) OldStyles(ctx context.Context) (v models.WidgetStyling, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStyles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStyles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStyles: %w", err)
	}
	return oldValue.Styles, nil
}

// ResetStyles resets all changes to the "styles" field.
func (m *WidgetSettingsMutation) ResetStyles() {
	m.styles = nil
}

// ClearUser clears the "user" edge to the User entity.
func (m *WidgetSettingsMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[widgetsettings.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WidgetSettingsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WidgetSettingsMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WidgetSettingsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WidgetSettingsMutation builder.
func (m *WidgetSettingsMutation) Where(ps ...predicate.WidgetSettings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WidgetSettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WidgetSettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WidgetSettings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WidgetSettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WidgetSettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WidgetSettings).
func (m *WidgetSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WidgetSettingsMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.created_at != nil {
		fields = append(fields, widgetsettings.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, widgetsettings.FieldUpdatedAt)
	}
	if m.reference_id != nil {
		fields = append(fields, widgetsettings.FieldReferenceID)
	}
	if m.title != nil {
		fields = append(fields, widgetsettings.FieldTitle)
	}
	if m.user != nil {
		fields = append(fields, widgetsettings.FieldUserID)
	}
	if m.session_from != nil {
		fields = append(fields, widgetsettings.FieldSessionFrom)
	}
	if m.session_reference_id != nil {
		fields = append(fields, widgetsettings.FieldSessionReferenceID)
	}
	if m.metadata != nil {
		fields = append(fields, widgetsettings.FieldMetadata)
	}
	if m.styles != nil {
		fields = append(fields, widgetsettings.FieldStyles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WidgetSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case widgetsettings.FieldCreatedAt:
		return m.CreatedAt()
	case widgetsettings.FieldUpdatedAt:
		return m.UpdatedAt()
	case widgetsettings.FieldReferenceID:
		return m.ReferenceID()
	case widgetsettings.FieldTitle:
		return m.Title()
	case widgetsettings.FieldUserID:
		return m.UserID()
	case widgetsettings.FieldSessionFrom:
		return m.SessionFrom()
	case widgetsettings.FieldSessionReferenceID:
		return m.SessionReferenceID()
	case widgetsettings.FieldMetadata:
		return m.Metadata()
	case widgetsettings.FieldStyles:
		return m.Styles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WidgetSettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case widgetsettings.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case widgetsettings.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case widgetsettings.FieldReferenceID:
		return m.OldReferenceID(ctx)
	case widgetsettings.FieldTitle:
		return m.OldTitle(ctx)
	case widgetsettings.FieldUserID:
		return m.OldUserID(ctx)
	case widgetsettings.FieldSessionFrom:
		return m.OldSessionFrom(ctx)
	case widgetsettings.FieldSessionReferenceID:
		return m.OldSessionReferenceID(ctx)
	case widgetsettings.FieldMetadata:
		return m.OldMetadata(ctx)
	case widgetsettings.FieldStyles:
		return m.OldStyles(ctx)
	}
	return nil, fmt.Errorf("unknown WidgetSettings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WidgetSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case widgetsettings.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case widgetsettings.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case widgetsettings.FieldReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReferenceID(v)
		return nil
	case widgetsettings.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case widgetsettings.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case widgetsettings.FieldSessionFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionFrom(v)
		return nil
	case widgetsettings.FieldSessionReferenceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSessionReferenceID(v)
		return nil
	case widgetsettings.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case widgetsettings.FieldStyles:
		v, ok := value.(models.WidgetStyling)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStyles(v)
		return nil
	}
	return fmt.Errorf("unknown WidgetSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WidgetSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WidgetSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WidgetSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WidgetSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WidgetSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(widgetsettings.FieldTitle) {
		fields = append(fields, widgetsettings.FieldTitle)
	}
	if m.FieldCleared(widgetsettings.FieldSessionFrom) {
		fields = append(fields, widgetsettings.FieldSessionFrom)
	}
	if m.FieldCleared(widgetsettings.FieldSessionReferenceID) {
		fields = append(fields, widgetsettings.FieldSessionReferenceID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WidgetSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WidgetSettingsMutation) ClearField(name string) error {
	switch name {
	case widgetsettings.FieldTitle:
		m.ClearTitle()
		return nil
	case widgetsettings.FieldSessionFrom:
		m.ClearSessionFrom()
		return nil
	case widgetsettings.FieldSessionReferenceID:
		m.ClearSessionReferenceID()
		return nil
	}
	return fmt.Errorf("unknown WidgetSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WidgetSettingsMutation) ResetField(name string) error {
	switch name {
	case widgetsettings.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case widgetsettings.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case widgetsettings.FieldReferenceID:
		m.ResetReferenceID()
		return nil
	case widgetsettings.FieldTitle:
		m.ResetTitle()
		return nil
	case widgetsettings.FieldUserID:
		m.ResetUserID()
		return nil
	case widgetsettings.FieldSessionFrom:
		m.ResetSessionFrom()
		return nil
	case widgetsettings.FieldSessionReferenceID:
		m.ResetSessionReferenceID()
		return nil
	case widgetsettings.FieldMetadata:
		m.ResetMetadata()
		return nil
	case widgetsettings.FieldStyles:
		m.ResetStyles()
		return nil
	}
	return fmt.Errorf("unknown WidgetSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WidgetSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, widgetsettings.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WidgetSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case widgetsettings.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WidgetSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WidgetSettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WidgetSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, widgetsettings.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WidgetSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case widgetsettings.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WidgetSettingsMutation) ClearEdge(name string) error {
	switch name {
	case widgetsettings.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WidgetSettings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WidgetSettingsMutation) ResetEdge(name string) error {
	switch name {
	case widgetsettings.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WidgetSettings edge %s", name)
}
