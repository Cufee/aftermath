// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/cufee/aftermath/internal/database/ent/db/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/cufee/aftermath/internal/database/ent/db/account"
	"github.com/cufee/aftermath/internal/database/ent/db/accountsnapshot"
	"github.com/cufee/aftermath/internal/database/ent/db/achievementssnapshot"
	"github.com/cufee/aftermath/internal/database/ent/db/appconfiguration"
	"github.com/cufee/aftermath/internal/database/ent/db/applicationcommand"
	"github.com/cufee/aftermath/internal/database/ent/db/clan"
	"github.com/cufee/aftermath/internal/database/ent/db/crontask"
	"github.com/cufee/aftermath/internal/database/ent/db/user"
	"github.com/cufee/aftermath/internal/database/ent/db/userconnection"
	"github.com/cufee/aftermath/internal/database/ent/db/usercontent"
	"github.com/cufee/aftermath/internal/database/ent/db/usersubscription"
	"github.com/cufee/aftermath/internal/database/ent/db/vehicle"
	"github.com/cufee/aftermath/internal/database/ent/db/vehicleaverage"
	"github.com/cufee/aftermath/internal/database/ent/db/vehiclesnapshot"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// AccountSnapshot is the client for interacting with the AccountSnapshot builders.
	AccountSnapshot *AccountSnapshotClient
	// AchievementsSnapshot is the client for interacting with the AchievementsSnapshot builders.
	AchievementsSnapshot *AchievementsSnapshotClient
	// AppConfiguration is the client for interacting with the AppConfiguration builders.
	AppConfiguration *AppConfigurationClient
	// ApplicationCommand is the client for interacting with the ApplicationCommand builders.
	ApplicationCommand *ApplicationCommandClient
	// Clan is the client for interacting with the Clan builders.
	Clan *ClanClient
	// CronTask is the client for interacting with the CronTask builders.
	CronTask *CronTaskClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserConnection is the client for interacting with the UserConnection builders.
	UserConnection *UserConnectionClient
	// UserContent is the client for interacting with the UserContent builders.
	UserContent *UserContentClient
	// UserSubscription is the client for interacting with the UserSubscription builders.
	UserSubscription *UserSubscriptionClient
	// Vehicle is the client for interacting with the Vehicle builders.
	Vehicle *VehicleClient
	// VehicleAverage is the client for interacting with the VehicleAverage builders.
	VehicleAverage *VehicleAverageClient
	// VehicleSnapshot is the client for interacting with the VehicleSnapshot builders.
	VehicleSnapshot *VehicleSnapshotClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.AccountSnapshot = NewAccountSnapshotClient(c.config)
	c.AchievementsSnapshot = NewAchievementsSnapshotClient(c.config)
	c.AppConfiguration = NewAppConfigurationClient(c.config)
	c.ApplicationCommand = NewApplicationCommandClient(c.config)
	c.Clan = NewClanClient(c.config)
	c.CronTask = NewCronTaskClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserConnection = NewUserConnectionClient(c.config)
	c.UserContent = NewUserContentClient(c.config)
	c.UserSubscription = NewUserSubscriptionClient(c.config)
	c.Vehicle = NewVehicleClient(c.config)
	c.VehicleAverage = NewVehicleAverageClient(c.config)
	c.VehicleSnapshot = NewVehicleSnapshotClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("db: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("db: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Account:              NewAccountClient(cfg),
		AccountSnapshot:      NewAccountSnapshotClient(cfg),
		AchievementsSnapshot: NewAchievementsSnapshotClient(cfg),
		AppConfiguration:     NewAppConfigurationClient(cfg),
		ApplicationCommand:   NewApplicationCommandClient(cfg),
		Clan:                 NewClanClient(cfg),
		CronTask:             NewCronTaskClient(cfg),
		User:                 NewUserClient(cfg),
		UserConnection:       NewUserConnectionClient(cfg),
		UserContent:          NewUserContentClient(cfg),
		UserSubscription:     NewUserSubscriptionClient(cfg),
		Vehicle:              NewVehicleClient(cfg),
		VehicleAverage:       NewVehicleAverageClient(cfg),
		VehicleSnapshot:      NewVehicleSnapshotClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                  ctx,
		config:               cfg,
		Account:              NewAccountClient(cfg),
		AccountSnapshot:      NewAccountSnapshotClient(cfg),
		AchievementsSnapshot: NewAchievementsSnapshotClient(cfg),
		AppConfiguration:     NewAppConfigurationClient(cfg),
		ApplicationCommand:   NewApplicationCommandClient(cfg),
		Clan:                 NewClanClient(cfg),
		CronTask:             NewCronTaskClient(cfg),
		User:                 NewUserClient(cfg),
		UserConnection:       NewUserConnectionClient(cfg),
		UserContent:          NewUserContentClient(cfg),
		UserSubscription:     NewUserSubscriptionClient(cfg),
		Vehicle:              NewVehicleClient(cfg),
		VehicleAverage:       NewVehicleAverageClient(cfg),
		VehicleSnapshot:      NewVehicleSnapshotClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Account, c.AccountSnapshot, c.AchievementsSnapshot, c.AppConfiguration,
		c.ApplicationCommand, c.Clan, c.CronTask, c.User, c.UserConnection,
		c.UserContent, c.UserSubscription, c.Vehicle, c.VehicleAverage,
		c.VehicleSnapshot,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Account, c.AccountSnapshot, c.AchievementsSnapshot, c.AppConfiguration,
		c.ApplicationCommand, c.Clan, c.CronTask, c.User, c.UserConnection,
		c.UserContent, c.UserSubscription, c.Vehicle, c.VehicleAverage,
		c.VehicleSnapshot,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountMutation:
		return c.Account.mutate(ctx, m)
	case *AccountSnapshotMutation:
		return c.AccountSnapshot.mutate(ctx, m)
	case *AchievementsSnapshotMutation:
		return c.AchievementsSnapshot.mutate(ctx, m)
	case *AppConfigurationMutation:
		return c.AppConfiguration.mutate(ctx, m)
	case *ApplicationCommandMutation:
		return c.ApplicationCommand.mutate(ctx, m)
	case *ClanMutation:
		return c.Clan.mutate(ctx, m)
	case *CronTaskMutation:
		return c.CronTask.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserConnectionMutation:
		return c.UserConnection.mutate(ctx, m)
	case *UserContentMutation:
		return c.UserContent.mutate(ctx, m)
	case *UserSubscriptionMutation:
		return c.UserSubscription.mutate(ctx, m)
	case *VehicleMutation:
		return c.Vehicle.mutate(ctx, m)
	case *VehicleAverageMutation:
		return c.VehicleAverage.mutate(ctx, m)
	case *VehicleSnapshotMutation:
		return c.VehicleSnapshot.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("db: unknown mutation type %T", m)
	}
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `account.Intercept(f(g(h())))`.
func (c *AccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.Account = append(c.inters.Account, interceptors...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountClient) MapCreateBulk(slice any, setFunc func(*AccountCreate, int)) *AccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountCreateBulk{err: fmt.Errorf("calling to AccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(a))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id string) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id string) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id string) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id string) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClan queries the clan edge of a Account.
func (c *AccountClient) QueryClan(a *Account) *ClanQuery {
	query := (&ClanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(clan.Table, clan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, account.ClanTable, account.ClanColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySnapshots queries the snapshots edge of a Account.
func (c *AccountClient) QuerySnapshots(a *Account) *AccountSnapshotQuery {
	query := (&AccountSnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(accountsnapshot.Table, accountsnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.SnapshotsTable, account.SnapshotsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVehicleSnapshots queries the vehicle_snapshots edge of a Account.
func (c *AccountClient) QueryVehicleSnapshots(a *Account) *VehicleSnapshotQuery {
	query := (&VehicleSnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(vehiclesnapshot.Table, vehiclesnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.VehicleSnapshotsTable, account.VehicleSnapshotsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAchievementSnapshots queries the achievement_snapshots edge of a Account.
func (c *AccountClient) QueryAchievementSnapshots(a *Account) *AchievementsSnapshotQuery {
	query := (&AchievementsSnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(achievementssnapshot.Table, achievementssnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.AchievementSnapshotsTable, account.AchievementSnapshotsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// Interceptors returns the client interceptors.
func (c *AccountClient) Interceptors() []Interceptor {
	return c.inters.Account
}

func (c *AccountClient) mutate(ctx context.Context, m *AccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Account mutation op: %q", m.Op())
	}
}

// AccountSnapshotClient is a client for the AccountSnapshot schema.
type AccountSnapshotClient struct {
	config
}

// NewAccountSnapshotClient returns a client for the AccountSnapshot from the given config.
func NewAccountSnapshotClient(c config) *AccountSnapshotClient {
	return &AccountSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountsnapshot.Hooks(f(g(h())))`.
func (c *AccountSnapshotClient) Use(hooks ...Hook) {
	c.hooks.AccountSnapshot = append(c.hooks.AccountSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountsnapshot.Intercept(f(g(h())))`.
func (c *AccountSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountSnapshot = append(c.inters.AccountSnapshot, interceptors...)
}

// Create returns a builder for creating a AccountSnapshot entity.
func (c *AccountSnapshotClient) Create() *AccountSnapshotCreate {
	mutation := newAccountSnapshotMutation(c.config, OpCreate)
	return &AccountSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountSnapshot entities.
func (c *AccountSnapshotClient) CreateBulk(builders ...*AccountSnapshotCreate) *AccountSnapshotCreateBulk {
	return &AccountSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountSnapshotClient) MapCreateBulk(slice any, setFunc func(*AccountSnapshotCreate, int)) *AccountSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountSnapshotCreateBulk{err: fmt.Errorf("calling to AccountSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountSnapshot.
func (c *AccountSnapshotClient) Update() *AccountSnapshotUpdate {
	mutation := newAccountSnapshotMutation(c.config, OpUpdate)
	return &AccountSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountSnapshotClient) UpdateOne(as *AccountSnapshot) *AccountSnapshotUpdateOne {
	mutation := newAccountSnapshotMutation(c.config, OpUpdateOne, withAccountSnapshot(as))
	return &AccountSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountSnapshotClient) UpdateOneID(id string) *AccountSnapshotUpdateOne {
	mutation := newAccountSnapshotMutation(c.config, OpUpdateOne, withAccountSnapshotID(id))
	return &AccountSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountSnapshot.
func (c *AccountSnapshotClient) Delete() *AccountSnapshotDelete {
	mutation := newAccountSnapshotMutation(c.config, OpDelete)
	return &AccountSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountSnapshotClient) DeleteOne(as *AccountSnapshot) *AccountSnapshotDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountSnapshotClient) DeleteOneID(id string) *AccountSnapshotDeleteOne {
	builder := c.Delete().Where(accountsnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountSnapshotDeleteOne{builder}
}

// Query returns a query builder for AccountSnapshot.
func (c *AccountSnapshotClient) Query() *AccountSnapshotQuery {
	return &AccountSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountSnapshot entity by its id.
func (c *AccountSnapshotClient) Get(ctx context.Context, id string) (*AccountSnapshot, error) {
	return c.Query().Where(accountsnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountSnapshotClient) GetX(ctx context.Context, id string) *AccountSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a AccountSnapshot.
func (c *AccountSnapshotClient) QueryAccount(as *AccountSnapshot) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountsnapshot.Table, accountsnapshot.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountsnapshot.AccountTable, accountsnapshot.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountSnapshotClient) Hooks() []Hook {
	return c.hooks.AccountSnapshot
}

// Interceptors returns the client interceptors.
func (c *AccountSnapshotClient) Interceptors() []Interceptor {
	return c.inters.AccountSnapshot
}

func (c *AccountSnapshotClient) mutate(ctx context.Context, m *AccountSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown AccountSnapshot mutation op: %q", m.Op())
	}
}

// AchievementsSnapshotClient is a client for the AchievementsSnapshot schema.
type AchievementsSnapshotClient struct {
	config
}

// NewAchievementsSnapshotClient returns a client for the AchievementsSnapshot from the given config.
func NewAchievementsSnapshotClient(c config) *AchievementsSnapshotClient {
	return &AchievementsSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `achievementssnapshot.Hooks(f(g(h())))`.
func (c *AchievementsSnapshotClient) Use(hooks ...Hook) {
	c.hooks.AchievementsSnapshot = append(c.hooks.AchievementsSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `achievementssnapshot.Intercept(f(g(h())))`.
func (c *AchievementsSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.AchievementsSnapshot = append(c.inters.AchievementsSnapshot, interceptors...)
}

// Create returns a builder for creating a AchievementsSnapshot entity.
func (c *AchievementsSnapshotClient) Create() *AchievementsSnapshotCreate {
	mutation := newAchievementsSnapshotMutation(c.config, OpCreate)
	return &AchievementsSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AchievementsSnapshot entities.
func (c *AchievementsSnapshotClient) CreateBulk(builders ...*AchievementsSnapshotCreate) *AchievementsSnapshotCreateBulk {
	return &AchievementsSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AchievementsSnapshotClient) MapCreateBulk(slice any, setFunc func(*AchievementsSnapshotCreate, int)) *AchievementsSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AchievementsSnapshotCreateBulk{err: fmt.Errorf("calling to AchievementsSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AchievementsSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AchievementsSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AchievementsSnapshot.
func (c *AchievementsSnapshotClient) Update() *AchievementsSnapshotUpdate {
	mutation := newAchievementsSnapshotMutation(c.config, OpUpdate)
	return &AchievementsSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AchievementsSnapshotClient) UpdateOne(as *AchievementsSnapshot) *AchievementsSnapshotUpdateOne {
	mutation := newAchievementsSnapshotMutation(c.config, OpUpdateOne, withAchievementsSnapshot(as))
	return &AchievementsSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AchievementsSnapshotClient) UpdateOneID(id string) *AchievementsSnapshotUpdateOne {
	mutation := newAchievementsSnapshotMutation(c.config, OpUpdateOne, withAchievementsSnapshotID(id))
	return &AchievementsSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AchievementsSnapshot.
func (c *AchievementsSnapshotClient) Delete() *AchievementsSnapshotDelete {
	mutation := newAchievementsSnapshotMutation(c.config, OpDelete)
	return &AchievementsSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AchievementsSnapshotClient) DeleteOne(as *AchievementsSnapshot) *AchievementsSnapshotDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AchievementsSnapshotClient) DeleteOneID(id string) *AchievementsSnapshotDeleteOne {
	builder := c.Delete().Where(achievementssnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AchievementsSnapshotDeleteOne{builder}
}

// Query returns a query builder for AchievementsSnapshot.
func (c *AchievementsSnapshotClient) Query() *AchievementsSnapshotQuery {
	return &AchievementsSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAchievementsSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a AchievementsSnapshot entity by its id.
func (c *AchievementsSnapshotClient) Get(ctx context.Context, id string) (*AchievementsSnapshot, error) {
	return c.Query().Where(achievementssnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AchievementsSnapshotClient) GetX(ctx context.Context, id string) *AchievementsSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a AchievementsSnapshot.
func (c *AchievementsSnapshotClient) QueryAccount(as *AchievementsSnapshot) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(achievementssnapshot.Table, achievementssnapshot.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, achievementssnapshot.AccountTable, achievementssnapshot.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AchievementsSnapshotClient) Hooks() []Hook {
	return c.hooks.AchievementsSnapshot
}

// Interceptors returns the client interceptors.
func (c *AchievementsSnapshotClient) Interceptors() []Interceptor {
	return c.inters.AchievementsSnapshot
}

func (c *AchievementsSnapshotClient) mutate(ctx context.Context, m *AchievementsSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AchievementsSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AchievementsSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AchievementsSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AchievementsSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown AchievementsSnapshot mutation op: %q", m.Op())
	}
}

// AppConfigurationClient is a client for the AppConfiguration schema.
type AppConfigurationClient struct {
	config
}

// NewAppConfigurationClient returns a client for the AppConfiguration from the given config.
func NewAppConfigurationClient(c config) *AppConfigurationClient {
	return &AppConfigurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appconfiguration.Hooks(f(g(h())))`.
func (c *AppConfigurationClient) Use(hooks ...Hook) {
	c.hooks.AppConfiguration = append(c.hooks.AppConfiguration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appconfiguration.Intercept(f(g(h())))`.
func (c *AppConfigurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppConfiguration = append(c.inters.AppConfiguration, interceptors...)
}

// Create returns a builder for creating a AppConfiguration entity.
func (c *AppConfigurationClient) Create() *AppConfigurationCreate {
	mutation := newAppConfigurationMutation(c.config, OpCreate)
	return &AppConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppConfiguration entities.
func (c *AppConfigurationClient) CreateBulk(builders ...*AppConfigurationCreate) *AppConfigurationCreateBulk {
	return &AppConfigurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppConfigurationClient) MapCreateBulk(slice any, setFunc func(*AppConfigurationCreate, int)) *AppConfigurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppConfigurationCreateBulk{err: fmt.Errorf("calling to AppConfigurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppConfigurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppConfigurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppConfiguration.
func (c *AppConfigurationClient) Update() *AppConfigurationUpdate {
	mutation := newAppConfigurationMutation(c.config, OpUpdate)
	return &AppConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppConfigurationClient) UpdateOne(ac *AppConfiguration) *AppConfigurationUpdateOne {
	mutation := newAppConfigurationMutation(c.config, OpUpdateOne, withAppConfiguration(ac))
	return &AppConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppConfigurationClient) UpdateOneID(id string) *AppConfigurationUpdateOne {
	mutation := newAppConfigurationMutation(c.config, OpUpdateOne, withAppConfigurationID(id))
	return &AppConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppConfiguration.
func (c *AppConfigurationClient) Delete() *AppConfigurationDelete {
	mutation := newAppConfigurationMutation(c.config, OpDelete)
	return &AppConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppConfigurationClient) DeleteOne(ac *AppConfiguration) *AppConfigurationDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppConfigurationClient) DeleteOneID(id string) *AppConfigurationDeleteOne {
	builder := c.Delete().Where(appconfiguration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppConfigurationDeleteOne{builder}
}

// Query returns a query builder for AppConfiguration.
func (c *AppConfigurationClient) Query() *AppConfigurationQuery {
	return &AppConfigurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppConfiguration},
		inters: c.Interceptors(),
	}
}

// Get returns a AppConfiguration entity by its id.
func (c *AppConfigurationClient) Get(ctx context.Context, id string) (*AppConfiguration, error) {
	return c.Query().Where(appconfiguration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppConfigurationClient) GetX(ctx context.Context, id string) *AppConfiguration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppConfigurationClient) Hooks() []Hook {
	return c.hooks.AppConfiguration
}

// Interceptors returns the client interceptors.
func (c *AppConfigurationClient) Interceptors() []Interceptor {
	return c.inters.AppConfiguration
}

func (c *AppConfigurationClient) mutate(ctx context.Context, m *AppConfigurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown AppConfiguration mutation op: %q", m.Op())
	}
}

// ApplicationCommandClient is a client for the ApplicationCommand schema.
type ApplicationCommandClient struct {
	config
}

// NewApplicationCommandClient returns a client for the ApplicationCommand from the given config.
func NewApplicationCommandClient(c config) *ApplicationCommandClient {
	return &ApplicationCommandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `applicationcommand.Hooks(f(g(h())))`.
func (c *ApplicationCommandClient) Use(hooks ...Hook) {
	c.hooks.ApplicationCommand = append(c.hooks.ApplicationCommand, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `applicationcommand.Intercept(f(g(h())))`.
func (c *ApplicationCommandClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApplicationCommand = append(c.inters.ApplicationCommand, interceptors...)
}

// Create returns a builder for creating a ApplicationCommand entity.
func (c *ApplicationCommandClient) Create() *ApplicationCommandCreate {
	mutation := newApplicationCommandMutation(c.config, OpCreate)
	return &ApplicationCommandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApplicationCommand entities.
func (c *ApplicationCommandClient) CreateBulk(builders ...*ApplicationCommandCreate) *ApplicationCommandCreateBulk {
	return &ApplicationCommandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApplicationCommandClient) MapCreateBulk(slice any, setFunc func(*ApplicationCommandCreate, int)) *ApplicationCommandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApplicationCommandCreateBulk{err: fmt.Errorf("calling to ApplicationCommandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApplicationCommandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApplicationCommandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApplicationCommand.
func (c *ApplicationCommandClient) Update() *ApplicationCommandUpdate {
	mutation := newApplicationCommandMutation(c.config, OpUpdate)
	return &ApplicationCommandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApplicationCommandClient) UpdateOne(ac *ApplicationCommand) *ApplicationCommandUpdateOne {
	mutation := newApplicationCommandMutation(c.config, OpUpdateOne, withApplicationCommand(ac))
	return &ApplicationCommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApplicationCommandClient) UpdateOneID(id string) *ApplicationCommandUpdateOne {
	mutation := newApplicationCommandMutation(c.config, OpUpdateOne, withApplicationCommandID(id))
	return &ApplicationCommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApplicationCommand.
func (c *ApplicationCommandClient) Delete() *ApplicationCommandDelete {
	mutation := newApplicationCommandMutation(c.config, OpDelete)
	return &ApplicationCommandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApplicationCommandClient) DeleteOne(ac *ApplicationCommand) *ApplicationCommandDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApplicationCommandClient) DeleteOneID(id string) *ApplicationCommandDeleteOne {
	builder := c.Delete().Where(applicationcommand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApplicationCommandDeleteOne{builder}
}

// Query returns a query builder for ApplicationCommand.
func (c *ApplicationCommandClient) Query() *ApplicationCommandQuery {
	return &ApplicationCommandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApplicationCommand},
		inters: c.Interceptors(),
	}
}

// Get returns a ApplicationCommand entity by its id.
func (c *ApplicationCommandClient) Get(ctx context.Context, id string) (*ApplicationCommand, error) {
	return c.Query().Where(applicationcommand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApplicationCommandClient) GetX(ctx context.Context, id string) *ApplicationCommand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApplicationCommandClient) Hooks() []Hook {
	return c.hooks.ApplicationCommand
}

// Interceptors returns the client interceptors.
func (c *ApplicationCommandClient) Interceptors() []Interceptor {
	return c.inters.ApplicationCommand
}

func (c *ApplicationCommandClient) mutate(ctx context.Context, m *ApplicationCommandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApplicationCommandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApplicationCommandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApplicationCommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApplicationCommandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown ApplicationCommand mutation op: %q", m.Op())
	}
}

// ClanClient is a client for the Clan schema.
type ClanClient struct {
	config
}

// NewClanClient returns a client for the Clan from the given config.
func NewClanClient(c config) *ClanClient {
	return &ClanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clan.Hooks(f(g(h())))`.
func (c *ClanClient) Use(hooks ...Hook) {
	c.hooks.Clan = append(c.hooks.Clan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clan.Intercept(f(g(h())))`.
func (c *ClanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Clan = append(c.inters.Clan, interceptors...)
}

// Create returns a builder for creating a Clan entity.
func (c *ClanClient) Create() *ClanCreate {
	mutation := newClanMutation(c.config, OpCreate)
	return &ClanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Clan entities.
func (c *ClanClient) CreateBulk(builders ...*ClanCreate) *ClanCreateBulk {
	return &ClanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClanClient) MapCreateBulk(slice any, setFunc func(*ClanCreate, int)) *ClanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClanCreateBulk{err: fmt.Errorf("calling to ClanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Clan.
func (c *ClanClient) Update() *ClanUpdate {
	mutation := newClanMutation(c.config, OpUpdate)
	return &ClanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClanClient) UpdateOne(cl *Clan) *ClanUpdateOne {
	mutation := newClanMutation(c.config, OpUpdateOne, withClan(cl))
	return &ClanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClanClient) UpdateOneID(id string) *ClanUpdateOne {
	mutation := newClanMutation(c.config, OpUpdateOne, withClanID(id))
	return &ClanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Clan.
func (c *ClanClient) Delete() *ClanDelete {
	mutation := newClanMutation(c.config, OpDelete)
	return &ClanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClanClient) DeleteOne(cl *Clan) *ClanDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClanClient) DeleteOneID(id string) *ClanDeleteOne {
	builder := c.Delete().Where(clan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClanDeleteOne{builder}
}

// Query returns a query builder for Clan.
func (c *ClanClient) Query() *ClanQuery {
	return &ClanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClan},
		inters: c.Interceptors(),
	}
}

// Get returns a Clan entity by its id.
func (c *ClanClient) Get(ctx context.Context, id string) (*Clan, error) {
	return c.Query().Where(clan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClanClient) GetX(ctx context.Context, id string) *Clan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccounts queries the accounts edge of a Clan.
func (c *ClanClient) QueryAccounts(cl *Clan) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clan.Table, clan.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clan.AccountsTable, clan.AccountsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClanClient) Hooks() []Hook {
	return c.hooks.Clan
}

// Interceptors returns the client interceptors.
func (c *ClanClient) Interceptors() []Interceptor {
	return c.inters.Clan
}

func (c *ClanClient) mutate(ctx context.Context, m *ClanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Clan mutation op: %q", m.Op())
	}
}

// CronTaskClient is a client for the CronTask schema.
type CronTaskClient struct {
	config
}

// NewCronTaskClient returns a client for the CronTask from the given config.
func NewCronTaskClient(c config) *CronTaskClient {
	return &CronTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `crontask.Hooks(f(g(h())))`.
func (c *CronTaskClient) Use(hooks ...Hook) {
	c.hooks.CronTask = append(c.hooks.CronTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `crontask.Intercept(f(g(h())))`.
func (c *CronTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.CronTask = append(c.inters.CronTask, interceptors...)
}

// Create returns a builder for creating a CronTask entity.
func (c *CronTaskClient) Create() *CronTaskCreate {
	mutation := newCronTaskMutation(c.config, OpCreate)
	return &CronTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CronTask entities.
func (c *CronTaskClient) CreateBulk(builders ...*CronTaskCreate) *CronTaskCreateBulk {
	return &CronTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CronTaskClient) MapCreateBulk(slice any, setFunc func(*CronTaskCreate, int)) *CronTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CronTaskCreateBulk{err: fmt.Errorf("calling to CronTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CronTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CronTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CronTask.
func (c *CronTaskClient) Update() *CronTaskUpdate {
	mutation := newCronTaskMutation(c.config, OpUpdate)
	return &CronTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CronTaskClient) UpdateOne(ct *CronTask) *CronTaskUpdateOne {
	mutation := newCronTaskMutation(c.config, OpUpdateOne, withCronTask(ct))
	return &CronTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CronTaskClient) UpdateOneID(id string) *CronTaskUpdateOne {
	mutation := newCronTaskMutation(c.config, OpUpdateOne, withCronTaskID(id))
	return &CronTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CronTask.
func (c *CronTaskClient) Delete() *CronTaskDelete {
	mutation := newCronTaskMutation(c.config, OpDelete)
	return &CronTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CronTaskClient) DeleteOne(ct *CronTask) *CronTaskDeleteOne {
	return c.DeleteOneID(ct.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CronTaskClient) DeleteOneID(id string) *CronTaskDeleteOne {
	builder := c.Delete().Where(crontask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CronTaskDeleteOne{builder}
}

// Query returns a query builder for CronTask.
func (c *CronTaskClient) Query() *CronTaskQuery {
	return &CronTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCronTask},
		inters: c.Interceptors(),
	}
}

// Get returns a CronTask entity by its id.
func (c *CronTaskClient) Get(ctx context.Context, id string) (*CronTask, error) {
	return c.Query().Where(crontask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CronTaskClient) GetX(ctx context.Context, id string) *CronTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CronTaskClient) Hooks() []Hook {
	return c.hooks.CronTask
}

// Interceptors returns the client interceptors.
func (c *CronTaskClient) Interceptors() []Interceptor {
	return c.inters.CronTask
}

func (c *CronTaskClient) mutate(ctx context.Context, m *CronTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CronTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CronTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CronTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CronTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown CronTask mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(u *User) *UserSubscriptionQuery {
	query := (&UserSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersubscription.Table, usersubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnections queries the connections edge of a User.
func (c *UserClient) QueryConnections(u *User) *UserConnectionQuery {
	query := (&UserConnectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userconnection.Table, userconnection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConnectionsTable, user.ConnectionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContent queries the content edge of a User.
func (c *UserClient) QueryContent(u *User) *UserContentQuery {
	query := (&UserContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usercontent.Table, usercontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ContentTable, user.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown User mutation op: %q", m.Op())
	}
}

// UserConnectionClient is a client for the UserConnection schema.
type UserConnectionClient struct {
	config
}

// NewUserConnectionClient returns a client for the UserConnection from the given config.
func NewUserConnectionClient(c config) *UserConnectionClient {
	return &UserConnectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userconnection.Hooks(f(g(h())))`.
func (c *UserConnectionClient) Use(hooks ...Hook) {
	c.hooks.UserConnection = append(c.hooks.UserConnection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userconnection.Intercept(f(g(h())))`.
func (c *UserConnectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserConnection = append(c.inters.UserConnection, interceptors...)
}

// Create returns a builder for creating a UserConnection entity.
func (c *UserConnectionClient) Create() *UserConnectionCreate {
	mutation := newUserConnectionMutation(c.config, OpCreate)
	return &UserConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserConnection entities.
func (c *UserConnectionClient) CreateBulk(builders ...*UserConnectionCreate) *UserConnectionCreateBulk {
	return &UserConnectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserConnectionClient) MapCreateBulk(slice any, setFunc func(*UserConnectionCreate, int)) *UserConnectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserConnectionCreateBulk{err: fmt.Errorf("calling to UserConnectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserConnectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserConnectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserConnection.
func (c *UserConnectionClient) Update() *UserConnectionUpdate {
	mutation := newUserConnectionMutation(c.config, OpUpdate)
	return &UserConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserConnectionClient) UpdateOne(uc *UserConnection) *UserConnectionUpdateOne {
	mutation := newUserConnectionMutation(c.config, OpUpdateOne, withUserConnection(uc))
	return &UserConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserConnectionClient) UpdateOneID(id string) *UserConnectionUpdateOne {
	mutation := newUserConnectionMutation(c.config, OpUpdateOne, withUserConnectionID(id))
	return &UserConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserConnection.
func (c *UserConnectionClient) Delete() *UserConnectionDelete {
	mutation := newUserConnectionMutation(c.config, OpDelete)
	return &UserConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserConnectionClient) DeleteOne(uc *UserConnection) *UserConnectionDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserConnectionClient) DeleteOneID(id string) *UserConnectionDeleteOne {
	builder := c.Delete().Where(userconnection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserConnectionDeleteOne{builder}
}

// Query returns a query builder for UserConnection.
func (c *UserConnectionClient) Query() *UserConnectionQuery {
	return &UserConnectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserConnection},
		inters: c.Interceptors(),
	}
}

// Get returns a UserConnection entity by its id.
func (c *UserConnectionClient) Get(ctx context.Context, id string) (*UserConnection, error) {
	return c.Query().Where(userconnection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserConnectionClient) GetX(ctx context.Context, id string) *UserConnection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserConnection.
func (c *UserConnectionClient) QueryUser(uc *UserConnection) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userconnection.Table, userconnection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userconnection.UserTable, userconnection.UserColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserConnectionClient) Hooks() []Hook {
	return c.hooks.UserConnection
}

// Interceptors returns the client interceptors.
func (c *UserConnectionClient) Interceptors() []Interceptor {
	return c.inters.UserConnection
}

func (c *UserConnectionClient) mutate(ctx context.Context, m *UserConnectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown UserConnection mutation op: %q", m.Op())
	}
}

// UserContentClient is a client for the UserContent schema.
type UserContentClient struct {
	config
}

// NewUserContentClient returns a client for the UserContent from the given config.
func NewUserContentClient(c config) *UserContentClient {
	return &UserContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercontent.Hooks(f(g(h())))`.
func (c *UserContentClient) Use(hooks ...Hook) {
	c.hooks.UserContent = append(c.hooks.UserContent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercontent.Intercept(f(g(h())))`.
func (c *UserContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserContent = append(c.inters.UserContent, interceptors...)
}

// Create returns a builder for creating a UserContent entity.
func (c *UserContentClient) Create() *UserContentCreate {
	mutation := newUserContentMutation(c.config, OpCreate)
	return &UserContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserContent entities.
func (c *UserContentClient) CreateBulk(builders ...*UserContentCreate) *UserContentCreateBulk {
	return &UserContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserContentClient) MapCreateBulk(slice any, setFunc func(*UserContentCreate, int)) *UserContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserContentCreateBulk{err: fmt.Errorf("calling to UserContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserContent.
func (c *UserContentClient) Update() *UserContentUpdate {
	mutation := newUserContentMutation(c.config, OpUpdate)
	return &UserContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserContentClient) UpdateOne(uc *UserContent) *UserContentUpdateOne {
	mutation := newUserContentMutation(c.config, OpUpdateOne, withUserContent(uc))
	return &UserContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserContentClient) UpdateOneID(id string) *UserContentUpdateOne {
	mutation := newUserContentMutation(c.config, OpUpdateOne, withUserContentID(id))
	return &UserContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserContent.
func (c *UserContentClient) Delete() *UserContentDelete {
	mutation := newUserContentMutation(c.config, OpDelete)
	return &UserContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserContentClient) DeleteOne(uc *UserContent) *UserContentDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserContentClient) DeleteOneID(id string) *UserContentDeleteOne {
	builder := c.Delete().Where(usercontent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserContentDeleteOne{builder}
}

// Query returns a query builder for UserContent.
func (c *UserContentClient) Query() *UserContentQuery {
	return &UserContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserContent},
		inters: c.Interceptors(),
	}
}

// Get returns a UserContent entity by its id.
func (c *UserContentClient) Get(ctx context.Context, id string) (*UserContent, error) {
	return c.Query().Where(usercontent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserContentClient) GetX(ctx context.Context, id string) *UserContent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserContent.
func (c *UserContentClient) QueryUser(uc *UserContent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercontent.Table, usercontent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usercontent.UserTable, usercontent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserContentClient) Hooks() []Hook {
	return c.hooks.UserContent
}

// Interceptors returns the client interceptors.
func (c *UserContentClient) Interceptors() []Interceptor {
	return c.inters.UserContent
}

func (c *UserContentClient) mutate(ctx context.Context, m *UserContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown UserContent mutation op: %q", m.Op())
	}
}

// UserSubscriptionClient is a client for the UserSubscription schema.
type UserSubscriptionClient struct {
	config
}

// NewUserSubscriptionClient returns a client for the UserSubscription from the given config.
func NewUserSubscriptionClient(c config) *UserSubscriptionClient {
	return &UserSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersubscription.Hooks(f(g(h())))`.
func (c *UserSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.UserSubscription = append(c.hooks.UserSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersubscription.Intercept(f(g(h())))`.
func (c *UserSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSubscription = append(c.inters.UserSubscription, interceptors...)
}

// Create returns a builder for creating a UserSubscription entity.
func (c *UserSubscriptionClient) Create() *UserSubscriptionCreate {
	mutation := newUserSubscriptionMutation(c.config, OpCreate)
	return &UserSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSubscription entities.
func (c *UserSubscriptionClient) CreateBulk(builders ...*UserSubscriptionCreate) *UserSubscriptionCreateBulk {
	return &UserSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSubscriptionClient) MapCreateBulk(slice any, setFunc func(*UserSubscriptionCreate, int)) *UserSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSubscriptionCreateBulk{err: fmt.Errorf("calling to UserSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSubscription.
func (c *UserSubscriptionClient) Update() *UserSubscriptionUpdate {
	mutation := newUserSubscriptionMutation(c.config, OpUpdate)
	return &UserSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSubscriptionClient) UpdateOne(us *UserSubscription) *UserSubscriptionUpdateOne {
	mutation := newUserSubscriptionMutation(c.config, OpUpdateOne, withUserSubscription(us))
	return &UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSubscriptionClient) UpdateOneID(id string) *UserSubscriptionUpdateOne {
	mutation := newUserSubscriptionMutation(c.config, OpUpdateOne, withUserSubscriptionID(id))
	return &UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSubscription.
func (c *UserSubscriptionClient) Delete() *UserSubscriptionDelete {
	mutation := newUserSubscriptionMutation(c.config, OpDelete)
	return &UserSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSubscriptionClient) DeleteOne(us *UserSubscription) *UserSubscriptionDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSubscriptionClient) DeleteOneID(id string) *UserSubscriptionDeleteOne {
	builder := c.Delete().Where(usersubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSubscriptionDeleteOne{builder}
}

// Query returns a query builder for UserSubscription.
func (c *UserSubscriptionClient) Query() *UserSubscriptionQuery {
	return &UserSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSubscription entity by its id.
func (c *UserSubscriptionClient) Get(ctx context.Context, id string) (*UserSubscription, error) {
	return c.Query().Where(usersubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSubscriptionClient) GetX(ctx context.Context, id string) *UserSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSubscription.
func (c *UserSubscriptionClient) QueryUser(us *UserSubscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersubscription.Table, usersubscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersubscription.UserTable, usersubscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSubscriptionClient) Hooks() []Hook {
	return c.hooks.UserSubscription
}

// Interceptors returns the client interceptors.
func (c *UserSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.UserSubscription
}

func (c *UserSubscriptionClient) mutate(ctx context.Context, m *UserSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown UserSubscription mutation op: %q", m.Op())
	}
}

// VehicleClient is a client for the Vehicle schema.
type VehicleClient struct {
	config
}

// NewVehicleClient returns a client for the Vehicle from the given config.
func NewVehicleClient(c config) *VehicleClient {
	return &VehicleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehicle.Hooks(f(g(h())))`.
func (c *VehicleClient) Use(hooks ...Hook) {
	c.hooks.Vehicle = append(c.hooks.Vehicle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehicle.Intercept(f(g(h())))`.
func (c *VehicleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vehicle = append(c.inters.Vehicle, interceptors...)
}

// Create returns a builder for creating a Vehicle entity.
func (c *VehicleClient) Create() *VehicleCreate {
	mutation := newVehicleMutation(c.config, OpCreate)
	return &VehicleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vehicle entities.
func (c *VehicleClient) CreateBulk(builders ...*VehicleCreate) *VehicleCreateBulk {
	return &VehicleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleClient) MapCreateBulk(slice any, setFunc func(*VehicleCreate, int)) *VehicleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleCreateBulk{err: fmt.Errorf("calling to VehicleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vehicle.
func (c *VehicleClient) Update() *VehicleUpdate {
	mutation := newVehicleMutation(c.config, OpUpdate)
	return &VehicleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleClient) UpdateOne(v *Vehicle) *VehicleUpdateOne {
	mutation := newVehicleMutation(c.config, OpUpdateOne, withVehicle(v))
	return &VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleClient) UpdateOneID(id string) *VehicleUpdateOne {
	mutation := newVehicleMutation(c.config, OpUpdateOne, withVehicleID(id))
	return &VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vehicle.
func (c *VehicleClient) Delete() *VehicleDelete {
	mutation := newVehicleMutation(c.config, OpDelete)
	return &VehicleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleClient) DeleteOne(v *Vehicle) *VehicleDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleClient) DeleteOneID(id string) *VehicleDeleteOne {
	builder := c.Delete().Where(vehicle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleDeleteOne{builder}
}

// Query returns a query builder for Vehicle.
func (c *VehicleClient) Query() *VehicleQuery {
	return &VehicleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicle},
		inters: c.Interceptors(),
	}
}

// Get returns a Vehicle entity by its id.
func (c *VehicleClient) Get(ctx context.Context, id string) (*Vehicle, error) {
	return c.Query().Where(vehicle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleClient) GetX(ctx context.Context, id string) *Vehicle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VehicleClient) Hooks() []Hook {
	return c.hooks.Vehicle
}

// Interceptors returns the client interceptors.
func (c *VehicleClient) Interceptors() []Interceptor {
	return c.inters.Vehicle
}

func (c *VehicleClient) mutate(ctx context.Context, m *VehicleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Vehicle mutation op: %q", m.Op())
	}
}

// VehicleAverageClient is a client for the VehicleAverage schema.
type VehicleAverageClient struct {
	config
}

// NewVehicleAverageClient returns a client for the VehicleAverage from the given config.
func NewVehicleAverageClient(c config) *VehicleAverageClient {
	return &VehicleAverageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehicleaverage.Hooks(f(g(h())))`.
func (c *VehicleAverageClient) Use(hooks ...Hook) {
	c.hooks.VehicleAverage = append(c.hooks.VehicleAverage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehicleaverage.Intercept(f(g(h())))`.
func (c *VehicleAverageClient) Intercept(interceptors ...Interceptor) {
	c.inters.VehicleAverage = append(c.inters.VehicleAverage, interceptors...)
}

// Create returns a builder for creating a VehicleAverage entity.
func (c *VehicleAverageClient) Create() *VehicleAverageCreate {
	mutation := newVehicleAverageMutation(c.config, OpCreate)
	return &VehicleAverageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VehicleAverage entities.
func (c *VehicleAverageClient) CreateBulk(builders ...*VehicleAverageCreate) *VehicleAverageCreateBulk {
	return &VehicleAverageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleAverageClient) MapCreateBulk(slice any, setFunc func(*VehicleAverageCreate, int)) *VehicleAverageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleAverageCreateBulk{err: fmt.Errorf("calling to VehicleAverageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleAverageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleAverageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VehicleAverage.
func (c *VehicleAverageClient) Update() *VehicleAverageUpdate {
	mutation := newVehicleAverageMutation(c.config, OpUpdate)
	return &VehicleAverageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleAverageClient) UpdateOne(va *VehicleAverage) *VehicleAverageUpdateOne {
	mutation := newVehicleAverageMutation(c.config, OpUpdateOne, withVehicleAverage(va))
	return &VehicleAverageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleAverageClient) UpdateOneID(id string) *VehicleAverageUpdateOne {
	mutation := newVehicleAverageMutation(c.config, OpUpdateOne, withVehicleAverageID(id))
	return &VehicleAverageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VehicleAverage.
func (c *VehicleAverageClient) Delete() *VehicleAverageDelete {
	mutation := newVehicleAverageMutation(c.config, OpDelete)
	return &VehicleAverageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleAverageClient) DeleteOne(va *VehicleAverage) *VehicleAverageDeleteOne {
	return c.DeleteOneID(va.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleAverageClient) DeleteOneID(id string) *VehicleAverageDeleteOne {
	builder := c.Delete().Where(vehicleaverage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleAverageDeleteOne{builder}
}

// Query returns a query builder for VehicleAverage.
func (c *VehicleAverageClient) Query() *VehicleAverageQuery {
	return &VehicleAverageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicleAverage},
		inters: c.Interceptors(),
	}
}

// Get returns a VehicleAverage entity by its id.
func (c *VehicleAverageClient) Get(ctx context.Context, id string) (*VehicleAverage, error) {
	return c.Query().Where(vehicleaverage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleAverageClient) GetX(ctx context.Context, id string) *VehicleAverage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VehicleAverageClient) Hooks() []Hook {
	return c.hooks.VehicleAverage
}

// Interceptors returns the client interceptors.
func (c *VehicleAverageClient) Interceptors() []Interceptor {
	return c.inters.VehicleAverage
}

func (c *VehicleAverageClient) mutate(ctx context.Context, m *VehicleAverageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleAverageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleAverageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleAverageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleAverageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown VehicleAverage mutation op: %q", m.Op())
	}
}

// VehicleSnapshotClient is a client for the VehicleSnapshot schema.
type VehicleSnapshotClient struct {
	config
}

// NewVehicleSnapshotClient returns a client for the VehicleSnapshot from the given config.
func NewVehicleSnapshotClient(c config) *VehicleSnapshotClient {
	return &VehicleSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehiclesnapshot.Hooks(f(g(h())))`.
func (c *VehicleSnapshotClient) Use(hooks ...Hook) {
	c.hooks.VehicleSnapshot = append(c.hooks.VehicleSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehiclesnapshot.Intercept(f(g(h())))`.
func (c *VehicleSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.VehicleSnapshot = append(c.inters.VehicleSnapshot, interceptors...)
}

// Create returns a builder for creating a VehicleSnapshot entity.
func (c *VehicleSnapshotClient) Create() *VehicleSnapshotCreate {
	mutation := newVehicleSnapshotMutation(c.config, OpCreate)
	return &VehicleSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VehicleSnapshot entities.
func (c *VehicleSnapshotClient) CreateBulk(builders ...*VehicleSnapshotCreate) *VehicleSnapshotCreateBulk {
	return &VehicleSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleSnapshotClient) MapCreateBulk(slice any, setFunc func(*VehicleSnapshotCreate, int)) *VehicleSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleSnapshotCreateBulk{err: fmt.Errorf("calling to VehicleSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VehicleSnapshot.
func (c *VehicleSnapshotClient) Update() *VehicleSnapshotUpdate {
	mutation := newVehicleSnapshotMutation(c.config, OpUpdate)
	return &VehicleSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleSnapshotClient) UpdateOne(vs *VehicleSnapshot) *VehicleSnapshotUpdateOne {
	mutation := newVehicleSnapshotMutation(c.config, OpUpdateOne, withVehicleSnapshot(vs))
	return &VehicleSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleSnapshotClient) UpdateOneID(id string) *VehicleSnapshotUpdateOne {
	mutation := newVehicleSnapshotMutation(c.config, OpUpdateOne, withVehicleSnapshotID(id))
	return &VehicleSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VehicleSnapshot.
func (c *VehicleSnapshotClient) Delete() *VehicleSnapshotDelete {
	mutation := newVehicleSnapshotMutation(c.config, OpDelete)
	return &VehicleSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleSnapshotClient) DeleteOne(vs *VehicleSnapshot) *VehicleSnapshotDeleteOne {
	return c.DeleteOneID(vs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleSnapshotClient) DeleteOneID(id string) *VehicleSnapshotDeleteOne {
	builder := c.Delete().Where(vehiclesnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleSnapshotDeleteOne{builder}
}

// Query returns a query builder for VehicleSnapshot.
func (c *VehicleSnapshotClient) Query() *VehicleSnapshotQuery {
	return &VehicleSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicleSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a VehicleSnapshot entity by its id.
func (c *VehicleSnapshotClient) Get(ctx context.Context, id string) (*VehicleSnapshot, error) {
	return c.Query().Where(vehiclesnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleSnapshotClient) GetX(ctx context.Context, id string) *VehicleSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a VehicleSnapshot.
func (c *VehicleSnapshotClient) QueryAccount(vs *VehicleSnapshot) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vehiclesnapshot.Table, vehiclesnapshot.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vehiclesnapshot.AccountTable, vehiclesnapshot.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VehicleSnapshotClient) Hooks() []Hook {
	return c.hooks.VehicleSnapshot
}

// Interceptors returns the client interceptors.
func (c *VehicleSnapshotClient) Interceptors() []Interceptor {
	return c.inters.VehicleSnapshot
}

func (c *VehicleSnapshotClient) mutate(ctx context.Context, m *VehicleSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown VehicleSnapshot mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Account, AccountSnapshot, AchievementsSnapshot, AppConfiguration,
		ApplicationCommand, Clan, CronTask, User, UserConnection, UserContent,
		UserSubscription, Vehicle, VehicleAverage, VehicleSnapshot []ent.Hook
	}
	inters struct {
		Account, AccountSnapshot, AchievementsSnapshot, AppConfiguration,
		ApplicationCommand, Clan, CronTask, User, UserConnection, UserContent,
		UserSubscription, Vehicle, VehicleAverage, VehicleSnapshot []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
