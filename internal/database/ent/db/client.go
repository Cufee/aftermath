// Code generated by ent, DO NOT EDIT.

package db

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"github.com/cufee/aftermath/internal/database/ent/db/migrate"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/cufee/aftermath/internal/database/ent/db/account"
	"github.com/cufee/aftermath/internal/database/ent/db/accountsnapshot"
	"github.com/cufee/aftermath/internal/database/ent/db/appconfiguration"
	"github.com/cufee/aftermath/internal/database/ent/db/applicationcommand"
	"github.com/cufee/aftermath/internal/database/ent/db/authnonce"
	"github.com/cufee/aftermath/internal/database/ent/db/clan"
	"github.com/cufee/aftermath/internal/database/ent/db/crontask"
	"github.com/cufee/aftermath/internal/database/ent/db/discordinteraction"
	"github.com/cufee/aftermath/internal/database/ent/db/gamemap"
	"github.com/cufee/aftermath/internal/database/ent/db/gamemode"
	"github.com/cufee/aftermath/internal/database/ent/db/leaderboardscore"
	"github.com/cufee/aftermath/internal/database/ent/db/session"
	"github.com/cufee/aftermath/internal/database/ent/db/user"
	"github.com/cufee/aftermath/internal/database/ent/db/userconnection"
	"github.com/cufee/aftermath/internal/database/ent/db/usercontent"
	"github.com/cufee/aftermath/internal/database/ent/db/usersubscription"
	"github.com/cufee/aftermath/internal/database/ent/db/vehicle"
	"github.com/cufee/aftermath/internal/database/ent/db/vehicleaverage"
	"github.com/cufee/aftermath/internal/database/ent/db/vehiclesnapshot"
	"github.com/cufee/aftermath/internal/database/ent/db/widgetsettings"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Account is the client for interacting with the Account builders.
	Account *AccountClient
	// AccountSnapshot is the client for interacting with the AccountSnapshot builders.
	AccountSnapshot *AccountSnapshotClient
	// AppConfiguration is the client for interacting with the AppConfiguration builders.
	AppConfiguration *AppConfigurationClient
	// ApplicationCommand is the client for interacting with the ApplicationCommand builders.
	ApplicationCommand *ApplicationCommandClient
	// AuthNonce is the client for interacting with the AuthNonce builders.
	AuthNonce *AuthNonceClient
	// Clan is the client for interacting with the Clan builders.
	Clan *ClanClient
	// CronTask is the client for interacting with the CronTask builders.
	CronTask *CronTaskClient
	// DiscordInteraction is the client for interacting with the DiscordInteraction builders.
	DiscordInteraction *DiscordInteractionClient
	// GameMap is the client for interacting with the GameMap builders.
	GameMap *GameMapClient
	// GameMode is the client for interacting with the GameMode builders.
	GameMode *GameModeClient
	// LeaderboardScore is the client for interacting with the LeaderboardScore builders.
	LeaderboardScore *LeaderboardScoreClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserConnection is the client for interacting with the UserConnection builders.
	UserConnection *UserConnectionClient
	// UserContent is the client for interacting with the UserContent builders.
	UserContent *UserContentClient
	// UserSubscription is the client for interacting with the UserSubscription builders.
	UserSubscription *UserSubscriptionClient
	// Vehicle is the client for interacting with the Vehicle builders.
	Vehicle *VehicleClient
	// VehicleAverage is the client for interacting with the VehicleAverage builders.
	VehicleAverage *VehicleAverageClient
	// VehicleSnapshot is the client for interacting with the VehicleSnapshot builders.
	VehicleSnapshot *VehicleSnapshotClient
	// WidgetSettings is the client for interacting with the WidgetSettings builders.
	WidgetSettings *WidgetSettingsClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Account = NewAccountClient(c.config)
	c.AccountSnapshot = NewAccountSnapshotClient(c.config)
	c.AppConfiguration = NewAppConfigurationClient(c.config)
	c.ApplicationCommand = NewApplicationCommandClient(c.config)
	c.AuthNonce = NewAuthNonceClient(c.config)
	c.Clan = NewClanClient(c.config)
	c.CronTask = NewCronTaskClient(c.config)
	c.DiscordInteraction = NewDiscordInteractionClient(c.config)
	c.GameMap = NewGameMapClient(c.config)
	c.GameMode = NewGameModeClient(c.config)
	c.LeaderboardScore = NewLeaderboardScoreClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserConnection = NewUserConnectionClient(c.config)
	c.UserContent = NewUserContentClient(c.config)
	c.UserSubscription = NewUserSubscriptionClient(c.config)
	c.Vehicle = NewVehicleClient(c.config)
	c.VehicleAverage = NewVehicleAverageClient(c.config)
	c.VehicleSnapshot = NewVehicleSnapshotClient(c.config)
	c.WidgetSettings = NewWidgetSettingsClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("db: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("db: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Account:            NewAccountClient(cfg),
		AccountSnapshot:    NewAccountSnapshotClient(cfg),
		AppConfiguration:   NewAppConfigurationClient(cfg),
		ApplicationCommand: NewApplicationCommandClient(cfg),
		AuthNonce:          NewAuthNonceClient(cfg),
		Clan:               NewClanClient(cfg),
		CronTask:           NewCronTaskClient(cfg),
		DiscordInteraction: NewDiscordInteractionClient(cfg),
		GameMap:            NewGameMapClient(cfg),
		GameMode:           NewGameModeClient(cfg),
		LeaderboardScore:   NewLeaderboardScoreClient(cfg),
		Session:            NewSessionClient(cfg),
		User:               NewUserClient(cfg),
		UserConnection:     NewUserConnectionClient(cfg),
		UserContent:        NewUserContentClient(cfg),
		UserSubscription:   NewUserSubscriptionClient(cfg),
		Vehicle:            NewVehicleClient(cfg),
		VehicleAverage:     NewVehicleAverageClient(cfg),
		VehicleSnapshot:    NewVehicleSnapshotClient(cfg),
		WidgetSettings:     NewWidgetSettingsClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Account:            NewAccountClient(cfg),
		AccountSnapshot:    NewAccountSnapshotClient(cfg),
		AppConfiguration:   NewAppConfigurationClient(cfg),
		ApplicationCommand: NewApplicationCommandClient(cfg),
		AuthNonce:          NewAuthNonceClient(cfg),
		Clan:               NewClanClient(cfg),
		CronTask:           NewCronTaskClient(cfg),
		DiscordInteraction: NewDiscordInteractionClient(cfg),
		GameMap:            NewGameMapClient(cfg),
		GameMode:           NewGameModeClient(cfg),
		LeaderboardScore:   NewLeaderboardScoreClient(cfg),
		Session:            NewSessionClient(cfg),
		User:               NewUserClient(cfg),
		UserConnection:     NewUserConnectionClient(cfg),
		UserContent:        NewUserContentClient(cfg),
		UserSubscription:   NewUserSubscriptionClient(cfg),
		Vehicle:            NewVehicleClient(cfg),
		VehicleAverage:     NewVehicleAverageClient(cfg),
		VehicleSnapshot:    NewVehicleSnapshotClient(cfg),
		WidgetSettings:     NewWidgetSettingsClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Account.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Account, c.AccountSnapshot, c.AppConfiguration, c.ApplicationCommand,
		c.AuthNonce, c.Clan, c.CronTask, c.DiscordInteraction, c.GameMap, c.GameMode,
		c.LeaderboardScore, c.Session, c.User, c.UserConnection, c.UserContent,
		c.UserSubscription, c.Vehicle, c.VehicleAverage, c.VehicleSnapshot,
		c.WidgetSettings,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Account, c.AccountSnapshot, c.AppConfiguration, c.ApplicationCommand,
		c.AuthNonce, c.Clan, c.CronTask, c.DiscordInteraction, c.GameMap, c.GameMode,
		c.LeaderboardScore, c.Session, c.User, c.UserConnection, c.UserContent,
		c.UserSubscription, c.Vehicle, c.VehicleAverage, c.VehicleSnapshot,
		c.WidgetSettings,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AccountMutation:
		return c.Account.mutate(ctx, m)
	case *AccountSnapshotMutation:
		return c.AccountSnapshot.mutate(ctx, m)
	case *AppConfigurationMutation:
		return c.AppConfiguration.mutate(ctx, m)
	case *ApplicationCommandMutation:
		return c.ApplicationCommand.mutate(ctx, m)
	case *AuthNonceMutation:
		return c.AuthNonce.mutate(ctx, m)
	case *ClanMutation:
		return c.Clan.mutate(ctx, m)
	case *CronTaskMutation:
		return c.CronTask.mutate(ctx, m)
	case *DiscordInteractionMutation:
		return c.DiscordInteraction.mutate(ctx, m)
	case *GameMapMutation:
		return c.GameMap.mutate(ctx, m)
	case *GameModeMutation:
		return c.GameMode.mutate(ctx, m)
	case *LeaderboardScoreMutation:
		return c.LeaderboardScore.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserConnectionMutation:
		return c.UserConnection.mutate(ctx, m)
	case *UserContentMutation:
		return c.UserContent.mutate(ctx, m)
	case *UserSubscriptionMutation:
		return c.UserSubscription.mutate(ctx, m)
	case *VehicleMutation:
		return c.Vehicle.mutate(ctx, m)
	case *VehicleAverageMutation:
		return c.VehicleAverage.mutate(ctx, m)
	case *VehicleSnapshotMutation:
		return c.VehicleSnapshot.mutate(ctx, m)
	case *WidgetSettingsMutation:
		return c.WidgetSettings.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("db: unknown mutation type %T", m)
	}
}

// AccountClient is a client for the Account schema.
type AccountClient struct {
	config
}

// NewAccountClient returns a client for the Account from the given config.
func NewAccountClient(c config) *AccountClient {
	return &AccountClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `account.Hooks(f(g(h())))`.
func (c *AccountClient) Use(hooks ...Hook) {
	c.hooks.Account = append(c.hooks.Account, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `account.Intercept(f(g(h())))`.
func (c *AccountClient) Intercept(interceptors ...Interceptor) {
	c.inters.Account = append(c.inters.Account, interceptors...)
}

// Create returns a builder for creating a Account entity.
func (c *AccountClient) Create() *AccountCreate {
	mutation := newAccountMutation(c.config, OpCreate)
	return &AccountCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Account entities.
func (c *AccountClient) CreateBulk(builders ...*AccountCreate) *AccountCreateBulk {
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountClient) MapCreateBulk(slice any, setFunc func(*AccountCreate, int)) *AccountCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountCreateBulk{err: fmt.Errorf("calling to AccountClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Account.
func (c *AccountClient) Update() *AccountUpdate {
	mutation := newAccountMutation(c.config, OpUpdate)
	return &AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountClient) UpdateOne(a *Account) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccount(a))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountClient) UpdateOneID(id string) *AccountUpdateOne {
	mutation := newAccountMutation(c.config, OpUpdateOne, withAccountID(id))
	return &AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Account.
func (c *AccountClient) Delete() *AccountDelete {
	mutation := newAccountMutation(c.config, OpDelete)
	return &AccountDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountClient) DeleteOne(a *Account) *AccountDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountClient) DeleteOneID(id string) *AccountDeleteOne {
	builder := c.Delete().Where(account.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountDeleteOne{builder}
}

// Query returns a query builder for Account.
func (c *AccountClient) Query() *AccountQuery {
	return &AccountQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccount},
		inters: c.Interceptors(),
	}
}

// Get returns a Account entity by its id.
func (c *AccountClient) Get(ctx context.Context, id string) (*Account, error) {
	return c.Query().Where(account.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountClient) GetX(ctx context.Context, id string) *Account {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryClan queries the clan edge of a Account.
func (c *AccountClient) QueryClan(a *Account) *ClanQuery {
	query := (&ClanClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(clan.Table, clan.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, account.ClanTable, account.ClanColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVehicleSnapshots queries the vehicle_snapshots edge of a Account.
func (c *AccountClient) QueryVehicleSnapshots(a *Account) *VehicleSnapshotQuery {
	query := (&VehicleSnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(vehiclesnapshot.Table, vehiclesnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.VehicleSnapshotsTable, account.VehicleSnapshotsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAccountSnapshots queries the account_snapshots edge of a Account.
func (c *AccountClient) QueryAccountSnapshots(a *Account) *AccountSnapshotQuery {
	query := (&AccountSnapshotClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(account.Table, account.FieldID, id),
			sqlgraph.To(accountsnapshot.Table, accountsnapshot.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, account.AccountSnapshotsTable, account.AccountSnapshotsColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountClient) Hooks() []Hook {
	return c.hooks.Account
}

// Interceptors returns the client interceptors.
func (c *AccountClient) Interceptors() []Interceptor {
	return c.inters.Account
}

func (c *AccountClient) mutate(ctx context.Context, m *AccountMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Account mutation op: %q", m.Op())
	}
}

// AccountSnapshotClient is a client for the AccountSnapshot schema.
type AccountSnapshotClient struct {
	config
}

// NewAccountSnapshotClient returns a client for the AccountSnapshot from the given config.
func NewAccountSnapshotClient(c config) *AccountSnapshotClient {
	return &AccountSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `accountsnapshot.Hooks(f(g(h())))`.
func (c *AccountSnapshotClient) Use(hooks ...Hook) {
	c.hooks.AccountSnapshot = append(c.hooks.AccountSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `accountsnapshot.Intercept(f(g(h())))`.
func (c *AccountSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.AccountSnapshot = append(c.inters.AccountSnapshot, interceptors...)
}

// Create returns a builder for creating a AccountSnapshot entity.
func (c *AccountSnapshotClient) Create() *AccountSnapshotCreate {
	mutation := newAccountSnapshotMutation(c.config, OpCreate)
	return &AccountSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AccountSnapshot entities.
func (c *AccountSnapshotClient) CreateBulk(builders ...*AccountSnapshotCreate) *AccountSnapshotCreateBulk {
	return &AccountSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AccountSnapshotClient) MapCreateBulk(slice any, setFunc func(*AccountSnapshotCreate, int)) *AccountSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AccountSnapshotCreateBulk{err: fmt.Errorf("calling to AccountSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AccountSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AccountSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AccountSnapshot.
func (c *AccountSnapshotClient) Update() *AccountSnapshotUpdate {
	mutation := newAccountSnapshotMutation(c.config, OpUpdate)
	return &AccountSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AccountSnapshotClient) UpdateOne(as *AccountSnapshot) *AccountSnapshotUpdateOne {
	mutation := newAccountSnapshotMutation(c.config, OpUpdateOne, withAccountSnapshot(as))
	return &AccountSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AccountSnapshotClient) UpdateOneID(id string) *AccountSnapshotUpdateOne {
	mutation := newAccountSnapshotMutation(c.config, OpUpdateOne, withAccountSnapshotID(id))
	return &AccountSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AccountSnapshot.
func (c *AccountSnapshotClient) Delete() *AccountSnapshotDelete {
	mutation := newAccountSnapshotMutation(c.config, OpDelete)
	return &AccountSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AccountSnapshotClient) DeleteOne(as *AccountSnapshot) *AccountSnapshotDeleteOne {
	return c.DeleteOneID(as.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AccountSnapshotClient) DeleteOneID(id string) *AccountSnapshotDeleteOne {
	builder := c.Delete().Where(accountsnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AccountSnapshotDeleteOne{builder}
}

// Query returns a query builder for AccountSnapshot.
func (c *AccountSnapshotClient) Query() *AccountSnapshotQuery {
	return &AccountSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAccountSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a AccountSnapshot entity by its id.
func (c *AccountSnapshotClient) Get(ctx context.Context, id string) (*AccountSnapshot, error) {
	return c.Query().Where(accountsnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AccountSnapshotClient) GetX(ctx context.Context, id string) *AccountSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a AccountSnapshot.
func (c *AccountSnapshotClient) QueryAccount(as *AccountSnapshot) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := as.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(accountsnapshot.Table, accountsnapshot.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, accountsnapshot.AccountTable, accountsnapshot.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(as.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AccountSnapshotClient) Hooks() []Hook {
	return c.hooks.AccountSnapshot
}

// Interceptors returns the client interceptors.
func (c *AccountSnapshotClient) Interceptors() []Interceptor {
	return c.inters.AccountSnapshot
}

func (c *AccountSnapshotClient) mutate(ctx context.Context, m *AccountSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AccountSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AccountSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AccountSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AccountSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown AccountSnapshot mutation op: %q", m.Op())
	}
}

// AppConfigurationClient is a client for the AppConfiguration schema.
type AppConfigurationClient struct {
	config
}

// NewAppConfigurationClient returns a client for the AppConfiguration from the given config.
func NewAppConfigurationClient(c config) *AppConfigurationClient {
	return &AppConfigurationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `appconfiguration.Hooks(f(g(h())))`.
func (c *AppConfigurationClient) Use(hooks ...Hook) {
	c.hooks.AppConfiguration = append(c.hooks.AppConfiguration, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `appconfiguration.Intercept(f(g(h())))`.
func (c *AppConfigurationClient) Intercept(interceptors ...Interceptor) {
	c.inters.AppConfiguration = append(c.inters.AppConfiguration, interceptors...)
}

// Create returns a builder for creating a AppConfiguration entity.
func (c *AppConfigurationClient) Create() *AppConfigurationCreate {
	mutation := newAppConfigurationMutation(c.config, OpCreate)
	return &AppConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AppConfiguration entities.
func (c *AppConfigurationClient) CreateBulk(builders ...*AppConfigurationCreate) *AppConfigurationCreateBulk {
	return &AppConfigurationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppConfigurationClient) MapCreateBulk(slice any, setFunc func(*AppConfigurationCreate, int)) *AppConfigurationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppConfigurationCreateBulk{err: fmt.Errorf("calling to AppConfigurationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppConfigurationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppConfigurationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AppConfiguration.
func (c *AppConfigurationClient) Update() *AppConfigurationUpdate {
	mutation := newAppConfigurationMutation(c.config, OpUpdate)
	return &AppConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppConfigurationClient) UpdateOne(ac *AppConfiguration) *AppConfigurationUpdateOne {
	mutation := newAppConfigurationMutation(c.config, OpUpdateOne, withAppConfiguration(ac))
	return &AppConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppConfigurationClient) UpdateOneID(id string) *AppConfigurationUpdateOne {
	mutation := newAppConfigurationMutation(c.config, OpUpdateOne, withAppConfigurationID(id))
	return &AppConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AppConfiguration.
func (c *AppConfigurationClient) Delete() *AppConfigurationDelete {
	mutation := newAppConfigurationMutation(c.config, OpDelete)
	return &AppConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppConfigurationClient) DeleteOne(ac *AppConfiguration) *AppConfigurationDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppConfigurationClient) DeleteOneID(id string) *AppConfigurationDeleteOne {
	builder := c.Delete().Where(appconfiguration.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppConfigurationDeleteOne{builder}
}

// Query returns a query builder for AppConfiguration.
func (c *AppConfigurationClient) Query() *AppConfigurationQuery {
	return &AppConfigurationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAppConfiguration},
		inters: c.Interceptors(),
	}
}

// Get returns a AppConfiguration entity by its id.
func (c *AppConfigurationClient) Get(ctx context.Context, id string) (*AppConfiguration, error) {
	return c.Query().Where(appconfiguration.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppConfigurationClient) GetX(ctx context.Context, id string) *AppConfiguration {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AppConfigurationClient) Hooks() []Hook {
	return c.hooks.AppConfiguration
}

// Interceptors returns the client interceptors.
func (c *AppConfigurationClient) Interceptors() []Interceptor {
	return c.inters.AppConfiguration
}

func (c *AppConfigurationClient) mutate(ctx context.Context, m *AppConfigurationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppConfigurationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppConfigurationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppConfigurationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppConfigurationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown AppConfiguration mutation op: %q", m.Op())
	}
}

// ApplicationCommandClient is a client for the ApplicationCommand schema.
type ApplicationCommandClient struct {
	config
}

// NewApplicationCommandClient returns a client for the ApplicationCommand from the given config.
func NewApplicationCommandClient(c config) *ApplicationCommandClient {
	return &ApplicationCommandClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `applicationcommand.Hooks(f(g(h())))`.
func (c *ApplicationCommandClient) Use(hooks ...Hook) {
	c.hooks.ApplicationCommand = append(c.hooks.ApplicationCommand, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `applicationcommand.Intercept(f(g(h())))`.
func (c *ApplicationCommandClient) Intercept(interceptors ...Interceptor) {
	c.inters.ApplicationCommand = append(c.inters.ApplicationCommand, interceptors...)
}

// Create returns a builder for creating a ApplicationCommand entity.
func (c *ApplicationCommandClient) Create() *ApplicationCommandCreate {
	mutation := newApplicationCommandMutation(c.config, OpCreate)
	return &ApplicationCommandCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ApplicationCommand entities.
func (c *ApplicationCommandClient) CreateBulk(builders ...*ApplicationCommandCreate) *ApplicationCommandCreateBulk {
	return &ApplicationCommandCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ApplicationCommandClient) MapCreateBulk(slice any, setFunc func(*ApplicationCommandCreate, int)) *ApplicationCommandCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ApplicationCommandCreateBulk{err: fmt.Errorf("calling to ApplicationCommandClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ApplicationCommandCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ApplicationCommandCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ApplicationCommand.
func (c *ApplicationCommandClient) Update() *ApplicationCommandUpdate {
	mutation := newApplicationCommandMutation(c.config, OpUpdate)
	return &ApplicationCommandUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ApplicationCommandClient) UpdateOne(ac *ApplicationCommand) *ApplicationCommandUpdateOne {
	mutation := newApplicationCommandMutation(c.config, OpUpdateOne, withApplicationCommand(ac))
	return &ApplicationCommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ApplicationCommandClient) UpdateOneID(id string) *ApplicationCommandUpdateOne {
	mutation := newApplicationCommandMutation(c.config, OpUpdateOne, withApplicationCommandID(id))
	return &ApplicationCommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ApplicationCommand.
func (c *ApplicationCommandClient) Delete() *ApplicationCommandDelete {
	mutation := newApplicationCommandMutation(c.config, OpDelete)
	return &ApplicationCommandDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ApplicationCommandClient) DeleteOne(ac *ApplicationCommand) *ApplicationCommandDeleteOne {
	return c.DeleteOneID(ac.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ApplicationCommandClient) DeleteOneID(id string) *ApplicationCommandDeleteOne {
	builder := c.Delete().Where(applicationcommand.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ApplicationCommandDeleteOne{builder}
}

// Query returns a query builder for ApplicationCommand.
func (c *ApplicationCommandClient) Query() *ApplicationCommandQuery {
	return &ApplicationCommandQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApplicationCommand},
		inters: c.Interceptors(),
	}
}

// Get returns a ApplicationCommand entity by its id.
func (c *ApplicationCommandClient) Get(ctx context.Context, id string) (*ApplicationCommand, error) {
	return c.Query().Where(applicationcommand.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ApplicationCommandClient) GetX(ctx context.Context, id string) *ApplicationCommand {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ApplicationCommandClient) Hooks() []Hook {
	return c.hooks.ApplicationCommand
}

// Interceptors returns the client interceptors.
func (c *ApplicationCommandClient) Interceptors() []Interceptor {
	return c.inters.ApplicationCommand
}

func (c *ApplicationCommandClient) mutate(ctx context.Context, m *ApplicationCommandMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ApplicationCommandCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ApplicationCommandUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ApplicationCommandUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ApplicationCommandDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown ApplicationCommand mutation op: %q", m.Op())
	}
}

// AuthNonceClient is a client for the AuthNonce schema.
type AuthNonceClient struct {
	config
}

// NewAuthNonceClient returns a client for the AuthNonce from the given config.
func NewAuthNonceClient(c config) *AuthNonceClient {
	return &AuthNonceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authnonce.Hooks(f(g(h())))`.
func (c *AuthNonceClient) Use(hooks ...Hook) {
	c.hooks.AuthNonce = append(c.hooks.AuthNonce, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authnonce.Intercept(f(g(h())))`.
func (c *AuthNonceClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthNonce = append(c.inters.AuthNonce, interceptors...)
}

// Create returns a builder for creating a AuthNonce entity.
func (c *AuthNonceClient) Create() *AuthNonceCreate {
	mutation := newAuthNonceMutation(c.config, OpCreate)
	return &AuthNonceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthNonce entities.
func (c *AuthNonceClient) CreateBulk(builders ...*AuthNonceCreate) *AuthNonceCreateBulk {
	return &AuthNonceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthNonceClient) MapCreateBulk(slice any, setFunc func(*AuthNonceCreate, int)) *AuthNonceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthNonceCreateBulk{err: fmt.Errorf("calling to AuthNonceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthNonceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthNonceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthNonce.
func (c *AuthNonceClient) Update() *AuthNonceUpdate {
	mutation := newAuthNonceMutation(c.config, OpUpdate)
	return &AuthNonceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthNonceClient) UpdateOne(an *AuthNonce) *AuthNonceUpdateOne {
	mutation := newAuthNonceMutation(c.config, OpUpdateOne, withAuthNonce(an))
	return &AuthNonceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthNonceClient) UpdateOneID(id string) *AuthNonceUpdateOne {
	mutation := newAuthNonceMutation(c.config, OpUpdateOne, withAuthNonceID(id))
	return &AuthNonceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthNonce.
func (c *AuthNonceClient) Delete() *AuthNonceDelete {
	mutation := newAuthNonceMutation(c.config, OpDelete)
	return &AuthNonceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthNonceClient) DeleteOne(an *AuthNonce) *AuthNonceDeleteOne {
	return c.DeleteOneID(an.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthNonceClient) DeleteOneID(id string) *AuthNonceDeleteOne {
	builder := c.Delete().Where(authnonce.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthNonceDeleteOne{builder}
}

// Query returns a query builder for AuthNonce.
func (c *AuthNonceClient) Query() *AuthNonceQuery {
	return &AuthNonceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthNonce},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthNonce entity by its id.
func (c *AuthNonceClient) Get(ctx context.Context, id string) (*AuthNonce, error) {
	return c.Query().Where(authnonce.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthNonceClient) GetX(ctx context.Context, id string) *AuthNonce {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthNonceClient) Hooks() []Hook {
	return c.hooks.AuthNonce
}

// Interceptors returns the client interceptors.
func (c *AuthNonceClient) Interceptors() []Interceptor {
	return c.inters.AuthNonce
}

func (c *AuthNonceClient) mutate(ctx context.Context, m *AuthNonceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthNonceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthNonceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthNonceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthNonceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown AuthNonce mutation op: %q", m.Op())
	}
}

// ClanClient is a client for the Clan schema.
type ClanClient struct {
	config
}

// NewClanClient returns a client for the Clan from the given config.
func NewClanClient(c config) *ClanClient {
	return &ClanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `clan.Hooks(f(g(h())))`.
func (c *ClanClient) Use(hooks ...Hook) {
	c.hooks.Clan = append(c.hooks.Clan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `clan.Intercept(f(g(h())))`.
func (c *ClanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Clan = append(c.inters.Clan, interceptors...)
}

// Create returns a builder for creating a Clan entity.
func (c *ClanClient) Create() *ClanCreate {
	mutation := newClanMutation(c.config, OpCreate)
	return &ClanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Clan entities.
func (c *ClanClient) CreateBulk(builders ...*ClanCreate) *ClanCreateBulk {
	return &ClanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ClanClient) MapCreateBulk(slice any, setFunc func(*ClanCreate, int)) *ClanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ClanCreateBulk{err: fmt.Errorf("calling to ClanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ClanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ClanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Clan.
func (c *ClanClient) Update() *ClanUpdate {
	mutation := newClanMutation(c.config, OpUpdate)
	return &ClanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ClanClient) UpdateOne(cl *Clan) *ClanUpdateOne {
	mutation := newClanMutation(c.config, OpUpdateOne, withClan(cl))
	return &ClanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ClanClient) UpdateOneID(id string) *ClanUpdateOne {
	mutation := newClanMutation(c.config, OpUpdateOne, withClanID(id))
	return &ClanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Clan.
func (c *ClanClient) Delete() *ClanDelete {
	mutation := newClanMutation(c.config, OpDelete)
	return &ClanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ClanClient) DeleteOne(cl *Clan) *ClanDeleteOne {
	return c.DeleteOneID(cl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ClanClient) DeleteOneID(id string) *ClanDeleteOne {
	builder := c.Delete().Where(clan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ClanDeleteOne{builder}
}

// Query returns a query builder for Clan.
func (c *ClanClient) Query() *ClanQuery {
	return &ClanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeClan},
		inters: c.Interceptors(),
	}
}

// Get returns a Clan entity by its id.
func (c *ClanClient) Get(ctx context.Context, id string) (*Clan, error) {
	return c.Query().Where(clan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ClanClient) GetX(ctx context.Context, id string) *Clan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccounts queries the accounts edge of a Clan.
func (c *ClanClient) QueryAccounts(cl *Clan) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cl.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(clan.Table, clan.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, clan.AccountsTable, clan.AccountsColumn),
		)
		fromV = sqlgraph.Neighbors(cl.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ClanClient) Hooks() []Hook {
	return c.hooks.Clan
}

// Interceptors returns the client interceptors.
func (c *ClanClient) Interceptors() []Interceptor {
	return c.inters.Clan
}

func (c *ClanClient) mutate(ctx context.Context, m *ClanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ClanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ClanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ClanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ClanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Clan mutation op: %q", m.Op())
	}
}

// CronTaskClient is a client for the CronTask schema.
type CronTaskClient struct {
	config
}

// NewCronTaskClient returns a client for the CronTask from the given config.
func NewCronTaskClient(c config) *CronTaskClient {
	return &CronTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `crontask.Hooks(f(g(h())))`.
func (c *CronTaskClient) Use(hooks ...Hook) {
	c.hooks.CronTask = append(c.hooks.CronTask, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `crontask.Intercept(f(g(h())))`.
func (c *CronTaskClient) Intercept(interceptors ...Interceptor) {
	c.inters.CronTask = append(c.inters.CronTask, interceptors...)
}

// Create returns a builder for creating a CronTask entity.
func (c *CronTaskClient) Create() *CronTaskCreate {
	mutation := newCronTaskMutation(c.config, OpCreate)
	return &CronTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CronTask entities.
func (c *CronTaskClient) CreateBulk(builders ...*CronTaskCreate) *CronTaskCreateBulk {
	return &CronTaskCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *CronTaskClient) MapCreateBulk(slice any, setFunc func(*CronTaskCreate, int)) *CronTaskCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &CronTaskCreateBulk{err: fmt.Errorf("calling to CronTaskClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*CronTaskCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &CronTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CronTask.
func (c *CronTaskClient) Update() *CronTaskUpdate {
	mutation := newCronTaskMutation(c.config, OpUpdate)
	return &CronTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CronTaskClient) UpdateOne(ct *CronTask) *CronTaskUpdateOne {
	mutation := newCronTaskMutation(c.config, OpUpdateOne, withCronTask(ct))
	return &CronTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CronTaskClient) UpdateOneID(id string) *CronTaskUpdateOne {
	mutation := newCronTaskMutation(c.config, OpUpdateOne, withCronTaskID(id))
	return &CronTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CronTask.
func (c *CronTaskClient) Delete() *CronTaskDelete {
	mutation := newCronTaskMutation(c.config, OpDelete)
	return &CronTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CronTaskClient) DeleteOne(ct *CronTask) *CronTaskDeleteOne {
	return c.DeleteOneID(ct.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CronTaskClient) DeleteOneID(id string) *CronTaskDeleteOne {
	builder := c.Delete().Where(crontask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CronTaskDeleteOne{builder}
}

// Query returns a query builder for CronTask.
func (c *CronTaskClient) Query() *CronTaskQuery {
	return &CronTaskQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCronTask},
		inters: c.Interceptors(),
	}
}

// Get returns a CronTask entity by its id.
func (c *CronTaskClient) Get(ctx context.Context, id string) (*CronTask, error) {
	return c.Query().Where(crontask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CronTaskClient) GetX(ctx context.Context, id string) *CronTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *CronTaskClient) Hooks() []Hook {
	return c.hooks.CronTask
}

// Interceptors returns the client interceptors.
func (c *CronTaskClient) Interceptors() []Interceptor {
	return c.inters.CronTask
}

func (c *CronTaskClient) mutate(ctx context.Context, m *CronTaskMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CronTaskCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CronTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CronTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CronTaskDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown CronTask mutation op: %q", m.Op())
	}
}

// DiscordInteractionClient is a client for the DiscordInteraction schema.
type DiscordInteractionClient struct {
	config
}

// NewDiscordInteractionClient returns a client for the DiscordInteraction from the given config.
func NewDiscordInteractionClient(c config) *DiscordInteractionClient {
	return &DiscordInteractionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `discordinteraction.Hooks(f(g(h())))`.
func (c *DiscordInteractionClient) Use(hooks ...Hook) {
	c.hooks.DiscordInteraction = append(c.hooks.DiscordInteraction, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `discordinteraction.Intercept(f(g(h())))`.
func (c *DiscordInteractionClient) Intercept(interceptors ...Interceptor) {
	c.inters.DiscordInteraction = append(c.inters.DiscordInteraction, interceptors...)
}

// Create returns a builder for creating a DiscordInteraction entity.
func (c *DiscordInteractionClient) Create() *DiscordInteractionCreate {
	mutation := newDiscordInteractionMutation(c.config, OpCreate)
	return &DiscordInteractionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of DiscordInteraction entities.
func (c *DiscordInteractionClient) CreateBulk(builders ...*DiscordInteractionCreate) *DiscordInteractionCreateBulk {
	return &DiscordInteractionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *DiscordInteractionClient) MapCreateBulk(slice any, setFunc func(*DiscordInteractionCreate, int)) *DiscordInteractionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &DiscordInteractionCreateBulk{err: fmt.Errorf("calling to DiscordInteractionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*DiscordInteractionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &DiscordInteractionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for DiscordInteraction.
func (c *DiscordInteractionClient) Update() *DiscordInteractionUpdate {
	mutation := newDiscordInteractionMutation(c.config, OpUpdate)
	return &DiscordInteractionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *DiscordInteractionClient) UpdateOne(di *DiscordInteraction) *DiscordInteractionUpdateOne {
	mutation := newDiscordInteractionMutation(c.config, OpUpdateOne, withDiscordInteraction(di))
	return &DiscordInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *DiscordInteractionClient) UpdateOneID(id string) *DiscordInteractionUpdateOne {
	mutation := newDiscordInteractionMutation(c.config, OpUpdateOne, withDiscordInteractionID(id))
	return &DiscordInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for DiscordInteraction.
func (c *DiscordInteractionClient) Delete() *DiscordInteractionDelete {
	mutation := newDiscordInteractionMutation(c.config, OpDelete)
	return &DiscordInteractionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *DiscordInteractionClient) DeleteOne(di *DiscordInteraction) *DiscordInteractionDeleteOne {
	return c.DeleteOneID(di.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *DiscordInteractionClient) DeleteOneID(id string) *DiscordInteractionDeleteOne {
	builder := c.Delete().Where(discordinteraction.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &DiscordInteractionDeleteOne{builder}
}

// Query returns a query builder for DiscordInteraction.
func (c *DiscordInteractionClient) Query() *DiscordInteractionQuery {
	return &DiscordInteractionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeDiscordInteraction},
		inters: c.Interceptors(),
	}
}

// Get returns a DiscordInteraction entity by its id.
func (c *DiscordInteractionClient) Get(ctx context.Context, id string) (*DiscordInteraction, error) {
	return c.Query().Where(discordinteraction.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *DiscordInteractionClient) GetX(ctx context.Context, id string) *DiscordInteraction {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a DiscordInteraction.
func (c *DiscordInteractionClient) QueryUser(di *DiscordInteraction) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := di.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(discordinteraction.Table, discordinteraction.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, discordinteraction.UserTable, discordinteraction.UserColumn),
		)
		fromV = sqlgraph.Neighbors(di.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *DiscordInteractionClient) Hooks() []Hook {
	return c.hooks.DiscordInteraction
}

// Interceptors returns the client interceptors.
func (c *DiscordInteractionClient) Interceptors() []Interceptor {
	return c.inters.DiscordInteraction
}

func (c *DiscordInteractionClient) mutate(ctx context.Context, m *DiscordInteractionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&DiscordInteractionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&DiscordInteractionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&DiscordInteractionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&DiscordInteractionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown DiscordInteraction mutation op: %q", m.Op())
	}
}

// GameMapClient is a client for the GameMap schema.
type GameMapClient struct {
	config
}

// NewGameMapClient returns a client for the GameMap from the given config.
func NewGameMapClient(c config) *GameMapClient {
	return &GameMapClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gamemap.Hooks(f(g(h())))`.
func (c *GameMapClient) Use(hooks ...Hook) {
	c.hooks.GameMap = append(c.hooks.GameMap, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gamemap.Intercept(f(g(h())))`.
func (c *GameMapClient) Intercept(interceptors ...Interceptor) {
	c.inters.GameMap = append(c.inters.GameMap, interceptors...)
}

// Create returns a builder for creating a GameMap entity.
func (c *GameMapClient) Create() *GameMapCreate {
	mutation := newGameMapMutation(c.config, OpCreate)
	return &GameMapCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GameMap entities.
func (c *GameMapClient) CreateBulk(builders ...*GameMapCreate) *GameMapCreateBulk {
	return &GameMapCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameMapClient) MapCreateBulk(slice any, setFunc func(*GameMapCreate, int)) *GameMapCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameMapCreateBulk{err: fmt.Errorf("calling to GameMapClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameMapCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameMapCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GameMap.
func (c *GameMapClient) Update() *GameMapUpdate {
	mutation := newGameMapMutation(c.config, OpUpdate)
	return &GameMapUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameMapClient) UpdateOne(gm *GameMap) *GameMapUpdateOne {
	mutation := newGameMapMutation(c.config, OpUpdateOne, withGameMap(gm))
	return &GameMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameMapClient) UpdateOneID(id string) *GameMapUpdateOne {
	mutation := newGameMapMutation(c.config, OpUpdateOne, withGameMapID(id))
	return &GameMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GameMap.
func (c *GameMapClient) Delete() *GameMapDelete {
	mutation := newGameMapMutation(c.config, OpDelete)
	return &GameMapDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameMapClient) DeleteOne(gm *GameMap) *GameMapDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameMapClient) DeleteOneID(id string) *GameMapDeleteOne {
	builder := c.Delete().Where(gamemap.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameMapDeleteOne{builder}
}

// Query returns a query builder for GameMap.
func (c *GameMapClient) Query() *GameMapQuery {
	return &GameMapQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGameMap},
		inters: c.Interceptors(),
	}
}

// Get returns a GameMap entity by its id.
func (c *GameMapClient) Get(ctx context.Context, id string) (*GameMap, error) {
	return c.Query().Where(gamemap.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameMapClient) GetX(ctx context.Context, id string) *GameMap {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GameMapClient) Hooks() []Hook {
	return c.hooks.GameMap
}

// Interceptors returns the client interceptors.
func (c *GameMapClient) Interceptors() []Interceptor {
	return c.inters.GameMap
}

func (c *GameMapClient) mutate(ctx context.Context, m *GameMapMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameMapCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameMapUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameMapUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameMapDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown GameMap mutation op: %q", m.Op())
	}
}

// GameModeClient is a client for the GameMode schema.
type GameModeClient struct {
	config
}

// NewGameModeClient returns a client for the GameMode from the given config.
func NewGameModeClient(c config) *GameModeClient {
	return &GameModeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `gamemode.Hooks(f(g(h())))`.
func (c *GameModeClient) Use(hooks ...Hook) {
	c.hooks.GameMode = append(c.hooks.GameMode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `gamemode.Intercept(f(g(h())))`.
func (c *GameModeClient) Intercept(interceptors ...Interceptor) {
	c.inters.GameMode = append(c.inters.GameMode, interceptors...)
}

// Create returns a builder for creating a GameMode entity.
func (c *GameModeClient) Create() *GameModeCreate {
	mutation := newGameModeMutation(c.config, OpCreate)
	return &GameModeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of GameMode entities.
func (c *GameModeClient) CreateBulk(builders ...*GameModeCreate) *GameModeCreateBulk {
	return &GameModeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *GameModeClient) MapCreateBulk(slice any, setFunc func(*GameModeCreate, int)) *GameModeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &GameModeCreateBulk{err: fmt.Errorf("calling to GameModeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*GameModeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &GameModeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for GameMode.
func (c *GameModeClient) Update() *GameModeUpdate {
	mutation := newGameModeMutation(c.config, OpUpdate)
	return &GameModeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *GameModeClient) UpdateOne(gm *GameMode) *GameModeUpdateOne {
	mutation := newGameModeMutation(c.config, OpUpdateOne, withGameMode(gm))
	return &GameModeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *GameModeClient) UpdateOneID(id string) *GameModeUpdateOne {
	mutation := newGameModeMutation(c.config, OpUpdateOne, withGameModeID(id))
	return &GameModeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for GameMode.
func (c *GameModeClient) Delete() *GameModeDelete {
	mutation := newGameModeMutation(c.config, OpDelete)
	return &GameModeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *GameModeClient) DeleteOne(gm *GameMode) *GameModeDeleteOne {
	return c.DeleteOneID(gm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *GameModeClient) DeleteOneID(id string) *GameModeDeleteOne {
	builder := c.Delete().Where(gamemode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &GameModeDeleteOne{builder}
}

// Query returns a query builder for GameMode.
func (c *GameModeClient) Query() *GameModeQuery {
	return &GameModeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeGameMode},
		inters: c.Interceptors(),
	}
}

// Get returns a GameMode entity by its id.
func (c *GameModeClient) Get(ctx context.Context, id string) (*GameMode, error) {
	return c.Query().Where(gamemode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *GameModeClient) GetX(ctx context.Context, id string) *GameMode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *GameModeClient) Hooks() []Hook {
	return c.hooks.GameMode
}

// Interceptors returns the client interceptors.
func (c *GameModeClient) Interceptors() []Interceptor {
	return c.inters.GameMode
}

func (c *GameModeClient) mutate(ctx context.Context, m *GameModeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&GameModeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&GameModeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&GameModeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&GameModeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown GameMode mutation op: %q", m.Op())
	}
}

// LeaderboardScoreClient is a client for the LeaderboardScore schema.
type LeaderboardScoreClient struct {
	config
}

// NewLeaderboardScoreClient returns a client for the LeaderboardScore from the given config.
func NewLeaderboardScoreClient(c config) *LeaderboardScoreClient {
	return &LeaderboardScoreClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `leaderboardscore.Hooks(f(g(h())))`.
func (c *LeaderboardScoreClient) Use(hooks ...Hook) {
	c.hooks.LeaderboardScore = append(c.hooks.LeaderboardScore, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `leaderboardscore.Intercept(f(g(h())))`.
func (c *LeaderboardScoreClient) Intercept(interceptors ...Interceptor) {
	c.inters.LeaderboardScore = append(c.inters.LeaderboardScore, interceptors...)
}

// Create returns a builder for creating a LeaderboardScore entity.
func (c *LeaderboardScoreClient) Create() *LeaderboardScoreCreate {
	mutation := newLeaderboardScoreMutation(c.config, OpCreate)
	return &LeaderboardScoreCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LeaderboardScore entities.
func (c *LeaderboardScoreClient) CreateBulk(builders ...*LeaderboardScoreCreate) *LeaderboardScoreCreateBulk {
	return &LeaderboardScoreCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LeaderboardScoreClient) MapCreateBulk(slice any, setFunc func(*LeaderboardScoreCreate, int)) *LeaderboardScoreCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LeaderboardScoreCreateBulk{err: fmt.Errorf("calling to LeaderboardScoreClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LeaderboardScoreCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LeaderboardScoreCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LeaderboardScore.
func (c *LeaderboardScoreClient) Update() *LeaderboardScoreUpdate {
	mutation := newLeaderboardScoreMutation(c.config, OpUpdate)
	return &LeaderboardScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LeaderboardScoreClient) UpdateOne(ls *LeaderboardScore) *LeaderboardScoreUpdateOne {
	mutation := newLeaderboardScoreMutation(c.config, OpUpdateOne, withLeaderboardScore(ls))
	return &LeaderboardScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LeaderboardScoreClient) UpdateOneID(id string) *LeaderboardScoreUpdateOne {
	mutation := newLeaderboardScoreMutation(c.config, OpUpdateOne, withLeaderboardScoreID(id))
	return &LeaderboardScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LeaderboardScore.
func (c *LeaderboardScoreClient) Delete() *LeaderboardScoreDelete {
	mutation := newLeaderboardScoreMutation(c.config, OpDelete)
	return &LeaderboardScoreDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LeaderboardScoreClient) DeleteOne(ls *LeaderboardScore) *LeaderboardScoreDeleteOne {
	return c.DeleteOneID(ls.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LeaderboardScoreClient) DeleteOneID(id string) *LeaderboardScoreDeleteOne {
	builder := c.Delete().Where(leaderboardscore.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LeaderboardScoreDeleteOne{builder}
}

// Query returns a query builder for LeaderboardScore.
func (c *LeaderboardScoreClient) Query() *LeaderboardScoreQuery {
	return &LeaderboardScoreQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLeaderboardScore},
		inters: c.Interceptors(),
	}
}

// Get returns a LeaderboardScore entity by its id.
func (c *LeaderboardScoreClient) Get(ctx context.Context, id string) (*LeaderboardScore, error) {
	return c.Query().Where(leaderboardscore.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LeaderboardScoreClient) GetX(ctx context.Context, id string) *LeaderboardScore {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LeaderboardScoreClient) Hooks() []Hook {
	return c.hooks.LeaderboardScore
}

// Interceptors returns the client interceptors.
func (c *LeaderboardScoreClient) Interceptors() []Interceptor {
	return c.inters.LeaderboardScore
}

func (c *LeaderboardScoreClient) mutate(ctx context.Context, m *LeaderboardScoreMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LeaderboardScoreCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LeaderboardScoreUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LeaderboardScoreUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LeaderboardScoreDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown LeaderboardScore mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(s *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.UserTable, session.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Session mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDiscordInteractions queries the discord_interactions edge of a User.
func (c *UserClient) QueryDiscordInteractions(u *User) *DiscordInteractionQuery {
	query := (&DiscordInteractionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(discordinteraction.Table, discordinteraction.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.DiscordInteractionsTable, user.DiscordInteractionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySubscriptions queries the subscriptions edge of a User.
func (c *UserClient) QuerySubscriptions(u *User) *UserSubscriptionQuery {
	query := (&UserSubscriptionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usersubscription.Table, usersubscription.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SubscriptionsTable, user.SubscriptionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConnections queries the connections edge of a User.
func (c *UserClient) QueryConnections(u *User) *UserConnectionQuery {
	query := (&UserConnectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(userconnection.Table, userconnection.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConnectionsTable, user.ConnectionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWidgets queries the widgets edge of a User.
func (c *UserClient) QueryWidgets(u *User) *WidgetSettingsQuery {
	query := (&WidgetSettingsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(widgetsettings.Table, widgetsettings.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.WidgetsTable, user.WidgetsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryContent queries the content edge of a User.
func (c *UserClient) QueryContent(u *User) *UserContentQuery {
	query := (&UserContentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(usercontent.Table, usercontent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ContentTable, user.ContentColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(u *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown User mutation op: %q", m.Op())
	}
}

// UserConnectionClient is a client for the UserConnection schema.
type UserConnectionClient struct {
	config
}

// NewUserConnectionClient returns a client for the UserConnection from the given config.
func NewUserConnectionClient(c config) *UserConnectionClient {
	return &UserConnectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `userconnection.Hooks(f(g(h())))`.
func (c *UserConnectionClient) Use(hooks ...Hook) {
	c.hooks.UserConnection = append(c.hooks.UserConnection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `userconnection.Intercept(f(g(h())))`.
func (c *UserConnectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserConnection = append(c.inters.UserConnection, interceptors...)
}

// Create returns a builder for creating a UserConnection entity.
func (c *UserConnectionClient) Create() *UserConnectionCreate {
	mutation := newUserConnectionMutation(c.config, OpCreate)
	return &UserConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserConnection entities.
func (c *UserConnectionClient) CreateBulk(builders ...*UserConnectionCreate) *UserConnectionCreateBulk {
	return &UserConnectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserConnectionClient) MapCreateBulk(slice any, setFunc func(*UserConnectionCreate, int)) *UserConnectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserConnectionCreateBulk{err: fmt.Errorf("calling to UserConnectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserConnectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserConnectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserConnection.
func (c *UserConnectionClient) Update() *UserConnectionUpdate {
	mutation := newUserConnectionMutation(c.config, OpUpdate)
	return &UserConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserConnectionClient) UpdateOne(uc *UserConnection) *UserConnectionUpdateOne {
	mutation := newUserConnectionMutation(c.config, OpUpdateOne, withUserConnection(uc))
	return &UserConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserConnectionClient) UpdateOneID(id string) *UserConnectionUpdateOne {
	mutation := newUserConnectionMutation(c.config, OpUpdateOne, withUserConnectionID(id))
	return &UserConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserConnection.
func (c *UserConnectionClient) Delete() *UserConnectionDelete {
	mutation := newUserConnectionMutation(c.config, OpDelete)
	return &UserConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserConnectionClient) DeleteOne(uc *UserConnection) *UserConnectionDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserConnectionClient) DeleteOneID(id string) *UserConnectionDeleteOne {
	builder := c.Delete().Where(userconnection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserConnectionDeleteOne{builder}
}

// Query returns a query builder for UserConnection.
func (c *UserConnectionClient) Query() *UserConnectionQuery {
	return &UserConnectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserConnection},
		inters: c.Interceptors(),
	}
}

// Get returns a UserConnection entity by its id.
func (c *UserConnectionClient) Get(ctx context.Context, id string) (*UserConnection, error) {
	return c.Query().Where(userconnection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserConnectionClient) GetX(ctx context.Context, id string) *UserConnection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserConnection.
func (c *UserConnectionClient) QueryUser(uc *UserConnection) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(userconnection.Table, userconnection.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, userconnection.UserTable, userconnection.UserColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserConnectionClient) Hooks() []Hook {
	return c.hooks.UserConnection
}

// Interceptors returns the client interceptors.
func (c *UserConnectionClient) Interceptors() []Interceptor {
	return c.inters.UserConnection
}

func (c *UserConnectionClient) mutate(ctx context.Context, m *UserConnectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown UserConnection mutation op: %q", m.Op())
	}
}

// UserContentClient is a client for the UserContent schema.
type UserContentClient struct {
	config
}

// NewUserContentClient returns a client for the UserContent from the given config.
func NewUserContentClient(c config) *UserContentClient {
	return &UserContentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usercontent.Hooks(f(g(h())))`.
func (c *UserContentClient) Use(hooks ...Hook) {
	c.hooks.UserContent = append(c.hooks.UserContent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usercontent.Intercept(f(g(h())))`.
func (c *UserContentClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserContent = append(c.inters.UserContent, interceptors...)
}

// Create returns a builder for creating a UserContent entity.
func (c *UserContentClient) Create() *UserContentCreate {
	mutation := newUserContentMutation(c.config, OpCreate)
	return &UserContentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserContent entities.
func (c *UserContentClient) CreateBulk(builders ...*UserContentCreate) *UserContentCreateBulk {
	return &UserContentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserContentClient) MapCreateBulk(slice any, setFunc func(*UserContentCreate, int)) *UserContentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserContentCreateBulk{err: fmt.Errorf("calling to UserContentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserContentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserContentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserContent.
func (c *UserContentClient) Update() *UserContentUpdate {
	mutation := newUserContentMutation(c.config, OpUpdate)
	return &UserContentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserContentClient) UpdateOne(uc *UserContent) *UserContentUpdateOne {
	mutation := newUserContentMutation(c.config, OpUpdateOne, withUserContent(uc))
	return &UserContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserContentClient) UpdateOneID(id string) *UserContentUpdateOne {
	mutation := newUserContentMutation(c.config, OpUpdateOne, withUserContentID(id))
	return &UserContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserContent.
func (c *UserContentClient) Delete() *UserContentDelete {
	mutation := newUserContentMutation(c.config, OpDelete)
	return &UserContentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserContentClient) DeleteOne(uc *UserContent) *UserContentDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserContentClient) DeleteOneID(id string) *UserContentDeleteOne {
	builder := c.Delete().Where(usercontent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserContentDeleteOne{builder}
}

// Query returns a query builder for UserContent.
func (c *UserContentClient) Query() *UserContentQuery {
	return &UserContentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserContent},
		inters: c.Interceptors(),
	}
}

// Get returns a UserContent entity by its id.
func (c *UserContentClient) Get(ctx context.Context, id string) (*UserContent, error) {
	return c.Query().Where(usercontent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserContentClient) GetX(ctx context.Context, id string) *UserContent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserContent.
func (c *UserContentClient) QueryUser(uc *UserContent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := uc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usercontent.Table, usercontent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usercontent.UserTable, usercontent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(uc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserContentClient) Hooks() []Hook {
	return c.hooks.UserContent
}

// Interceptors returns the client interceptors.
func (c *UserContentClient) Interceptors() []Interceptor {
	return c.inters.UserContent
}

func (c *UserContentClient) mutate(ctx context.Context, m *UserContentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserContentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserContentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserContentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserContentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown UserContent mutation op: %q", m.Op())
	}
}

// UserSubscriptionClient is a client for the UserSubscription schema.
type UserSubscriptionClient struct {
	config
}

// NewUserSubscriptionClient returns a client for the UserSubscription from the given config.
func NewUserSubscriptionClient(c config) *UserSubscriptionClient {
	return &UserSubscriptionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `usersubscription.Hooks(f(g(h())))`.
func (c *UserSubscriptionClient) Use(hooks ...Hook) {
	c.hooks.UserSubscription = append(c.hooks.UserSubscription, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `usersubscription.Intercept(f(g(h())))`.
func (c *UserSubscriptionClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserSubscription = append(c.inters.UserSubscription, interceptors...)
}

// Create returns a builder for creating a UserSubscription entity.
func (c *UserSubscriptionClient) Create() *UserSubscriptionCreate {
	mutation := newUserSubscriptionMutation(c.config, OpCreate)
	return &UserSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserSubscription entities.
func (c *UserSubscriptionClient) CreateBulk(builders ...*UserSubscriptionCreate) *UserSubscriptionCreateBulk {
	return &UserSubscriptionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserSubscriptionClient) MapCreateBulk(slice any, setFunc func(*UserSubscriptionCreate, int)) *UserSubscriptionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserSubscriptionCreateBulk{err: fmt.Errorf("calling to UserSubscriptionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserSubscriptionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserSubscriptionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserSubscription.
func (c *UserSubscriptionClient) Update() *UserSubscriptionUpdate {
	mutation := newUserSubscriptionMutation(c.config, OpUpdate)
	return &UserSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserSubscriptionClient) UpdateOne(us *UserSubscription) *UserSubscriptionUpdateOne {
	mutation := newUserSubscriptionMutation(c.config, OpUpdateOne, withUserSubscription(us))
	return &UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserSubscriptionClient) UpdateOneID(id string) *UserSubscriptionUpdateOne {
	mutation := newUserSubscriptionMutation(c.config, OpUpdateOne, withUserSubscriptionID(id))
	return &UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserSubscription.
func (c *UserSubscriptionClient) Delete() *UserSubscriptionDelete {
	mutation := newUserSubscriptionMutation(c.config, OpDelete)
	return &UserSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserSubscriptionClient) DeleteOne(us *UserSubscription) *UserSubscriptionDeleteOne {
	return c.DeleteOneID(us.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserSubscriptionClient) DeleteOneID(id string) *UserSubscriptionDeleteOne {
	builder := c.Delete().Where(usersubscription.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserSubscriptionDeleteOne{builder}
}

// Query returns a query builder for UserSubscription.
func (c *UserSubscriptionClient) Query() *UserSubscriptionQuery {
	return &UserSubscriptionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserSubscription},
		inters: c.Interceptors(),
	}
}

// Get returns a UserSubscription entity by its id.
func (c *UserSubscriptionClient) Get(ctx context.Context, id string) (*UserSubscription, error) {
	return c.Query().Where(usersubscription.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserSubscriptionClient) GetX(ctx context.Context, id string) *UserSubscription {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserSubscription.
func (c *UserSubscriptionClient) QueryUser(us *UserSubscription) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := us.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(usersubscription.Table, usersubscription.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, usersubscription.UserTable, usersubscription.UserColumn),
		)
		fromV = sqlgraph.Neighbors(us.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserSubscriptionClient) Hooks() []Hook {
	return c.hooks.UserSubscription
}

// Interceptors returns the client interceptors.
func (c *UserSubscriptionClient) Interceptors() []Interceptor {
	return c.inters.UserSubscription
}

func (c *UserSubscriptionClient) mutate(ctx context.Context, m *UserSubscriptionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserSubscriptionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserSubscriptionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserSubscriptionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserSubscriptionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown UserSubscription mutation op: %q", m.Op())
	}
}

// VehicleClient is a client for the Vehicle schema.
type VehicleClient struct {
	config
}

// NewVehicleClient returns a client for the Vehicle from the given config.
func NewVehicleClient(c config) *VehicleClient {
	return &VehicleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehicle.Hooks(f(g(h())))`.
func (c *VehicleClient) Use(hooks ...Hook) {
	c.hooks.Vehicle = append(c.hooks.Vehicle, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehicle.Intercept(f(g(h())))`.
func (c *VehicleClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vehicle = append(c.inters.Vehicle, interceptors...)
}

// Create returns a builder for creating a Vehicle entity.
func (c *VehicleClient) Create() *VehicleCreate {
	mutation := newVehicleMutation(c.config, OpCreate)
	return &VehicleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vehicle entities.
func (c *VehicleClient) CreateBulk(builders ...*VehicleCreate) *VehicleCreateBulk {
	return &VehicleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleClient) MapCreateBulk(slice any, setFunc func(*VehicleCreate, int)) *VehicleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleCreateBulk{err: fmt.Errorf("calling to VehicleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vehicle.
func (c *VehicleClient) Update() *VehicleUpdate {
	mutation := newVehicleMutation(c.config, OpUpdate)
	return &VehicleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleClient) UpdateOne(v *Vehicle) *VehicleUpdateOne {
	mutation := newVehicleMutation(c.config, OpUpdateOne, withVehicle(v))
	return &VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleClient) UpdateOneID(id string) *VehicleUpdateOne {
	mutation := newVehicleMutation(c.config, OpUpdateOne, withVehicleID(id))
	return &VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vehicle.
func (c *VehicleClient) Delete() *VehicleDelete {
	mutation := newVehicleMutation(c.config, OpDelete)
	return &VehicleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleClient) DeleteOne(v *Vehicle) *VehicleDeleteOne {
	return c.DeleteOneID(v.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleClient) DeleteOneID(id string) *VehicleDeleteOne {
	builder := c.Delete().Where(vehicle.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleDeleteOne{builder}
}

// Query returns a query builder for Vehicle.
func (c *VehicleClient) Query() *VehicleQuery {
	return &VehicleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicle},
		inters: c.Interceptors(),
	}
}

// Get returns a Vehicle entity by its id.
func (c *VehicleClient) Get(ctx context.Context, id string) (*Vehicle, error) {
	return c.Query().Where(vehicle.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleClient) GetX(ctx context.Context, id string) *Vehicle {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VehicleClient) Hooks() []Hook {
	return c.hooks.Vehicle
}

// Interceptors returns the client interceptors.
func (c *VehicleClient) Interceptors() []Interceptor {
	return c.inters.Vehicle
}

func (c *VehicleClient) mutate(ctx context.Context, m *VehicleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown Vehicle mutation op: %q", m.Op())
	}
}

// VehicleAverageClient is a client for the VehicleAverage schema.
type VehicleAverageClient struct {
	config
}

// NewVehicleAverageClient returns a client for the VehicleAverage from the given config.
func NewVehicleAverageClient(c config) *VehicleAverageClient {
	return &VehicleAverageClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehicleaverage.Hooks(f(g(h())))`.
func (c *VehicleAverageClient) Use(hooks ...Hook) {
	c.hooks.VehicleAverage = append(c.hooks.VehicleAverage, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehicleaverage.Intercept(f(g(h())))`.
func (c *VehicleAverageClient) Intercept(interceptors ...Interceptor) {
	c.inters.VehicleAverage = append(c.inters.VehicleAverage, interceptors...)
}

// Create returns a builder for creating a VehicleAverage entity.
func (c *VehicleAverageClient) Create() *VehicleAverageCreate {
	mutation := newVehicleAverageMutation(c.config, OpCreate)
	return &VehicleAverageCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VehicleAverage entities.
func (c *VehicleAverageClient) CreateBulk(builders ...*VehicleAverageCreate) *VehicleAverageCreateBulk {
	return &VehicleAverageCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleAverageClient) MapCreateBulk(slice any, setFunc func(*VehicleAverageCreate, int)) *VehicleAverageCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleAverageCreateBulk{err: fmt.Errorf("calling to VehicleAverageClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleAverageCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleAverageCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VehicleAverage.
func (c *VehicleAverageClient) Update() *VehicleAverageUpdate {
	mutation := newVehicleAverageMutation(c.config, OpUpdate)
	return &VehicleAverageUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleAverageClient) UpdateOne(va *VehicleAverage) *VehicleAverageUpdateOne {
	mutation := newVehicleAverageMutation(c.config, OpUpdateOne, withVehicleAverage(va))
	return &VehicleAverageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleAverageClient) UpdateOneID(id string) *VehicleAverageUpdateOne {
	mutation := newVehicleAverageMutation(c.config, OpUpdateOne, withVehicleAverageID(id))
	return &VehicleAverageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VehicleAverage.
func (c *VehicleAverageClient) Delete() *VehicleAverageDelete {
	mutation := newVehicleAverageMutation(c.config, OpDelete)
	return &VehicleAverageDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleAverageClient) DeleteOne(va *VehicleAverage) *VehicleAverageDeleteOne {
	return c.DeleteOneID(va.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleAverageClient) DeleteOneID(id string) *VehicleAverageDeleteOne {
	builder := c.Delete().Where(vehicleaverage.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleAverageDeleteOne{builder}
}

// Query returns a query builder for VehicleAverage.
func (c *VehicleAverageClient) Query() *VehicleAverageQuery {
	return &VehicleAverageQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicleAverage},
		inters: c.Interceptors(),
	}
}

// Get returns a VehicleAverage entity by its id.
func (c *VehicleAverageClient) Get(ctx context.Context, id string) (*VehicleAverage, error) {
	return c.Query().Where(vehicleaverage.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleAverageClient) GetX(ctx context.Context, id string) *VehicleAverage {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *VehicleAverageClient) Hooks() []Hook {
	return c.hooks.VehicleAverage
}

// Interceptors returns the client interceptors.
func (c *VehicleAverageClient) Interceptors() []Interceptor {
	return c.inters.VehicleAverage
}

func (c *VehicleAverageClient) mutate(ctx context.Context, m *VehicleAverageMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleAverageCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleAverageUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleAverageUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleAverageDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown VehicleAverage mutation op: %q", m.Op())
	}
}

// VehicleSnapshotClient is a client for the VehicleSnapshot schema.
type VehicleSnapshotClient struct {
	config
}

// NewVehicleSnapshotClient returns a client for the VehicleSnapshot from the given config.
func NewVehicleSnapshotClient(c config) *VehicleSnapshotClient {
	return &VehicleSnapshotClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vehiclesnapshot.Hooks(f(g(h())))`.
func (c *VehicleSnapshotClient) Use(hooks ...Hook) {
	c.hooks.VehicleSnapshot = append(c.hooks.VehicleSnapshot, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vehiclesnapshot.Intercept(f(g(h())))`.
func (c *VehicleSnapshotClient) Intercept(interceptors ...Interceptor) {
	c.inters.VehicleSnapshot = append(c.inters.VehicleSnapshot, interceptors...)
}

// Create returns a builder for creating a VehicleSnapshot entity.
func (c *VehicleSnapshotClient) Create() *VehicleSnapshotCreate {
	mutation := newVehicleSnapshotMutation(c.config, OpCreate)
	return &VehicleSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VehicleSnapshot entities.
func (c *VehicleSnapshotClient) CreateBulk(builders ...*VehicleSnapshotCreate) *VehicleSnapshotCreateBulk {
	return &VehicleSnapshotCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VehicleSnapshotClient) MapCreateBulk(slice any, setFunc func(*VehicleSnapshotCreate, int)) *VehicleSnapshotCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VehicleSnapshotCreateBulk{err: fmt.Errorf("calling to VehicleSnapshotClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VehicleSnapshotCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VehicleSnapshotCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VehicleSnapshot.
func (c *VehicleSnapshotClient) Update() *VehicleSnapshotUpdate {
	mutation := newVehicleSnapshotMutation(c.config, OpUpdate)
	return &VehicleSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VehicleSnapshotClient) UpdateOne(vs *VehicleSnapshot) *VehicleSnapshotUpdateOne {
	mutation := newVehicleSnapshotMutation(c.config, OpUpdateOne, withVehicleSnapshot(vs))
	return &VehicleSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VehicleSnapshotClient) UpdateOneID(id string) *VehicleSnapshotUpdateOne {
	mutation := newVehicleSnapshotMutation(c.config, OpUpdateOne, withVehicleSnapshotID(id))
	return &VehicleSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VehicleSnapshot.
func (c *VehicleSnapshotClient) Delete() *VehicleSnapshotDelete {
	mutation := newVehicleSnapshotMutation(c.config, OpDelete)
	return &VehicleSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VehicleSnapshotClient) DeleteOne(vs *VehicleSnapshot) *VehicleSnapshotDeleteOne {
	return c.DeleteOneID(vs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VehicleSnapshotClient) DeleteOneID(id string) *VehicleSnapshotDeleteOne {
	builder := c.Delete().Where(vehiclesnapshot.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VehicleSnapshotDeleteOne{builder}
}

// Query returns a query builder for VehicleSnapshot.
func (c *VehicleSnapshotClient) Query() *VehicleSnapshotQuery {
	return &VehicleSnapshotQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVehicleSnapshot},
		inters: c.Interceptors(),
	}
}

// Get returns a VehicleSnapshot entity by its id.
func (c *VehicleSnapshotClient) Get(ctx context.Context, id string) (*VehicleSnapshot, error) {
	return c.Query().Where(vehiclesnapshot.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VehicleSnapshotClient) GetX(ctx context.Context, id string) *VehicleSnapshot {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryAccount queries the account edge of a VehicleSnapshot.
func (c *VehicleSnapshotClient) QueryAccount(vs *VehicleSnapshot) *AccountQuery {
	query := (&AccountClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vs.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vehiclesnapshot.Table, vehiclesnapshot.FieldID, id),
			sqlgraph.To(account.Table, account.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vehiclesnapshot.AccountTable, vehiclesnapshot.AccountColumn),
		)
		fromV = sqlgraph.Neighbors(vs.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VehicleSnapshotClient) Hooks() []Hook {
	return c.hooks.VehicleSnapshot
}

// Interceptors returns the client interceptors.
func (c *VehicleSnapshotClient) Interceptors() []Interceptor {
	return c.inters.VehicleSnapshot
}

func (c *VehicleSnapshotClient) mutate(ctx context.Context, m *VehicleSnapshotMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VehicleSnapshotCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VehicleSnapshotUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VehicleSnapshotUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VehicleSnapshotDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown VehicleSnapshot mutation op: %q", m.Op())
	}
}

// WidgetSettingsClient is a client for the WidgetSettings schema.
type WidgetSettingsClient struct {
	config
}

// NewWidgetSettingsClient returns a client for the WidgetSettings from the given config.
func NewWidgetSettingsClient(c config) *WidgetSettingsClient {
	return &WidgetSettingsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `widgetsettings.Hooks(f(g(h())))`.
func (c *WidgetSettingsClient) Use(hooks ...Hook) {
	c.hooks.WidgetSettings = append(c.hooks.WidgetSettings, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `widgetsettings.Intercept(f(g(h())))`.
func (c *WidgetSettingsClient) Intercept(interceptors ...Interceptor) {
	c.inters.WidgetSettings = append(c.inters.WidgetSettings, interceptors...)
}

// Create returns a builder for creating a WidgetSettings entity.
func (c *WidgetSettingsClient) Create() *WidgetSettingsCreate {
	mutation := newWidgetSettingsMutation(c.config, OpCreate)
	return &WidgetSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WidgetSettings entities.
func (c *WidgetSettingsClient) CreateBulk(builders ...*WidgetSettingsCreate) *WidgetSettingsCreateBulk {
	return &WidgetSettingsCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WidgetSettingsClient) MapCreateBulk(slice any, setFunc func(*WidgetSettingsCreate, int)) *WidgetSettingsCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WidgetSettingsCreateBulk{err: fmt.Errorf("calling to WidgetSettingsClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WidgetSettingsCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WidgetSettingsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WidgetSettings.
func (c *WidgetSettingsClient) Update() *WidgetSettingsUpdate {
	mutation := newWidgetSettingsMutation(c.config, OpUpdate)
	return &WidgetSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WidgetSettingsClient) UpdateOne(ws *WidgetSettings) *WidgetSettingsUpdateOne {
	mutation := newWidgetSettingsMutation(c.config, OpUpdateOne, withWidgetSettings(ws))
	return &WidgetSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WidgetSettingsClient) UpdateOneID(id string) *WidgetSettingsUpdateOne {
	mutation := newWidgetSettingsMutation(c.config, OpUpdateOne, withWidgetSettingsID(id))
	return &WidgetSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WidgetSettings.
func (c *WidgetSettingsClient) Delete() *WidgetSettingsDelete {
	mutation := newWidgetSettingsMutation(c.config, OpDelete)
	return &WidgetSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WidgetSettingsClient) DeleteOne(ws *WidgetSettings) *WidgetSettingsDeleteOne {
	return c.DeleteOneID(ws.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WidgetSettingsClient) DeleteOneID(id string) *WidgetSettingsDeleteOne {
	builder := c.Delete().Where(widgetsettings.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WidgetSettingsDeleteOne{builder}
}

// Query returns a query builder for WidgetSettings.
func (c *WidgetSettingsClient) Query() *WidgetSettingsQuery {
	return &WidgetSettingsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWidgetSettings},
		inters: c.Interceptors(),
	}
}

// Get returns a WidgetSettings entity by its id.
func (c *WidgetSettingsClient) Get(ctx context.Context, id string) (*WidgetSettings, error) {
	return c.Query().Where(widgetsettings.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WidgetSettingsClient) GetX(ctx context.Context, id string) *WidgetSettings {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a WidgetSettings.
func (c *WidgetSettingsClient) QueryUser(ws *WidgetSettings) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ws.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(widgetsettings.Table, widgetsettings.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, widgetsettings.UserTable, widgetsettings.UserColumn),
		)
		fromV = sqlgraph.Neighbors(ws.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WidgetSettingsClient) Hooks() []Hook {
	return c.hooks.WidgetSettings
}

// Interceptors returns the client interceptors.
func (c *WidgetSettingsClient) Interceptors() []Interceptor {
	return c.inters.WidgetSettings
}

func (c *WidgetSettingsClient) mutate(ctx context.Context, m *WidgetSettingsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WidgetSettingsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WidgetSettingsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WidgetSettingsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WidgetSettingsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("db: unknown WidgetSettings mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Account, AccountSnapshot, AppConfiguration, ApplicationCommand, AuthNonce, Clan,
		CronTask, DiscordInteraction, GameMap, GameMode, LeaderboardScore, Session,
		User, UserConnection, UserContent, UserSubscription, Vehicle, VehicleAverage,
		VehicleSnapshot, WidgetSettings []ent.Hook
	}
	inters struct {
		Account, AccountSnapshot, AppConfiguration, ApplicationCommand, AuthNonce, Clan,
		CronTask, DiscordInteraction, GameMap, GameMode, LeaderboardScore, Session,
		User, UserConnection, UserContent, UserSubscription, Vehicle, VehicleAverage,
		VehicleSnapshot, WidgetSettings []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
